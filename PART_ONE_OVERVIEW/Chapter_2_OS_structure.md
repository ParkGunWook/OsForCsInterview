# What we gonna study?

운영체제는 프로그램이 실행되는 환경을 제공한다.  내부적으로, 운영체제는 그들이 여러개의 라인으로 구성되는 메이크업에 따라 달라진다. 새로운 운영체제의 디자인은 매우 중요하다. 디자인을 시작하기 전에 운영체제를 잘 정의하는 것이 중요하다. 이런 목표는 다양한 알고리즘과 전략을 고른 기초이다.

우리는 운영체제를 다양한 우세로 볼수있다. 한가지 관점은 시스템이 제공하는 서비스에 집중하는 것이다. 다른 하나는 프로그래머와 유저가 사용하능하게하는 인터페이스이다. 세번째는 그것의 구성요소와 내부연결이다. 이 장에서는, 우리는 운영체제의 3가지 관점을 바라볼 것이다. 사용자, 프로그래머, 운영체제 디자이너의 관점이다. 우리는 운영체제가 어떤 서비스를 제공하는지 고려하고 그들이 어떻게 제공되는지 그들이 어떻게 디버깅되는지, 그리고 이런 시스템을 디자인하는 여러가지 방법론이 된다. 마지막으로 우리는 어떻게 운영체제가 만들어지고 어떻게 컴퓨터가 운영체제를 실행하는지 보겠다.

# Objectives

1. 운영체제가 제공하는 서비스를 확인한다.
2. 시스템 콜이 어떻게 운영체제 서비스를 제공하는지 설명한다.
3. 단일, 레이어드, 마이크로 커널, 모듈러, 하이브리드 전략을 비교하며 운영체제 디자인을 살펴본다.
4. 운영체제를 부팅하는 프로세스를 설명한다.
5. 운영체제 퍼포먼스를 관찰하는 툴을 적용한다.
6. 리눅스 커널을 간섭하는 커널 모듈을 디자인하고 사용한다.

## 2.2 Operating-System Service

운영체제는 프로그램을 실행하는 환경을 제공한다. 그것은 프로그램을 모두 가능하게 하는 서비스이다. 특정 서비스들은 물론 다른 운영체제에서도 제공하지만, 우리는 일반적인 클래스를 구별한다. 

- 유저 인터페이스
대부분의 운영체제는 UI를 가지고 있다. 이 인터페이스는 몇가지 형태가 있다. 보통은, GUI가 사용된다. 마우스로 무언가를 가르키고 키보드로 텍스트를 입력한다. 모바일 시스템은 터치-스크린 인터페이스를 제공해서 손가락으로 버튼을 누른다. 다른 방법은 comman-line-interface로, 텍스트 커맨드와 그들을 입력하는 방법이다. 몇몇은 이 3가지를 모두 지원한다.

- 프로그램 실행
시스템은 메모리에서 프로그램을 불러와서 프로그램을 실행한다. 프로그램은 반드시 실행을 정상이든 비정상으로 끝내야한다.

- I/O operations
작동중인 프로그램은 파일이나 I/O 디바이스와 같은 I/O가 필요하다. 특정 장비를 위해서, 특별한 함수가 필요하다. 효율성과 보호를 위해서, 유저는 보통 I/O 디바이스를 직접 통제할 수 없다. 그러므로 운영체제는 반드시 I/O를 제공해야한다.

- 파일시스템 조작

파일 시스템은 특정한 관심이다. 명백하게, 프로그램은 디렉토리와 파일을 읽고 쓸 수 있어야한다. 그들은 또한 주어진 파일을 찾거나, 그들의 이름으로 삭제하거나 생성할 수 있어야한다. 마지막으로는, 몇몇 운영체제들은 디렉토리나 파일에 그들의 소유권에 기반해서 접근을 거부하거나 승낙할 수 있어야한다. 많은 운영체제들은 다양한 파일 시스템을 제공하고, 때때로는 개인적 선택을 승낙하고 특정 기능이나 성능 특성을 제공한다.

- 통신

프로세스가 다른 프로세스와 정보를 교환해야하는 많은 상황이 있다. 이런 통신은 같은 컴퓨터에서 실행중인 프로세스간에 생기거나  네트워크로 묶인 다른 컴퓨터 시스템에서 일어난다. 통신은 같은 메모리 영역의 **공유 메모리**를 통해서 일어나거나, 미리 정의된 포멧의 정보 패킷이 운영체제를 통해서 움직이는 **메시지 패싱**이 가능하다.

- 에러 감지
운영체제는 에러를 지속적으로 감지하고 조정한다. 에러들은 CPU와 메모리 하드웨어, I/O 디바이스(용지부족, 네트워크 연결 실패, 디스크에서의 패리티 에러), 유저프로그램에서 생길 수 있다. 이런 각각의 에러의 종류는, 운영체제가 반드시 적절한 액션을 취해서 정확하고 일정한 컴퓨팅을 하게 돕는다. 가끔, 시스템 정지외의 방법이 없을 때가 있다. 다른 때에는, 그것은 에러를 일으키는 프로세스를 종료하거나 프로세스 에러코드를 리턴해서 프로세스를 감지하고 고치려고 한다.

운영체제 기능의 다른 세트는 유저보다는 시스템 자체의 효율적인 명령을 보장해준다. 다양한 프로세서를 가진 시스템들은 컴퓨터 리소스를 프로세스간에 나누면서 효율성을 얻었다.

- 리소스 할당

동시에 많은 프로세스가 작동하면, 리소스들은 반드시 각각에게 할당되어야한다. 운영체제는 다양한 리소스를 관리한다. 몇몇(CPU 사이클, 메인메모리, 파일 저장소)는 특별한 할당 코드가 필요한데 비해서, 몇몇(I/O 디바이스)는 일반적인 요청과 릴리즈 코드가 있을 것이다. 예를 들어서, CPU를 가장 최고로 사용하는 것을 정하는 방법은, 운영체제가 CPU의 속도, 실행되어야만하는 프로세스, CPU 위의 프로세싱 코어 같은 CPU스케쥴링 루틴을 가지는 것이다. 그리고 프린터, 유에스비, 주변장치를 할당하는 많은 루틴이 있다.

- 로깅

우리는 어떤 프로그램이 얼마나 많고 다양한 컴퓨터 리소스를 사용하는지 추적해야한다. 이런 기록은 회계로 사용되거나 사용 통계를 누적한다. 사용통계는 컴퓨터 서비스 향상을 위해 시스템을 변경할 시스템 관리자에게 귀중한 도구이다.

- 보호와 보안 

멀티 유저와 네트워크속의 컴퓨터 시스템에 저장된 정보의 소유자는 정보의 사용을 제어하고 싶다. 몇몇 프로세스가 동시에 실행될 때, 그것은 하나가 다른 것에 의해서 방해되는 것은 불가능해야한다. 보호는 시스템 리소스로 부터의 모든 접근이 통제되는 것이다. 외부인으로부터의 시스템의 보안은 또한 중요하다. 이런 보안은 각각의 유저가 시스템에게 자신을 자신이라고 입증하는 것이다. 외부 I/O 디바이스, 네트워크 어댑터를 불분명한 접근과 녹음으로 보호하는 것으로 확장되기도 한다. 만약 시스템이 보호되고 보안되면, 경고는 그것을 통해서 생긴다. 체인은 또한 가장 약한 링크만큼 강하다.

## 2.2 User and Operating System Interface

우리는 운영체제 시스템과 유저가 연결되는 인터페이스에 대해서 언급한 적이 있다. 여기서, 우리는 3가지 기초적인 접근이 있다. 하나는 CLI, **command interpreter**, 유저가 커맨드를 운영체제에 직접 입력하는 방법이다. 다른 두가지 방법은 유저가 GUI를 통해서 운영체제와 연결되는 인터페이스이다.

### 2.2.1 커맨드 인터프리터

리눅스, 유닉스, 윈도우를 포함한 대부분의 운영체제는 프로세스가 실행되거나 유저가 로그인 했을 떄 커맨드 인터프리터를 특별한 프로그램을 제공한다. 예를 들어 유닉스와 리눅스 시스템에서, 유저는 C-shell, Bourne-Again shell, Korn shell이라는 다양한 쉘을 제공한다. 서드 파티 쉘과 유저가 만든 쉘또한 존재한다. 대부분의 쉘들은 비슷한 기능을 제공하고 유저의 기호에 따라서 선택된다.

커맨드 인터프리터의 주요한 함수는 유저가 지정한 커맨드를 얻어내고 실행한다. 많은 커맨드는 이런 수준으로 제공된다. : 삭제, 리스트, 생성, 프린트, 카피, 실행 등등이다. 유닉스 시스템에서 실행가능한 다양한 유닉스 시스템은 이런 방식으로 실행된다. 이런 커맨드들은 두가지 방법으로 실행된다.

한가지 접근은, 커맨드 인터프리터는 그 자체로 커맨드를 실행시키는 코드를 포함하고 있다. 예를 들어, 파일을 삭제하는 커맨드는 커맨드 인터프리터가 그것의 코드 구역을 이동해서 파라미터를 결정한 후에 적절한 시스템 콜을 부른다. 이런 경우에는, 많은 수의 커맨드는 커맨드 인터프리터의 사이즈를 결정하기에 커맨드는 그것의 실행 코드를 필요로 한다.

다른 접근은, 유닉스에서 쓰이는데, 커맨드를 시스템 프로그램으로 실행한다. 이런 경우에는 커맨드 인터프리터는 커맨드를 이해하는 것이 아니다. 그것은 커맨드를 메모리에서 부를 파일을 인식하고 실행하는 것이다. 따라서 유닉스가 파일을 지우게 하는 것이다.

rm file.txt는 rm이라는 파일을 찾게하고 파일을 메모리에서 부르고 그것의 파라미터를 file.txt로 한다. rm 코맨드와 관련된 논리는 file rm에 있는 코드에서 확실히 정의된다. 이런 방식으로, 프로그래머들은 새로운 파일을 만들고 적적한 프로그램 로직을 만듬으로서 쉽게 새로운 커맨드를 시스템에 추가한다. 커맨드 인터프리터 프로그ㅐㄻ은 매우 작지만, 새로운 커맨드 추가를 위해서 바뀔필요는 없다.

### 2.2.2 GUI

운영체제가 사용자와 인터페이싱하는 두번째 방법은 우리가 친숙하게 사용하는 GUI이다. 커맨드를 CLI로 직접치는 것보다는, 유저는 마우스 기반의 윈도우와 메뉴 시스템을 사용하는 것이다. 유저는 마우스를 이미지의 포인트로 옮긴다. 그리고 그 이미지들은 프로그램, 파일, 디렉토리, 시스템 함수 등이 있다. 마우스 포인터의 위치에 따라서, 마우스 버튼을 클릭하는 것은 프로그램을 깨우고, 파일이나 디렉토리를 고르고 커맨드를 포함한 메뉴를 내린다.

GUI는 1970년도에 제록스 PARC 연구소에서 처음 나타났다. 첫번째 GUI는 제록스 알토 컴퓨터였다. 그러나 그래픽 인터페이스는 애플의 메킨토시 컴퓨터와 함께 급진했다. 매킨토시 운영체제의 유저 인터페이스는 다양한 변화를 다년간 겪었고, 가장 큰 변화는 맥OS의 아쿠아 인터페이스이다. MS사의 첫 윈도우는 MS-DOS 운영체제의 GUI 추가버전이다. 그 후에 윈도우는 그것의 기능성을 향상시키면서 GUI의 모습을 변화시켰다. 전통적으로, 유닉스 시스템은 CLI에 의해서 지배되었다. 다양한 GUI 인터페이스는 존재하나, GUI 디자인은 오픈소스에 의해서 큰 영향을 받았다.

### 2.2.3 터치 스크린 인터페이스

CLI와 마우스 키보드 시스템이 모바일에서는 불편해서 스마트폰과 태블릿컴퓨터는 터치 스크린을 택하게되었다. 유저는 터치스크린의 행동으로 소통한다. 비록 초기의 스마트폰은 물리적 키보드를 지원했지만 이제는 키보드는 보통 터치스크린 위에서 실행된다.

### 2.2.4 인터페이스의 선택

GUI를 쓸지, CLI를 쓸지는 컴퓨터를 사용하는 사람의 개인 선호에 따라 달린다. 컴퓨터를 관리하는 시스템 어드민과 시스템을 깊게 이해하는 파워유저는 CLI를 선호한다. 그들에게는 이것이 더욱 효율적이고 원하는 행동에 대한 더 빠른 접근을 주기 때문이다. 실제로, 시스템위에서 오직 시스템 함수의 하위세트는 GUI를 통해서만 되고 나머지는 CL 지식에 맡겨둔다. 더 나아가, CLI는 보통 반복적인 행동을 쉽게하고, 몇몇 부분에서는 그들의 프로그래머빌리티를 가진다. 예를 들어 반복되는 동작들은 일련의 command line step이 필요한데, 이런 step은 파일에 저장될 수 있고, 파일은 프로그램처럼 돌아갈 수 있다. 프로그램은 실행코드로만 컴파일 되지 않고 CLI에 의해서 해석된다. 이런 쉘 스크립트들은 보통 시스템에서 일반적이다.

반면에 대부분의 윈도우 유저들은 윈도우 GUI 유저들에게 행복을 주고 대부분이 절대 쉘 인터페이스를 사용하지 않는다. 최근 버전의 윈도우 운영체제 버전은 데스크탑을 위한 GUI와 태블릿을 위한 터치 스크린을 제공한다. 이런 다양한 변화는 매킨토시 운영체제가 좋은 연구를 보여주었기 때문이다. 역사적으로, MacOs는 CLI를 제공하지 않았고 오직 GUI만을 사용하게했다. 그러나 macOS의 출시와 함께 운영체제는 아쿠아 GUI와 CLI를 모두 제공했다.

비록 CLI를 제공하는 IOS와 안드로이드 시스템이 있지만, 그들은 거의 사용되지 않는다. 대신에 대부분의 유저들은 터치스크린을 이용한다.

유저 인터페이스는 시스템마다 다르고 같은 시스템에서도 유저마다 다르다. 그러나 실제 시스템 구조는 점점 사라지고 있다. 유용하고 직관적인 유저인터페이스의 운영체제 의 직접적인 함수는 아니다. 이 책에서는 적절한 서비스를 제공하는 근본적인 문제에 집중하겠다. 운영체제의 여러가지 관점에서, 우리는 유저 프로그램과 시스템 프로그램을 구별하지 않는다.

## 2.3 시스템 콜

**시스템 콜**은 운영체제에 의해서 서비스를 제공하는 인터페이스를 만들어주게한다. 이런 콜들은 보통 C언어나 C++로 쓰여있고, 낮은 레벨의 일(예를 들어, 하드웨어가 직접 연결된 것이다.)은 어셈블리어 명령어로 쓰여있다.

### 2.3.1 예시

운영체제가 시스템콜을 가능하게 만드는 것을 논의하기 이전에, 먼저 어떻게 시스템 콜이 사용되는지 생각해보자 : 하나의 파일로부터 데이터를 읽고 다른 파일로부터 복사하는 프로그램을 만들겠다. 먼저 프로그램이 필요로하는 인풋은 두가지이다.(인풋파일과 아웃풋 파일) 이런 이름들은 많은 방식으로 되어있고, 운영체제 디자인에 따라 다르다. 두파일의 이름은 커맨드에 전달하는 한가지 방법이다.

cp in.txt out.txt

이러한 커맨드들은 인풋 파일 in.txt를 아웃풋 파일 ou.txt로 카피한다. 두번쨰 방법은 프로그램이 유저에게 이름을 묻는 것이다. 반응형 시스템에서, 이런 접근은 시스템콜의 일련을 필요로하고, 처음으로는 프롬프팅 메시지를 작성하고 키보드로부터 두 파일을 읽어들인다. 마우스와 아이콘 베이스의 시스템에서는, 파일 이름의 메뉴는 윈도우에서 보여진다. 유저는 소스 이름을 선택하기 위해서 마우스를 선택하고, 윈도우는 정해진 도착 윈도우에 의해서 열린다. 이런 시퀀스는 많은 I/O 시스템 콜을 필요로 한다. 

두 파일 이름이 얻어지면, 프로그램은 반드시 인풋 파일을 열고 아웃풋 파일을 생성하고 열어낸다. 각각의 명령은 다른 시스템 콜이 필요하다. 각각의 시스템에 예상되는 에러는 조정되어야한다. 예를 들어서, 프로그램이 인풋 파일을 열려고하면, 그것은 그곳에 파일이 없는지 찾아내야하고 접근으로부터 파일이 보호되어있을수 있다. 이러한 경우에 프로그램은 에러메시지를 내보내야하고 비정상적인 종료를 한다. 만약 인풋이 존재하면 , 우리는 반드시 새로운 아웃풋 파일을 만들어내야한다. 우리는 아웃풋 파일이 같은 이름으로 존재하는 것을 볼수도 있다. 이런상황은 프로그램이 멈추게 할 수도있고 존재하는 파일을 지우고 새로운 파일을 만들수도있다. 인터렉티브 시스템에서는 유저에게 파일을 교체할지 프로그램을 멈출기 물어볼 수 도있다.

두 파일이 준비되면, 우리는 인풋 파일로 부터 루프를 입력하고 아웃풋 파일을 쓰기시작한다. 각각의 읽기와 쓰기는 가능한 에러 컨티션을 위해서 상태 정보를 리턴해야한다. 인풋에서는, 프로그램은 파일의 끝에 도달하거나 읽기에서 하드웨어 페일이 나온다. 쓰기에서는, 다양한 에러가 아웃풋 디바이스에서 일어날 수 있다.

마지막으로, 전체 파일이 복사되면, 프로그램은 두 파일을 모두 닫고, 콘솔이나 윈도우에 메시지를 쓰고 마침내 정상적으로 종료된다.

### 2.3.2 애플리케이션 프로그래밍 인터페이스

말햇듯이, 간단한 프로그램은 운영체제의 무거운 사용을 만들 수 있다. 자주, 시스템은 일초마다 수천만가지의 시스템 콜을 생성한다. 대부분의 프로그래머들은 이러한 자세한 사항을 살피지 않는다. 보통, 앱 개발자는 API에 따라서 프로그램을 디자인한다. API는 애플리케이션 프로그래머가 사용가능한 다양한 함수를 제공한다. 이 함수들은 각각의 함수의 파라미터를 포함하고 프로그래머가 예상하는 리턴값을 돌려준다. 대부분의 API에서는 윈도우 시스템을 위한 윈도우 API이다.(포식스는 포식스API)) 자바 API는 자바 가상머신에서 돌아간다. 씨로 쓰여진 유닉스와 리눅스 프로그램은 libc라고 불린다. 이런 시스템 콜 이름은 일반적인 예시이다. 각각의 운영체제는 각각의 시스템콜 이름이 있다. 화면뒤에서, API를 만드는 함수는 앱 프로그래머 입장에서 시스템콜을 만들어낸다. 예를들어 윈도우 함수 CreateProcess()는 실제로 NTCreateProcess() 시스템콜을 윈도우 커널에서 불러들인다. 

앱 프로그래머가 시스템 콜보다 API를 부르는 이유가 무엇일까? 한가지 장점은 프로그램 휴대성이다. 프로그램을 디자인하는 앱 프로그래머는 그녀의 프로그램이 어떤 시스템이든 같은 API에서는 그녀의 프로그램이 실행되고 컴파일되기를 원한다. 더욱이 실제의 시스템콜은 보통 API더 힘들게 만든다. 그럼에도 불구하고, API와 커널의 시스템 콜에서는 강력한 관련점이 있다. 실제로, 많은 포식스와 윈도우 API는 유닉스, 리눅스, 윈도우가 제공하는 네이티브 시스템 콜과 배우 유사하다.

다른 핸들링 시스템 콜의 중요한 요소는 **런타임 환경**이다- 주어진 언어로 애플리케이션을 실행하는데 필요한 컴파일러와 인터프리터나 라이브러리나 로더 같은 소프트웨어 모음이다. RTE는 운영체제에서 시스템콜을 만드는 링크를 시스템콜 인터페이스에 제공한다. 시스템 콜 인터페이스는 API에서 함수를 뺏고 운영체제에서 필요한 시스템콜을 실행한다. 특히, 다양한 것들이 각각의 시스템콜과 연관되어있고 시스템콜 인터페이스는 이런 넘버에 따른 테이블 인덱스를 유지한다. 시스템 콜 인터페이스는 운영체제 커널안에서 의도된 시스템 콜을 실행하고 시스템콜의 상태를 반환한다.

콜러는 어떻게 시스템콜이 작동되고 어떤 일을 하는지 전혀 모른다. 오히려 콜러는 API에 복종하고 운영체제가 시스템콜의 실행의 결과를 받아들인다. 그러므로 대부분의 운영체제 인터페이스는 API로부터 프로그래머에게 숨어있고 RTE에 의해서 관리된다. 

시스템 콜은 다양한 방식에서 일어나고 컴퓨터 사용에 따라 달린다. 보통, 정보는 소망된 시스템콜의 정보보다 많이 필요로한다. 정확한 타입과 정보의 양은 특정한 운영체제와 시스템콜에 따라서 달라진다. 예를 들어서 인풋을 얻기위해서, 우리는 파일 또는 장치 소스를 특정화하고 읽혀야하는 인풋의 메모리 버퍼의 길이와 주소를 필요로한다. 물론 디바이스나 파일과 길이는 내부 콜에서 정확해야한다. 

운영체제에서는 파라미터를 전달하는 3가지 일반적인 방법론이 존재한다. 가장 간단한 방법은 레지스터를 통해서 파라미터를 넘기는 것이다. 몇가지 경우에는 물론 레지스터보다 파라미터가 더 많다. 이런 경우에는, 파라미터는 블록이나 테이블, 메모리에 저장되고 레지스터에는 파라미터의 주소가 저장된다. 리눅스는 이런 방법의 조합을 사용한다. 만약 5개나 적인 파라미터가 있으면, 레지스터가 사용된다. 아니라면 블록 메서드가 사용된다. 파라미터는 운영체제에서 프로그램 유저에 의해서 스택에서 푸시되거나 운영체제에 의해서 팝된다. 몇몇 운영체제는 블럭이나 스택 방법을 더 선호하는데 이런 방법은 파라미터의 갯수에 제한이 없기 떄문이다.

### 2.3.3 시스템 콜의 종류

시스템 콜은 6가지의 메이저 카테고리로 그룹된다 : 프로세스 컨트롤, 파일 관리, 디바이스 관리, 정보 유지, 통신, 보호가 있다. 우리는 운영체제에 의해서 제공되는 여러가지 타입의 시스템 콜을 논의하겠다. 대부분의 시스템 콜은 뒷 챕터에 나올 개념들을 서포트하거나 서포트 받는다. 이 책에서 말했듯이, 우리는 시스템콜을 제너릭한 이름으로 부르겠다. 이책에서 우리는 유닉스, 리눅스, 윈도우에 상응하는 실제 예시도 제공하겠다.

> Porcess Control
> - Create process, terminate process
> - 로드, 실행
> - 프로세스 성질 얻기 혹은 설정
> - 이벤트를 기다리거나 시그널
> - 메모리 할당 및 해제
> File management
> - 파일 생성, 삭제
> - 열기, 닫기
> - 읽기, 쓰기, 재위치
> - 파일 성질 얻기, 설정
> 디바이스 관리
> - 디바이스 호출, 해제
> - 읽기, 쓰기, 재위치
> - 디바이스 성질 얻기, 설정
> 정보 유지
> - 시간 혹은 날짜 얻기, 설정
> - 시스템 데이터 얻기, 설정
> - 프로세스, 파일, 디바이스 성질 얻기
> - 프로세스, 파일, 디바이스 성질 설정
> 통신
> - 통신 연결 생성, 삭제
> - 메시지 보내기, 받기
> - 상태 정보 전이
> - 먼 디바이스 부착 및 해제
> 보호
> - 파일 허가 얻기
> - 파일 허가 설정

#### 2.3.3.1 프로세스 컨트롤

실행중인 프로그램은 그것의 실행을 정상적(end()) 또는 비정상적(abort())로 멈출 필요가 있다. 만약 시스템 콜이 현재의 프로그램을 비정상적으로 종료하거나, 만약 프로그램이 문제에 진입하고 에러 트랩을 야기하면 버려진 메모리는 사라지고 에러메시지가 생성된다. 이 버려진 메모리는 디스크의 특별한 로그파일에 쓰이거나 에러 원인을 찾기 위해서 디버거(프로그래머가 에러를 찾거나 고치는 것을 돕는 시스템 프로그램)에 의해서 측정된다. 이런 정상 또는 비정상적인 상황속에서, 운영체제는 반드시 커맨드 인터프리터 발생으로 컨트롤을 옮겨야한다. 이런 커맨드 인터프리터는 다음 커맨드를 읽는다. 상호적인 시스템에서, 커맨드 인터프리터는 간단하게 다음 커맨드를 진행한다. 그것은 유저가 에러에 따라 유저가 다음 커맨드를 입력할 것을 예상하기 때문이다. GUI 시스템에서는, 팝업 윈도우가 에러를 유저에게 알리고 가이드를 제공한다. 몇몇 시스템은 에러가 생긴 시점에 특별한 리커버리 액션을 허용한다. 만약 프로그램이 에러를 그것의 인풋에서 찾으면 비정상 종료를 원하는데, 그것은 에러 레벨을 또한 정의하기를 원한다. 더 심각한 에러는 높은 레벨 에러 파라미터를 가르킬 수도 있다. 정상과 비정상 종료를 정상 종료를 에러 레벨 0으로 설정함으로서 합쳐서 사용할 수 있다. 커맨드 인터프리터나 따라오는 프로그램은 에러레벨을 다음 행동을 자동으로 실행하기 위해서 사용할 수도 있다.

한프로그램을 싱행하는 프로세스는 다른 프로그램을 loag()와 excute()하고 싶을 수도 있다. 이런 기능은 커맨드 인터프리터가 지시하는 프로그램을 실행하는 것을 허용한다. 예를 들어서, 유저 커맨드 또는 마우스의 클릭이다. 흥미로운 질문은 로드된 프로그램이 종료될때 어디에 컨트롤을 리턴하는 것이다. 이 질문은 존재하는 프로그램이 사라지거나 저장되었거나 새로운 프로그램이 동시에 실행될때 관련되어 있다.

만약 존재하는 프로그램에 컨트롤이 리턴되면 새로운 프로그램은 종료되고, 우리는 반드시 존재하는 프로그램의 메모리 이미지를 저장해야한다. 그러므로 우리는 한개의 프로그램이 다른 프로그램을 부르는 메커니즘을 효과적으로 만들 수 있다. 만약 두개의 프로그램이 동시에 지속되면, 우리는 새로운 프로세스를 멀티프로그램을 위해서 생성한다. 자주, 시스템 콜은 이목적을 위해서 생성된다.(create_process)

만약 우리가 새로운 프로세스를 만들면, 우리는 그것의 실행을 컨트롤할 수 있다. 이런 컨트롤은 프로세서의 성질을 결정하거나 리셋할 수 있다.(프로세스 우선권, 그것의 맥시멈 실행시간 등등(get_process_attributes() and set_process_attributes())). 우리는 우리가 만든 프로세스를 종료하고 싶을수도 있다.(terminate_process()) 만약에 우리가 그것이 잘못되었거나 더이상 필요없다면.

새로운 프로세스를 만드는 것에서, 우리는 그들의 실행을 끝낼때까지 기다릴 필요가 있다. 우리는 특정 양의 시간을 기다리는 것을 원할 수도 있다.(wait_time()) 더 가능성 있는 것은, 우리는 특별한 이벤트가 일어나는 것을 기다릴 수도 있다.(wait_event()) 프로세스들은 만드시 이벤트가 일어났을때, 시그널을 보내야한다.(signal_event())

더 자주, 두개 또는 더많은 프로세스는 데이터를 공유한다. 공유되는 데이터의 순결성을 확정하기 위해서, 운영체제는 공유데이터를 잠구는 시스템콜을 프로세서에게 허용해야한다. 그러면 다른 프로세스들은 락이 풀리기 전에 데이터에 접근할 수 없다. 보통, 이런 시스템은 *acquire_lock()*과 *release_lock()*을 포함한다. 이런 타입의 시스템 콜은 동시 실행되는 프로세스와 얘기하고, 챕터 6과 7에서 설명될 것이다.

우리가 다음에 사용할 두 예제의 프로세스 컨트롤은 다양한 측면과 베리에이션이 있다. 싱글 태스킹 시스템과 멀티 태스킹 시스템이다. 이 개념을 명료화하겠다. 아두이노는 마이크로 컨트롤러를 인풋 센서로 포함하는 간단한 하드웨어 플랫폼이다. 인풋 센서는 불빛, 온도, 기압변화의 변화에 반응한다. 아두이노 프로그램을 작성하기위해서, 우리는 PC에 프로그램을 작성하고 PC에서 아두이노 플래시 메모리에 USB를 통해서 컴파일된 프로그램을 작성한다. 대신에, 부트로더로 불리는 작은 소프트웨어는 스케치를 아두이노 메모리의 특별한 지역에 로드한다. 스케치가 로드되면, 그것은 실행을 시작하고, 프로그램된 이벤트가 반응하기를 기다린다. 예를 들어, 만약에 아두이노의 온도 센서가 쓰레시홀드 온도를 넘기면, 스케치는 아두이노를 시작해서 팬을 돌린다. 아두이노는 한가지 일을 하는 시스템이다. 하나의 스케치만이 동시간에 메모리에 존재하기 때문이다. 만약 다른 스케치가 로드되면, 그것은 존재하는 스케치로 교체된다. 더욱이, 아두이노는 하드웨어 인풋 센서 사이에서 아무런 유저 인터페이스를 제공하지 않는다.

FreeBSD(berkeley UNIX에서 만들어짐)는 멀티태스킹 시스템의 예시이다. 유저가 시스템에 로그온하면, 유저가 선택한 쉘은 실행되고 커맨드를 기다리고 유저 요청에따라 프로그램을 실행한다. 그러나 FreeBSD가 멀티태승킹 시스템이어서, 커맨드 인터프리터는 다른 프로그램이 실행될때도 계속 실행한다. 새로운 프로세스를 시작하려면, 쉘은 fork() 시스템콜을 실행한다. 그러면 exec() 시스템콜을 통해 선택된 프로그램이 메모리에 로드된다. 그렇게 프로그램은 실행된다. 커맨드에서 어떻게 생겨났냐에 따라서, 쉘은 프로세스가 끝나는 것을 기다리거나 프로세스가 백그라운드에서 실행된다. 후자의 경우에는 쉘은 다른 커맨드를 당장 입력되기를 기다린다. 프로세스가 백그라운드에서 실행중이면, 그것은 키보드로부터 직접 인풋을 받을 수 없다. 왜냐하면 쉘은 이 리소스를 이미 사용하기 때문이다. I/O는 따라서 파일 또는 GUI를 통해서 실행된다. 반면에, 유저는 쉘에게 다른 프로그램 실행을 마음껏 물을 수 있고, 실행중인 프로세스의 진척을 볼수 있고, 프로그램의 우선도를 바꿀수 있다. 프로세스가 다하면, 그것은 exit() 시스템콜을 종료하기 위해서 실행하고 프로세스 상태를 0또는 0이아닌 에러코드로 리턴한다. 이런 상태나 에러코드는 쉘또는 다른 프로그램에 존재하게 된다. 프로세스는 3장에서 논의되고 fork와 exec를 사용하는 예시를 보이겠다.

#### 2.3.3.2 파일 관리

파일 시스템은 13장에서 15장에서 자세히 다룰 것이다. 여기서는 우리는 몇가지 파일을 다루는 시스템콜을 구분하겠다.

우리는 먼저 create()와 delete() 파일을 필요로한다. 두 시스템은 파일의 이름 또는 파일의 성질또한 필요로할 것이다. 한번 파일이 생성되면, 우리는 사용하려면 open()을 필요로한다. 우리는 또한 read(), write(), reposition()(파일의 끝을 스킵하거나 리와인드한다.)또한 필요할 것이다. 마침내 사용을 다했을떄, 우리는 close() 파일을 실행한다.

우리는 만약 파일 시스템에서 디렉토리 구조를 가진다면 몇몇 디렉토리 명령어 또한 필요로 한다. 덧붙여서, 파일 또는 디렉토리 둘다, 우리는 다양한 성질의 값을 결정하고 필요하다면 그들을 설정한다. 파일 설정은 파일 이름, 파일 타입, 보호 코드, 정보 등등이 필요하다. 적어도 두 시스템 콜, get_file_attributes()와 set_file_attributes()는 이런 함수가 필요하다. 몇몇 운영체제는 더 많은 콜을 제공한다. 이런 콜은 파일이 move()와 copy가 있다. 다른 것은 API가 이런 명령어를 사용해서 우리의 일을 돕는다. 만약 시스템 프로그램이 다른 프로그램에 의해서 불려지면, 각각은 다른 시스템 프로그램에서 API 취급 받는다.

#### 2.3.3.3 디바이스 관리

프로세스는 메인 메모리, 디스크 드라이브, 파일 접근 등 다양한 리소스가 실행되기 위해서 필요하다. 만약 리소스가 존재한다면, 그들은 반드시 보장되어야하고 컨트롤은 유저 프로세스에 리턴되어야한다. 다른 경우에, 프로세스는 충분한 리소스가 존재할때까지 기다려야할 것이다. 운영체제에 의해서 통제되는 다양한 리소스는 디바이스라고 생각할 수 있다. 몇몇 디바이스는 물리 장치(디스크 드라이버)일 것이고, 나머지는 추상적이고 가상 디바이스(파일)일 것이다. 여러 유저를 가진 시스템은 먼저 우리에게 request()로 그것을 독점적으로 사용할 수 있을 지 물어야한다. 우리가 디바이스를 모두 사용하면 realease()를 해준다. 이런 함수는 파일 시스템 콜인 open()과 close()와 비슷하다. 다른 운영체제에서는 디바이스 접근을 관리안할수도 있다. 그 위험은 디바이스 논쟁 위험과 데드락을 만들어낼 수 있다.

디바이스가 요청되면, 우리는 read(), writ- e(), reposition() 디바이스를 할수있다. 사실은 I/O device와 파일은 공통점이 많은 운영체제에서 존재한다. 유닉스같은 곳에서는 두개가 합쳐져있기도하다. 이런 경우에는 시스템콜은 파일과 디바이스에 사용된다. 가끔은, I/O 디바이스는 특별한 파일 이름, 디렉토리, 파일 성질에 따라 구별된다.

유저 인터페이스는 파일을 만들고 디바이스는 존재하는 시스템콜이 달라도 비슷하게 나타난다. 이런 예시는 운영체제와 유저 인터페이스의 많은 디자인에 따라서 달라진다.

#### 2.3.3.4 정보 유지

많은 시스템 콜은 유저 프로그램과 운영체제 간에 정보를 주고받기위해서 존재한다. 예를 들어 대부분의 시스템은 현재의 시간과 날짜를 리턴하는 시스템콜이 있다. 다른 시스템 콜은 운영체제의 버전 넘버, 디스크와 메모리의 여유공간양 같은 시스템에 관련된 정보를 리턴한다. 

다른 시스템 콜은 프로그램 디버깅에 도움이 된다. 많은 시스템들은 dump() memory라는 시스템 콜을 제공한다. 이 영역은 디버깅에 도움이 된다. 프로그램 *strace*는 리눅스 시스템에서 존재하고, 시스템콜이 실행될때마다 리스트된다. 마이크로 프로세서가 CPU 모드를 한단계로 제공해도, 트랩은 모든 명령이 끝나고 CPU에 의해서 실행된다. 트랩은 디버거에 의해서 보통 잡힌다.

많은 운영체제는 프로그램이 어떤 장소에서 얼마나 실행되었는지 알려주는 프로그램의 시간 프로필을 제공한다. 시간 프로필은 시설을 따르거나 일바넉인 시간 인터럽트를 필요로한다. 각각의 타이머 인터럽트 실행에서, 프로그램 카운터의 값은 저장된다. 충분히 빈번한 타이머 인터럽트와 함께, 시간의 통계적인 그림은 프로그램의 다양한 부분을 얻어준다.

덧붙여서, 운영체제는 그것의 프로세스 정보를 모두 가지고, 시스템 콜은 이정보에 접근하는데 사용한다. 보통, 시스테 콜은 프로세스 정보를 얻거나 설정한다.(get_process_attributes() and set_process_attributes()) 3.13절에서 우리는 어떤 정보가 저장되는지 논의하겠다.

#### 2.3.3.5 통신

프로세스간에 두가지 통신 모델이 존재한다. 하나는 메시지 패싱 모델과 하나는 공유 메모리 모델이다. 메시지 패싱 모델에서, 프로세스간 통신은 메시지를 프로세스 간에 교환한다. 메시지는 공통 메일함을 통해서 프로세스간에 직접 또는 간접으로 교환할 수 있다. 통신이 생기기전에, 연결이 열려야한다. 다른 통신자의 이름을 반드시 알아야하고, 같은 시스템의 다른 프로세서나 다른 컴퓨터의 프로세스는 통신 네트워크로 연결되어야한다 네트워크안의 각각의 컴퓨터는 호스트 이름을 가지고 있다. 호스트는 IP같은 네트워크 구별자를 가져야한다. 비슷하게 각각의 프로세스는 프로세스 이름을 가져야하고 운영체제가 프로세스를 언급하는 것에 다라서 이 이름을 구별자로 번역해야한다. get_hostid()와 get_processid() 시스템 콜이 이러한 번역을 진행한다. 구별자는 보통 open()과 close() 콜 같은 일반적인 목적으로 전해지고 open_connection()과 close_connection() 시스템 콜이라는 특별한 것으로 시스템의 통신 모델에 따라 달라진다. 프로세스의 수신자는 보통 통신을 위한 허가를 accept_connectioin()콜을 통해서 얻는다. 대부분의 프로세스들은 특정 목적 daemons로 연결을 얻고, 시스템 프로그램은 그 목적으로 제공된다. 그들은 wait_for_connection() 콜과 연결이 만들어졌을때 깨워진다. 커뮤니케이션의 소스는 클라이언트이고 그것은 recieving damon이라고 불리는 서버이고 read_message()와 write_message() system 콜로 메시지를 주고받는다. 그리고 close_connection()콜로 통신을 종료한다.

#### 2.3.3.6 보호

보호는 컴퓨터 시스템이 리소스 접근을 컨트롤하는 메커니즘으로 제공한다. 역사적으로, 보호는 오직 여러 유저에 의해서 멀티프로그램된 컴퓨터 시스템에서만 고려된다. 그러나 네트워킹과 인터넷의 발전으로, 모든 컴퓨터 시스템은 이 보호가 필요해졌다.

보통, 보호를 제공하는 시스템콜은 set_permisiion()과 get_permission이 있고, 파일과 디스크 같은 리소스 허용 설정을 조절한다. allow_user()와 deny_user() 시스템 콜은 특정 유저가 리소스에 접근할지 말지를 허용한다. 우리는 이런 내용을 보안이라는 더 큰 주제에서 다루도록 하겠다.

## 2.4 시스템 서비스

현대 시스템의 다른 점은 서비스 시스템의 모음이다. 가장 낮은 단계는 하드웨어이다. 그리고 운영체제이고 시스템 서비스, 마지막으로 애플리케이션 프로그램이다. 시스템 서비스는 시스템 유틸리티라고 알려져있고, 프로그램 개발과 실행에 편한 환경을 제공한다. 그들중 몇가지는 간단하게 유저 인터페이스 시스템 콜이다. 다른 것들은 훨씬 복잡하고 여러가지 분야로 나뉠수 있다.

- 파일 관리 : 이런 프로그램은 만들고 삭제하고 복사하고 재정의하고 출력하고 리스트로 만들고 파일과 디렉토리를 관리하고 접근하게한다.

- 상태 정보 : 몇몇 프로그램은 시스템에게 날짜, 시간, 사용가능한 메모리 또는 디스크 공간, 유저의 수, 상태 정보를 묻는다. 다른 것들은 복잡한데, 정확한 성능, 로깅, 디버깅 정보를 제공한다. 보통 이런 프로그램들은 터미널, 파일, GUI를 통해 아웃풋으로 내보내진다. 몇몇 시스템은 레지스트리를 지원하는데, 레지스트리는 환경설정 정보를 저장하고 불러온다.

- 파일 수정 : 몇몇 텍스트 에디터는 디스크나 저장장치에 저장된 파일을 만들거나 수정하는 것이 가능하게한다. 파일을 검색하거나 텍스트의 변형을 수행하는 특별한 커맨드이다.

- 프로그램 언어 지원 : 컴파일러, 어셈블러, 디버거, 프로그램 언어 인터프리터들은 운영체제와 함께 제공되거나 별도의 다운로드로 제공된다.

- 프로그램 로딩과 실행 : 프로그램이 만들어지고 컴파일 되면 그것은 메모리에서 로드되어 실행한다. 그 시스템은 절대적인 로더나 새롭게 위치하는 로더나 링키지 에디터, 오버레이 로더를 제공한다. 높은 수준 언어나 기계어도 디버깅 시스템이 필요하다.

- 통신 : 이런 프로그램은 프로세스, 유저, 컴퓨터 시스템을 가상으로 연결하는 메커니즘을 제공한다. 그들은 유저가 다른이의 스크린에 메시지를 보내게 도와주고, 웹페이지를 탐색하고, 이메일을 보내고, 다른 기계나 다른 사람의 파일을 멀리서 접근하게 해준다.

- 백그라운드 서비스 : 모든 시스템은 특정 시스템 프로그램 프로세스를 부트중에 런칭하는 방법이 있다. 이런 프로세스들은 그들의 작업이 완료되면 사라지고, 다른 것들은 시스템이 멈출때까지 실행한다. 영구적으로 시스템 프로그램 프로세스를 실행하는 것은 서비스, 서브시스템, 다이몬이 있다. 한가지 예시는 네트워크 다이몬이고 2.3.3.5에서 언급되었다. 이 예시에서는 시스템은 프로세스를 교정할 리퀘스트를 수행하기 위해 네트워크 연결을 들을 서비스가 필요하다. 다른 예시는 특정 스케쥴에 맞춰서 프로세스를 시작하는 프로세스 스케쥴러, 시스템 에러 모니터링 서비스, 프린터 서버가 있다. 몇몇 시스템은 수많은 다이몬이 있다. 덧붙여서, 유저 컨텍스트 보다는 커널 컨텍스트가 더 중요하게 여기는 운영체제는 다이몬을 이런 행동을 위해서 사용한다.

이런 시스템 프로그램들과 함께, 대부분의 운영체제는 일반 문제 해결이나 일반 명령을 수행하는 프로그램을 공급한다. 이런 앱프로그램은 웹브라우저, 워드프로세서, 텍스트 포매터, 스프레드시트, db 시스템, 컴파일러 등이 있다.

대부분의 유저들이 보는 운영체제의 관점은 실제 시스템 콜보다는 앱과 시스템 프로그램으로 이루어져있다. 유저의 컴퓨터가 macOS 운영체제를 돌리면, 유저는 GUI를 볼 것이고, 마우스와 윈도우 인터페이스를 기능한다. 윈도우에서는, 유저는 유닉스 쉘 커맨드 라인을 가진다. 두개다 같은 시스템 콜을 사용하지만, 시스템 콜은 다르게 보이고 다르게 행동한다. 유저의 관점에서 더헷갈리는 것은, 유저가 macOS에서 윈도우를 듀얼 부팅하는 것이다. 이제 같은 하드웨어의 같은 유저가 두개의 다른 인터페이스와 같은 물리 자원을 사용하는 앱을 사용한다. 이런 하드웨어에서 유저는 다중 유저 인터페이스를 겪을수 있다.

## 2.5 링커와 로더

일반적으로, 프로그램은 디스크에서 바이너리 실행파일로 거주한다. CPU에서 실행되려면, 프로그램은 만드시 메모리에 가져다지고 프로세스의 컨텍스트에 들어가야한다. 이 절에서는 우리는 이 과정을 설명하겠다. 프로그램 컴파일 부터 메모리에 옮겨서 CPU 코어가 사용 가능하게 만드는 것까지이다.

소스 파일들은 오브젝트 파일이라는 물리적 메모리 공간에 로드될수 있게끔 컴파일되는데 이 포맷은 **relocatable object file**이라고 불린다. 다음으로는, 링커가 relocatable object file을 단일 실행가능 바이너리 파일로 합친다. 링킹 단계에서, 다른 오브젝트 파일이나 라이브러리는 또한 포함된다.

**로더**는 바이너리 실행 파일을 메모리에 로드하는데 사용되는데 이것이 cpu 코어에서 작동하게 해준다. 링킹과 로딩에 관련된 활동은 **relocation**이고 프로그램 파트에 마지막 주소를 할당하고 프로그램 안의 코드와 데이터를 주소에 맞게 고정한다. 예를 들어 코드는 라이브러리 함수를 부르고 그것의 변수가 접근하게 해준다. 로더가 실행되게 필요한 것은 커맨드 라인에 실행 파일을 입력하는 것이다. 프로그램 이름이 유닉스 시스템의 커맨드 라인에 입력된다. 그러면 쉘은 먼저 새로운 프로세스를 프로그래밈이 실행하게 fork() 시스템 콜을 해준다. 그 쉘은 다음으로 exec() 시스템 콜과 로더를 실행하고 실행 파일의 이름을 exec()에 넘겨준다.

프로세스는 모든 라이브러리를 실행파일과 링크하고 메모리로 로드한다. 현실에서 대부분의 시스템은 프로그램이 동적으로 프로그램이 로드될때 라이브러리를 링크한다. 윈도우에서는 dynamically linked libraries(**DLLs**)를 지원한다. 이 방법의 장점은 실행파일에서 사용되지 않을 라이브러리를 부르고 링크하는 것을 피하는 것이다. 대신에, 라이브러리는 조건에 맞게 프로그램 런타임때마다 불려진다. 이것은 챕터 9에서 멀티프로세스가 라이브러리를 동적으로 공유해서 메모리 사용을 아끼는 것을 보게될 것이다.

오브젝트 파일과 실행파일은 커파일 머신 코드와 프로그램에서 언급된 함수와 변수 메타데이터를 포함한 심볼 테이블을 포함하고 있다. 유닉스와 리눅스 시스템에서, 이 표준 포맷은 ELF(**Excutable and Linkable Format**)이라는 것으로 알려져 있다. ELF 포멧은 relocatable과 실행 파일로 구별되어있다. 실행 파일을 위한 ELF의 한 정보 단편은 프로그램의 엔트리 포인트이고 프로그램이 실행될떄 첫번째 명령의 위치를 저장한다. 

## 2.6 왜 앱들은 운영체제 특성화인가?

기본적으로, 한운영체제에서 컴파일된 앱은 다른 운영체제에서는 실행되지 않는다. 만약 그들이 그랬다면, 세계는 더 나아지고, 어떤 운영체제를 선택할지는 어떤 앱이 가용한가보다는 유틸리티와 기능에 달려있을 것이다.

최근의 논쟁에 따르면, 우리는 문제의 부분을 볼수있는데, 각각의 운영체제는 특별한 시스템콜을 제공하는 것이다. 시스템 콜은 앱이 사용하는 운영체제가 제공한 서비스이다. 아무리 시스템 콜이 같아도, 다른 장벽들이 우리가 다른 운영체제에서 작동하기 힘들게 만든다. 만약 너가 다중 운영체제를 사용하면, 당신은 그들위에서 같은 앱을 사용하고있다. 어떻게 가능할까?

앱은 3가지 방법으로 다중 운영체제를 가능하게 한다.

1. 앱은 파이썬이나 루비같은 인터프리터 언어로 쓰일수 있는데 인터프리터는 여러가지 운영체제에서 가용하다. 인터프리터는 소스 프로그램의 각 줄을 읽고, 네이티브 명령어 셋을 동일하게 실행하고 네이티브 시스템 콜을 부른다. 성능은 네이티브 앱보다 떨어지지만, 인터프리터는 각각의 운영체제 기능을 지원해서, 비슷한 앱의 기능 셋을 제한하기도 한다.

2. 앱은 가상 머신을 포함한 언어로 쓰일 수 있다. 가상 머신은 언어의 풀 RTE 부분이다. 자바가 대표적이다. 자바는 로더를 포함한 RTE가 있고, 파이트 코드 명확자, 자바 가상 머신으로부터 자바 앱을 불러오는 구성요소가 있다. RTE는 많은 운영체제를 복사하고 개발하고 RTE가 존재하면 어디서든 실행되게 만들었다. 이런 시스템은 인터프리터와 비슷한 제약이 있다.

3. 앱 개발자가 스탠다드 언어 또는 컴파일러가 머신에서 이진수를 만드는 API와 운영체제 특정 언어를 사용하는 것이다. 앱은 반드시 각각의 운영체제에 맞게 작동하게 복사된다.이 복사는 시간이 꽤 걸리고 앱의 새로운 버전마다 진행되어야한다. 아마도 가장 좋은 예시는 포식스 API와 그것의 UNIX 운영체제와의 호환성이다.

이론으로는 이런 3가지 접근은 다른 운영체제속에서 앱을 개발하는 간단한 해결책을 제공한다. 그러나 앱 모빌리티의 부재는 크로스 플랫폼 앱을 만들기 힘들게 만든다. 앱의 레벨에서는, API를 포함한 운영체제 라이브러리가 제공되어야하고 앱은 API를 부를수 있게 디자인해야하는데 그 API를 제공하지 않는 운영체제에서는 일하지 않을 것이다. 다른 도전점은 시스템의 낮은 레벨에 있는데 다음과 같다.

- 각각의 운영체제는 헤더, 명령어, 변수의 레이아웃을 특정 마이너리 포맷으로 가지고 있다. 이런 구성은 실행 파일의 특정한 구조에 위치되어야한다. 그래서 운영체제가 파일을 열고 로드해서 앱을 적절하게 실행한다.

- CPU는 다양한 명령어 셋이 있고, 한개의 앱은 특정한 명령이 확실하게 실행하게하는 것을 포함한다.

- 운영체제는 앱이 파일 생성, 네트워크 연결 열기 같은 다양한 활동을 요청하는 앱을 허용하는 시스템 콜을 제공한다. 이런 시스템 콜은 많은 관점에서 운영체제 마다 다른데, 특별한 연산자와 연산 순서가 사용되고, 앱이 시스템 콜을 어떻게 생성하는지, 그들의 넘버링과 숫자, 그들의 의미, 그들의 결과 리턴등이 다양하다.

완벽하게 해결하지는 않지만, 이런 구조적 다름을 해결하는 여러가지 접근이 있다. 예를 들어, 리눅스, 대부분의 유닉스 시스템은, 이진 실행 파일을 위한 ELF 포맷을 채택했다. 비록 ELF 포맷이 특정 컴퓨터 구조에 묶여 있지는 않지만, 그것은 실행파일이 다른 하드웨어 플랫폼에서 운영되는 것을 보장한다.

APIs는 말했듯이, 앱 레벨에서 특정한 함수를 명시한다. 구조적인 레벨에서, **Application binary Inerface**는 주어진 운영체제 에서 바이너리 코드가 얼마나 다른지 보여준다. ABI는 낮은 레벨 상세를 주소 너비, 시스템콜을 전달하는 파라미터 방법, 런타임 스택, 시스템 라이브러리의 바이너리 포맷, 데이터타입의 사이즈를 포함한다. 보통, ABI는 주어진 구조에 맞게 특정화된다. 그러므로, ABI는 API와 구조적인 레벨에서는 같다. 만약 이진 실행 파일이 특정 ABI로 링크되고 컴파일되었다면, 그것은 그 ABI를 지원하는 다른 시스템에서 실행되어야한다. 그러나, 특정한 ABI는 전체적인 운영체제를 정의하는데, ABI는 크로스 플랫폼을 조금 지원한다.

요약하면, 모든 이런 다름은 인터프리터, RTE, 이진 실행파일이 특정 CPU 타입의 특정 운영체제를 위해서 쓰이고, 앱은 실행을 실패하는 것이다. 파이어 폭스 브라우저가 윈도우 맥 리눅스 아이오에서 안드로이드 몇가지 CPU 구조를 위해서 쓰는 것을 상상해보아라.

## 2.7 운영체제 디자인과 도구

이 절에서는, 우리는 운영체제를 디자인하고 시행하는 것을 논의하겠다. 물론, 그런 문제에는 완벽한 솔루션이 없지만, 성공적이라고 생각하는 몇가지 접근이 있다.

### 2.7.1 디자인 목표

목적과 세부안을 정의하기 위해서 시스템을 디자인하는 것이 첫번째 문제이다. 가장 높은 레벨에서, 시스템의 디자인은 하드웨어와 시스템의 타입에 영향을 줄것이다. 전통적인 데스크탑/랩탑, 모바일, 분산, 리얼타임이다.

이런 가장 높은 디자인 레벨에서, 필요한 것은 더 구체화하기 힘들다. 이 필요는 그러나 2가지 그룹으로 나눠진다. 유저와 시스템 목표이다.

유저는 시스템에서 명백한 재산을 원한다. 시스템은 사용하기 편리하고 배우기 쉽고 믿음직하고 안전하고 빨라야한다. 물론, 이런 세부사항들은 시스템 디자인에서만 유용한 것이 아니고 어떻게 그들을 수행하는지에 대한 일반해가 없다.

비슷한 필요점의 집합은 시스템을 디자인, 생성, 유지, 운영하는 개발자에게 정의된다. 시스템은 디자인, 실행, 유지가 쉽고 그것은 반드시 유동적이고 믿음직하고 에러없고 효율적이어야한다. 다시한번, 이런 필요점은 애매해지고 다양한 방법으로 해석된다.

운영체제가 필요로하는 문제의 해답을 명확하게 하는 것은 없다. 존재하는 넓은 범위의 시스템은 다양한 환경에서 다양한 솔루션이 필요하다. 예를 들어, 윈드 리버 Vx워크라는 임베디드 시스템을 위한 리얼타임 운영체제는 반드시 다양한 멀티엑세스를 지원하는 윈도우 서버와 달라야한다.

운영체제를 체제화하고 디자인하는 것은 매우 창의적인 일이다. 비록 어떠한 책도 그런 것을 설명하지 않지만, 일반적인 방법은 sw엔지니어링에서 개발되어왔고, 우리는 이런 방법을 논의하겠다.

### 2.7.2 메커니즘과 정책

정책과 메커니즘의 분리는 한가지 중요한 방법이다. 메커니즘은 어떻게 무언가를 하는가이다. 정책은 어떤 일이 벌어질지를 결정한다. 예를 들어, 타이머 건설은 CPU 보호를 확실하게 하는 메커니즘이지만, 얼마나 타이머를 길게하는지는 개인 유저의 정책 결정이다.

이런 정책과 메커니즘의 분리는 유연성을 중요하게했다. 정책은 시간과 공간을 넘어서 쉽게 변화되었다. 최악의 경우에는 정책의 변화는 그 밑의 메커니즘의 변화를 유도했다. 여러가지 범위의 정책이 일하기에 충분히 유연한 일반 메커니즘은 더욱 선호된다. 정책의 변화는 일부 파라미터의 재정의가 필요하다. 예를 들어, 특정 프로그램 타입에 우선권을 주는 메커니즘이 있다. 만약 메커니즘이 정책과 잘 분리되어있으면, 그것은 I/O 인텐시브 프로그램이 CPU 인텐시브보다 더 우선권을 가지게 하는 것 또는 반대의 정책도 지원할수있게된다.

마이크로 커널 베이스 운영체제는 기본적인 원시 빌딩 블록을 실행함으로서 메커니즘과 정책의 분리를 가져왔다. 이런 블럭들은 정책에 무관하고, 더욱 발전된 메커니즘과 정책을 유저 생성 모듈 또는 유저 프로그램으로 만들수 있게한다. 반대로, 윈도우를 고려하겠다. 마이크로 소프트는 정책과 메커니즘을 윈도우를 실행하는 기기들이 글로벌하게 보이고 느껴지도록 인코딩하였다. 모든 앱들은 비슷한 인터페이스를 가졌고 인터페이스 자체가 커널과 시스템 라이브러리에서 작성되었다. 애플 또한 비슷한 정책을 사용했다.

### Implementation

운영체제가 디자인되면, 그것은 반드시 실행되어야한다. 운영체제는 다양한 프로그램의 모음집이고 많은 사람들에게 오랜 시간동안 쓰여졌고, 그것은 그들이 어떻게 실행되는지에 대해 설명하기 어렵다.

초기의 운영체제는 어셈블리어로 쓰여졌다. 이제는 대부분 고급언어인 C나 C++로 쓰여지고 몇몇 시스템만이 기계어를 사용한다. 사실은, 한단계 더높은 언어가 보통 사용된다. 커널의 낮은 레벨은 어셈블리어와 C로 쓰여진다. 그리고 높은 레벨의 루틴은 아마도 C나 C++로 쓰여지고 시스템 라이브러리는 C++로 쓰여지거나 더 높은 언어로 쓰여진다. 안드로이드가 좋은 예시를 준다. 그것의 커널은 C언어와 몇몇의 기계어로 쓰여졌고 대부분의 안드로이드 시스템 라이브러리는 C와 C++로 쓰여졌고 개발자 인터페이스는 자바로 쓰여져있다. 우리는 안드로이드의 아키텍쳐 상세를 뒤에서 더 보여주겠다.

운영체제를 실행하는 것에 높은 레벨의 언어 아니면 시스템 실행 언어를 사용하는 이점은 언어가 앱 프로그램에서 쓰일때 얻어진다. 코드는 더욱 빨리 쓰여질수 있고, 더욱 컴팩트해지고, 더욱 이해하기 쉽고 디버그 하기 쉽다. 덧붙여서, 컴파일러 기술의 향상은 간단한 리컴파일을 통해서 모든 운영체제에서 실행될 수 있다. 마침내, 운영체제는 만약에 높은 언어에서 쓰이면 다른 하드웨어에 더욱 쉽게 설치된다. 이것은 인텔, ARM칩 같은 임베디드 시스템 같은 다양한 다른 하드웨어 시스템에서 특히 중요하다.

운영체제에서 높은 단계의 언어를 사용하는 한가지 가능한 단점은 속도를 줄이고 공간 복잡도를 늘리는 것이다. 그러나 이것은 현재의 큰 문제는 아니다. 비록 기계어 프로그래머는 효율적인 작은 루틴을 생산하지만, 큰 프로그램의 현대 컴파일러는 복잡한 분석과 정교한 최적화를 통해서 완벽한 코드를 제공한다. 현대의 프로세서는 깊은 파이프라인과 다중 함수 유닛을 통해서 복잡한 의지의 상세를 사람보다도 더 쉽게 관리한다.

다른 시스템에서도 사실인데, 운영체제의 주요한 발전은 멋진 어셈블리어보다는 더 나은 자료구조와 알고리즘이 더욱 큰 기여를 했다. 덧붙여서, 비록 운영체제는 크지만, 오직 작은 양의 코드만이 높은 생산성에 치명적이다.; 인터럽트 핸들러, I/O 매니저, 메모리 매니저 CPU 스케줄러가 가장 치명적인 루틴이다. 시스템이 쓰이고 정확하게 작동하면, 병목현상은 찾아지고 더욱 효율적이게 운영되게 변경된다.

## 2.8 운영체제 구조.

시스템이 현대운영체제 만큼 거대해지고 복잡해지면서 그것이 적절하게 작동되고 쉽게 수정되기 위해서는 조심스럽게 설계되어야한다. 일반적인 접근은 한개의 시스템보다는 작은 구성요소, 모듈로 일들을 분할하는 것이다. 각각의 모듈은 반드시 시스템의 일부분으로 잘 정의되어야한다. 너는 너가 너의 프로그램을 구조화할때 비슷한 접근을 사용할 수 있다. main함수에 모든 코드를 두는 것 대신에, 너는 다양한 함수의 로직으로 분산하고, 명백하게 파라미터와 리턴 값을 말하고, 메인에서 이런 것들을 부르는 것이다.

우리는 운영체제의 컴퍼넌트에 대해서 1장에서 말했다. 이번 절에서는 우리는 어떻게 이런 컴포넌트들이 커널을 통해서 섞이고 이어졌는지에 대해서 말하겠다.

### 2.8.1 모노리딕 구조

운영체제를 구성하는 가장 간단한 구조는 구조가 없는 것이다. 즉, 모든 커널의 기능을 한곳에 몰아두고, 정적인 이진 파일이 한개의 주소공간에서 실행되는 것이다. 이 접근이 모노리딕 구조라고 불리고 운영체제에서 보통 쓰이는 기술이다.

제한된 구조화의 예시는 오리지널 유닉스 운영체제이다. 오직 커널과 시스템 프로그램이라는 두개의 구성부분만 잇다. 커널은 유닉스가 발전하면서 몇년간 확장되거 더해진 인터페이스와 장치 드라이버의 연속으로 구별되어있다. 우리는 전통적인 유닉스 운영체제에서는 모든 시스템 콜 인터페이스의 밑과 하드웨어의 위에는 커널이 있다. 커널은 파일시스템, CPU 스케쥴링, 메모리 관리, 그리고 시스템 콜을 통한 운영체제 함수가 제공된다. 다합치면 하나의 주소에 거대한 함수들이 합쳐져있는 것이다.

리눅스 운영체제는 유닉스 기반이고 비슷하게 구조화되었다. 앱들은 보통 glibc를 시스템콜과 커널이 통신하기 위해서 사용된다. 리눅스 커널은 하나의 주소공간에서 커널 모드가 모두 돌아간다는 모노리딕 구조이다. 하지만 쉘을 보게된다면 그것은 모듈러 디자인으로 되어있어서 커널이 런타임 중에 바뀔수 있게 허용해두었다.

이런 모노디딕 커널의 명백한 단순화덕분에, 그들은 실행과 확장이 어려워졌다. 모노리딕 커널은 명백한 성능 장점은 있지만, 시스템 콜 인터페이스의 오버해드와 커널 내부의 통신이 빠르다는 특징이 있다. 그러므로 모노리딕 커널의 단점은, 그들의 속도와 효율성 덕분에 여전히 리눅스, 유닉스, 윈도우에서 보이고 있다.

### 2.8.2 레이어드 접근

모노리딕 접근은 보통 tightly coupled 시스템이라고 알려져 있는데 한 시스템의 부분 변화가 다른 부분에 중대한 변화를 끼치기 떄문이다. 반대로 우리는 loosely coupled 시스템을 디자인 할수 있다. 이런 시스템은 여러가지 특별하고 제한된 기능을 수행하는 작은 구성요소로 나눌 수 있다. 모든 컴포넌트들은 뭉쳐서 커널을 구성한다. 이런 모듈러 접근의 장점은 한개의 구성요소 변화가 오직 그 구성요소에만 영향을 미치고 다른이들에게는 영향을 미치지 않는다. 그리고 시스템이 더욱 쉽게 생산되고 변화되게 만든다.

모듈러로 시스템을 만드는 여러가지 방법이 있다. 한가지 방법은 레이어드 접근이고, 운영체제가 몇 겹의 레이어로 쪼개져있다. 바텀 레이어는 하드웨어이고 가장 높은 단은 유저 인터페이스이다.

운영체제 레이어는 추상적인 오브젝트가 데이터를 만들고 이런 데이터를 바꾸는 명령어를 만든다. 일반적인 운영체제 레이어는 자료구조로 이루어지고 높은 단에서 실행되는 하수로 구성되어있다. 즉 이런 구성요소가 낮은 레벨 레이어의 명령을 깨운다.

이 접근의 주요한 장점은 디버깅과 건설이 간단하다는 것이다. 레이어는 각각이 낮은 레벨의 레이어의 서비스와 함수를 사용하게 선택한다. 이런 접근은 디버깅과 시스템 명료화를 단순하게한다. 첫번째 레이어는 다른 시스템의 걱정없이 디버깅된다. 왜냐하면 그것은 오직 기초적인 하드웨어만을 사용하기 때문이다. 한번 첫번째 레이어가 디버그되면, 그것의 기능은 2번째 레이어가 디버그 되는동안 잘 작동한다고 가정할 수 있다. 만약 에러가 특정 레이어에서 생긴다면, 에러는 그 레이어가 아니라 밑단에서 생겼을 수도 있다. 그러므로, 시스템의 디자인과 실행이 단순화된다.

각각의 레이어는 낮은 레벨 레이어의 명령으로 제공될 수 있다. 레이어 각각은 오직 낮은 레벨 레이어가 제공하는 명령에서 실행된다. 레이어는 어떻게 명령이 실행되는지 알 필요가 없다. 그것은 오직 명령어가 어떤 일을 하는지만 알고있다. 따라서, 각각의 레이어는 특정 자료구조, 명령어, 높은 레벨 레이어의 하드웨어 존재로부터 숨어있다.

레이어드 시스템은 컴퓨터 네트워크와 웹 앱에서 성공적으로 사용되고 있다. 그럼에도 불구하고, 몇몇 운영체제는 순수한 레이어드 접근을 사용한다. 한가지 이유는 각 레이어의 적절한 함수의 정의가 힘들기 때문이다. 덧붙여 이런 시스템의 전체 성능은 유저 프로그램이 운영체제 서비스의 다양한 레이어를 탐색하는 오버헤드가 나쁘게 만들기 때문이다. 몇몇 레이어링은 현대 운영체제에서 일반적이다. 보통 이런 시스템은 약간의 레이어를 많은 기능으로 구성하고, 레이어 정의와 상호작용의 문제를 피하면서 모듈화된 많은 코드의 이점을 제공한다.

### 2.8.3 마이크로커널

우리는 유닉스 시스템이 모노리딕 구조를 가지는 것을 알고있다. 유닉스가 확장됨에 따라서, 커널은 커지고 관리되기 어려워졋다. 1980년대 중반에, 카네기 멜론 대학은 **Mach**라고 불리는 마이크로 커널 방식을 이용하는 모듈화된 커널을 사용했다. 이 방법은 모든 중요하지 않은 구성요소들을 커널에서 지웠고 그들을 유저레벨 프로그램에서 구별된 공간에서 거주하도록 했다. 그 결과는 작은 커널을 만들었다. 어떤 서비스가 커널에 남고 어떤 것이 유저 공간에 실행되어야하는지 약간의 의견일치가 생겼다. 보통, 그러나 마이크로커널은 최소한의 프로세스와 메모리 관리를 제공했고, 통신 기능을 제공했다.

마이크로 커널의 주요한 기능은 클라이언트 프로그램과 유저 스페이스에서 실행되는 다양한 프로그램이 통신하는 기능 제공이다. 통신은 메시지 패싱이라는 것을 통해서 제공된다. 만약 클라이언트 프로그램이 파일에 접근하기를 원하면, 그것은 반드시 파일 서버와 반응해야한다. 그 클라이언트 프로그램과 서비스는 직접적으로 소통하지 않는다. 오히려, 그들은 마이크로 커널과 함께 메시지를 간접적으로 통신한다.

마이크로 커널 방식의 장점은 운영체제를 더욱 쉽게 확장한다는 것이다. 모든 새로운 서비스는 유저공간에 더해지고 결론적으로 커널의 수정을 필요로하지않는다. 만약 커널이 수정되어야한다면, 변화는 적을 것이다. 왜냐하면 마이크로 커널은 작은 커널이기 때문이다. 만들어진 운영체제는 한개의 하드웨어 디자인에서 다른곳으로 쉽게 복사되었다. 마이크로 커널은 대부분의 서비스가 커널보다는 유저에서 일하면서 더욱 보안과 신뢰성을 제공하였다. 만약 서비스가 실패하면, 나머지 운영체제는 여전히 만져지지 않은 상태이다.

아마도, 마이크로 커널 운영체제의 가장 알려진 것은 다윈이고, macOS와 iOS 운영체제의 커널이다. 다윈은 사실 두개의 커널로 이루어져있다. 그중하나는 mach 마이크로 커널이다. 우리는 이것을 후에 다루겠다.

다른 예제는 QNX이고, 임베디드 시스템을 위한 리얼타임 운영체제이다. QNX 뉴트리노 마이크로커널은 메시지 패싱과 프로세스 스케쥴링을 제공한다. 그것은 낮은 레벨 네트워크 통신과 하드웨어 인터럽트를 다룬다. 모든 QNX속의 서비스는 커널 밖의 유저모드의 일반적인 프로세스에서 제공된다.

불행하게도, 마이크로 커널 성능은 시스템 함수 오버헤드로 저하될수있다. 만약 두개의 유저레벨 서비스가 반드시 소통하려면, 메시지는 서비스 사이에서 복사되어야하고, 분리된 주소공간에 저장될 것이다. 덧붙여서, 운영체제는 한개의 프로세스에서 다른 것으로 바뀌어야지 메시지를 교환할 수 있다. 이런 오버헤드는 메시지 복사와 프로세스간에 스위치가 마이크로 커널 기반 운영체제의 성장에 장애로 다가왔다. 윈도우 NT의 역사를 보겠다. 첫번쨰 버전은 레이어드 마이크로 커널 운영체제였다. 이 버전은 윈도우 95보다 느렸다. 윈도우 NT 4.0은 레이어를 유저 공간에서 커널 공간으로 옮기고 그들을 통합하면서 성능을 향상시켰다. 윈도우 XP가 디자인되었을떄, 윈도우는 더욱 모노리딕해졌다.

### 2.8.4 Modules.

아마도 가장 알려진 현대의 운영체제 방식은 **Loadable Kernel Modules(LKMs)**일 것이다. 여기서, 커널은 부트타임과 런타임 도중에 주요한 컴포넌트를 가지고 모듈을 통한 추가적인 서비스를 링크할수 있다. 이런 디자인 타입은 현대 유닉스, 리눅스, 맥, 솔라리스, 윈도우에서 일반적이다.

이 디자인은 커널이 주요한 서비스를 제공하면서, 다른 서비스가 동적으로 실행되게하는 디자인 아이디어이다. 서비스를 동적으로 연결하는 것은 새로운 기능을 커널에 추가하는 것보다는 선호될 것이다. 그러므로 우리는 CPU 스케쥴링과 메모리 관리 알고리즘을 커널에 넣고 다른 파일 시스템을 여러가지 방법의 로드가능한 모듈로 넣는 것을 지원한다. 커널을 리컴파일링하고 변화하는것은 힘들다. 그러므로 예를 들어 우리가 CPU 스케쥴링과 메모리 관리 알고리즘을 커널에 직접 넣고 다른 파일 시스템을 로더블 모듈로 지원하는 것을 더한다.

전체적인 결과는 레이어드 시스템을 형성하고 각각의 커널 부분은 정의되고 인터페이스를 보호한다. 그러나 그것은 레이어드 시스템보다는 훨씬 탄력적인데, 어떤 모듈도 어떤 모듈을 부를수있다. 이런 방법은 마이크로 커널의 주요 모듈이 주요 함수를 가진 방식과 비슷하고 어떻게 다른 모듈과 소통하고 로드하는지 지식이다. 그러나 그것은 훨씬 효율적인데, 모듈은 다른것들과 통신하기 위해서 메시지 패싱할 필요가 없기 때문이다.

리눅스는 로더블 커널 모듈을 사용하고, 디바이스 드라이버와 파일 시스템을 주로 지원한다. LKMs는 시스템이 시작되거나 런타임 중에 삽입될수있다. 예를 들어서 USB 디바이스가 머신을 가동중에 꽂아질때이다. 리눅스 커널이 필요한 드라이버가 없다면, 그것은 동적으로 로드된다. LKMs는 동적이고 모듈러 커널을 허용하는데, 모노리딕 시스템의 성능 장점을 유지한다. LKMs는 런타임중에 물론 커널에서 제거될 수 있다. 리눅스에서는 LKMs는 동적이고 모듈러 커널을 허용하는데, 모노리딕 시스템의 성능 장점을 여전히 유지한다. 우리는 리눅스 속의 LKMs는 것을 이 장의 마지막에 보여주겠다.

### 2.8.5 하이브리드 시스템

실전에서는, 몇몇 운영체제는 한가지, 확실하게 규정된 구조를 채택했다. 대신에 그들은 다른 구조를 합쳤고, 성능과 보안, 사용 이슈를 만드는 하이브리드 시스템을 만들어냈다.  예를 들어 리눅스는 모노리딕 시스템인데, 운영체제가 한개의 주소공간에서 제공하는 것은 성능이 매우 효율적이기 때문이다. 그러나, 그것은 또한 모듈러하다. 그래서 새로운 기능이 커널을 통해서 동적으로 더해진다. 윈도우즈는 또한 모노리딕하지만, 그것은 유저 모드 프로세스를 분할된 서브시스템에서 작동시키는 마이크로커널 시스템을 함유하고있다. 윈도우 시스템들은 동적으로 로드가능한 커널 모듈을 지원한다. 우리는 리눅스와 윈도우 10의 연구를 제공할 것이다. 나머지 절에서는 3가지 하이브리드 시스템을 소개하겠다.

#### 2.8.5.1 맥과 iOS

애플의 맥OS 운영체제는 데스크탑과 랩탑 컴퓨터 시스템에서 동작하도록 디자인되었지만, iOS는 아이폰과 아이패드 같은 태블릿을 위해서 디자인되었다. 구조적으로, macOS와 iOS는 공통점을 가지고 있고, 우리는 보통 그들을 같이 소개하고 어떤 점이 공유되고 어떤점이 다른지 강조한다. 다양한 레이어의 강조는 다음과 같다.

- 유저 경험 층 : 이 층에서는 유저가 컴퓨터 장치와 상호작용하는 소프트웨어 인터페이스를 정의한다. 맥OS는 아쿠아 유저 인터페이스를 사용하고, 마우스와 트랙 패드를 지원하는데 비해서, iOS는 스프링 보드 유저 인터페이스로 터치 디바이스를 지원한다.

- 앱 프레임워크 층 : 이 층은 코코아와 코코아터치 프레임워크를 포함하는데 Objective-C와 스위프트 언어를 위한 API를 지원한다. 두개의 차이점은 코코아는 macOS용이고 후자는 터치스크린 같은 모바일 하드웨어의 특별한 기능을 지원한다.

- 코어 프레임워크 : 이 층은 퀵타임과 OpenGL을 포함하는 그래픽 미디어를 지원한다.

- 커널 환경 : 다윈이라고 알려진, 이 환경은 매크 마이크로 커널과 BSD 유닉스 커널을 포함한다. 우리는 다윈에대해서 자세히 말할 것이다.

앱들은 유저 경험 기능의 장점을 가지기 위해서 또는 그들을 우회하고 앱 프레임워크나 코어 프레임워크와 직접 상호작용하도록 디자인된다. 덧붙여서, 앱은 프레임워크를 앞서가고 커널 환경과 직접 통신할 수 있다.(예를 들어, C프로그램이 포식스 시스템 콜을 부르는 유저인터페이스 없이 쓰인 것이다.) 

두가지의 거대한 구분점이 다음과 같다.

- macOS는 데탑과 랩탑을 위해서 만들어졌기에, 그것은 인텔 구조에서 컴파일 된다. iOS는 모바일 디바이스를 위해서 디자인되어서 ARM-based 구조에서 컴파일된다. 비슷하게, iOS 커널은 특정 기능과 파워 관리와 공격적인 메모리 관리 같은 모바일 시스템의 주소를 가르키도록 변경되었다. 덧붙여서 iOS는 macOS보다 엄중한 보안 설정이 있다.

- iOS 운영체제는 macOS보다 더욱 개발자에게 제한되어있고 닫혀있다. 예를 들어, iOS는 POSIX와 BSD API 접근을 제한하는데 비해서 macOS는 개발자가 접근 가능하다.

이제 우리는 다윈이라는 하이브리드 구조에 집중하겠다. 다윈은 매크 마이크로 커널과 BSD 유닉스 커널을 가진 레이어드 시스템이다.

대부분의 운영체제는 UNIX에서의 C library와 리눅스 시스템 같은 단일의 시스템콜 인터페이스를 커널에 제공한다. 다윈은 하지만 두개의 구별된 시스템콜 인터페이스를 제공한다. 매크 시스템콜(trap)과 BSD 시스템 콜(POSIX 기능 제공)으로 구성되어있다. 이런 시스템콜의 인터페이스는 C 라이브러리 뿐만이 아니라 네트워킹, 보안, 프로그램 언어를 지원하기에 매우 풍부한 라이브러리를 제공한다. 

시스템콜 인터페이스의 밑에, 매크는 메모리 관리, CPU 스케쥴링, IPC(메시지 패싱, remote procedure calls)같은 운영체제의 기본적인 서비스를 제공한다. 매크에 의해서 제공되는 많은 기능은 커널 추상화를 가능한데, 쓰레드, 메모리 객체, 포트와 같은 기능이 포함된다. 이런 예시로, 앱은 BSD POSIX fork() 시스템콜을 통해서 새로운 프로세스를 생성할 수 있다. 매크는 그러면, 태스크 커널 추상화를 커널안의 프로세스를 대표하기 위해서 사용할 것이다.

덧붙여서 매크와 BSD는, 커널 환경은 디바이스 드라이버의 개발자를 위한 I/O 킷과 동적 로드 가능 모듈(맥에서는 **kernel extensions**, **kexts**라고한다)을 제공한다.

2.8.3절에서 우리는 다른 유저 공간에서 동작하는 서비스 사이의 메시지 패싱의 오버헤드가 어떻게 마이크로 커널의 성능을 손상시키는지 이야기했다. 이런 성능 문제를 해결하기 위해서, 다윈은 매크, BSD, I/O 킷과 kernel extension을 한개의 주소에 합쳤다. 그러므로, 매크는 유저 공간에서 다양한 서브시스템이 반응하는 순수한 마이크로 커널이 아니다. 매크에서의 메이지 패싱은 여전히 일어나지만, 카피는 필요하지 않고, 서비스는 같은 주소공간을 접근한다.

애플은 다윈 운영체제를 오픈소스로 제공했다. 결과적으로, X-11 윈도윙 시스템과 파일 시스템 지원 같은 부가적인 기능이 다양한 프로젝트를 통해서 더해졌다. 다윈과 다르게 코코아 인터페이스는 닫혀있다.

#### 2.8.5.2 안드로이드

안드로이드 운영체제는 오픈 핸드셋 연뱅에 의해서 디자인되었고 안드로이드 스마트폰과 태블릿 컴퓨터를 위해서 개발되었다. 반면에 iOS는 애플 모바일 디바이스에서 작동되게 디자인되어서 클로즈 소스이다. 안드로이드는 다양한 모바일 플랫폼에서 동작하고 오픈소스인데, 그것의 인기 급상승을 설명한다. 

안드로이드는 iOS의 그래픽, 오디오, 하드웨어 기능을 지원하는 소프트웨어의 층층히 쌓인 스택과 비슷하다. 이런 기능들은, 안드로이드 기능을 가능하게 하는 모바일 앱 개발 플랫폼을 제공한다.

자바로 쓰인 안드로이드 장치 개발하는 소프트웨어 디자이너는, 그러나 그들은 표준 자바 APi를 대개 사용하지 않는다. 구글은 자바 개발을 위한 구별된 안드로이드 API를 디자인했다. 자바 앱들은 안드로이드를 위해서 디자인되고 모바일기기의 제한된 메모리와 CPU 프로세싱 가용성을 최적화하는 ART라는 안드로이드 런타임에서 작동되는 형태로 컴파일 된다. 자바 프로그램은 자바 바이트코드 .class 파일로 컴파일되고 실행가능한 .dex 파일로 번역된다. 반면에 자바 가상 머신은 justintime compilation을 앱의 기능 향상을위해서 사용하는데, ART는 **ahead-of-time** 컴파일레이션을 사용한다. 여기서 .dex 파일은 그들이 ART에서 시작했을때부터 디바이스에 설치되었을때 원시의 기계언어로 컴파일된다. AOT 컴파일은 더욱 효율적인 앱 실행을 모바일 시스템에서 제일 중요한 파워 소비에서 줄여준다.

안드로이드 개발자들은 자바 원시 인터페이스 또는 JNI로 가상머신을 개발자가 우회하는 것을 허용하고 대신에 특정 하드웨어 기능에 직접 접근하도록 자바프로그램을 사용하도록 개발한다. JNI로 쓰인 프로그램은 보통 한개의 하드웨어에서 다른 하드웨어로의 이동이 불가하다.

안드로이드 앱을 위한 네이티브 라이브러리 셋은 웹 브라우저 개발(webkit), 데이터베이스 지원(sqlite), 네트워크 지원(시큐어 소켓(SSLs))같은 프레임워크를 포함한다.

안드로이드가 제한되지 않은 하드웨어 디바이스에서 가용하기 때문에, 구글은 물리적인 하드웨어를 하드웨어 추상화 층이나 HAL을 통해서 추상화했다. 카메라, GPS 칩, 센서 같은 모든 하드웨어 기기를 추상화해서, HAL은 특정 하드웨어와 관련없이 일관된 뷰를 제공했다. 이런 기능은 물론 개발자가 다른 하드웨어 플랫폼으로 쉽게 넘어갈 수 있게 했다.

리눅스 시스템에 의해서 사용되는 표준 C 라이브러리는 GNU C library이다.(glibc) 구글은 대신에 안드로이드를 위한 Bionic 표준 씨언어를 개발했다. 바이오닉은 glibc보다 적은 메모리 공간을 차지했고 모바일 기기를 위한 느린 CPU를 디자인했다.

안드로이드 소프트웨어 스택의 최하단은 리눅스 커널이다. 구글은 모바일에서 다양한 시스템(파워 관리)를 지원하기 위해서 리눅스 커널을 안드로이드에 맞게 변경했다. 그것은 메모리 관리에 변화를 주었고 Binder라는 새로운 형태의 IPC를 만들어냈다.

## 2.9 운영체제 빌딩과 부팅

운영체제를 한개의 특정 머신 설정에 맞게 디자인, 코드 실행하는 것은 가능하다. 더 일반적으로, 운영체제는 어던 종류의 기계에서도 보조적인 설정 없이 작동하도록 디자인되었다.

### 2.9.1 운영체제 생성

보통은, 컴퓨터 시스템이 구매되면, 이미 설치된 운영체제를 가진다. 예를 들어서, 너는 윈도우와 맥OS가 이미 설치된 새로운 랩탑을 구매할 수 있다. 그러나 너가 이미 설치된 운영체제를 바꾸거나 새로운 운영체제를 더한다고 생각하자. 아니면 운영체제 없는 컴퓨터를 샀다고 하자. 후자의 경우에는 너는 너의 사용과 컴퓨터에 알맞은 운영체제를 두는 몇가지 옵션이 있다. 만약 니가 운영체제를 스크래치에서 만들면 다음과 같은 절차가 필요하다.

1. 운영체제 소스코드를 적는다.(아니면 이미 적혀진 소스코드를 얻어온다.)
2. 작동시킬 시스템에 운영체제를 설정한다.
3. 운영체제를 컴파일한다.
4. 운영체제를 설치한다.
5. 컴퓨터와 그것의 운영체제를 부팅한다.

시스템을 설정하는 것은 어떤 기능이 포함되어있는지 확실하게 정하는 것이 포함되어 있고 운영체제마다 다르다. 일반적으로, 시스템이 어떻게 설정되는지 파라미터를 정의하는 것은 몇가지 타입의 파일 설정에 저장되고 이 파일이 생성되면, 몇가지 방법으로 이용된다.

한가지 극단으로는, 시스템 관리자는 운영체제 소스코드의 카피를 수정할 수 있다. 그러고 운영체제는 확실하게 컴파일한다. 데이터 선언, 초기화, 변수에 따라서 컴파일하고 운영체제의 버전에 맞는 설정 파일에 설명되어있는대로 시스템에 맞게 재단된 아웃풋 객체 파일을 생산한다.

덜 재단된 레벨에서, 시스템 상세는 미리 컴파일된 객체 모듈부터 존재하는 라이브러리까지 있을 것이다. 이런 모듈은 생성된 운영체제를 함꼐 형성한다. 이런 프로세스는 모든 지원하는 I/O디바이스에 맞게 라이브러리를 허용하고, 오직 필요한 것들만 운영체제에서 고르고 링크한다. 시스템이 다시 컴파일되지 않기에, 시스템 생성은 빠르지만, 결과로 나오는 시스템은 너무 일반적이고 다른 하드웨어 상세를 지원하지 않을 수도 있다.

다른 극단은 그것은 시스템을 완벽하게 모듈러하게 짤수있는 것이다. 여기서, 컴파일이나 링크 과정보다는 실행하는 도중에 선택이 생긴다. 시스템 세대는 파라미터를 세팅하는 것을 포함하는데 시스템 설정을 표현한다.

이런 접근들 간의 가장 큰 차이는 만들어진 시스템의 크기와 일반성과 하드웨어 설정이 바뀌었을 때의 바꾸는 난이도이다. 임베디드 시스템에서, 첫번째 접근을 채택하는 것은 일반적이지 않고 특별하고 정적인 하드웨어 설정을 위한 운영체제를 만드는 것이다. 그러나 데스크탑과 랩탑같은 모바일 기기를 지원하는 현대의 운영체제는 두번째 방법을 채택했다. 즉, 운영체제는 여전히 특정한 하드웨어 설정을 만들고 있지만, 로더블 커널 모듈같은 기술의 사용은 시스템이 동적으로 변하는 모듈러 지원을 한다.

이제 우리는 리눅스시스템을 스크래치에서 짓는 법을 보고, 그것은 다음과 같은 절차를 필수적으로 보통 따른다.

1. 리눅스 코드를 다운 받는다.(http://www.kernel.org)
2. "make menuconfig" 커맨드를 이용해서 커널을 구별한다. 이 과정은 .config congiguration file을 만든다.
3. make 커맨드로 메인 커널을 컴파일한다. make 커맨드는 .config file에서 정보를 설정 파라미터를 기반으로 컴파일한다. 그리고 vmlinuz라는 커널 이미지를 만든다.
4. make modules 커맨드로 커널 모듈을 만든다. 커널을 컴파일하는 것처럼 .config file의 설정 파라미터를 기반으로 모듈 컴파일을 완료한다.
5. "make modules_install"커맨드를 이용해서 vmlinuz안으로 커널 모듈을 설치한다.
6. make install 커맨드로 시스템위에 새로운 커널을 설치한다.

시스템이 리부트될 때, 그것은 이 새로운 운영체제를 실행한다.

대안으로 리눅스 가상 머신을 설치함으로서 현존하는 시스템에서 수정을 할 수 있다. 이것은 호스트 운영체제(윈도우, 맥)를 리눅스 돌리는 것을 허용한다.

리눅스를 가상머신으로 설치하는 몇가지 옵션이 있다. 한가지 대안은 스크래치로부터 가상머신을 짓는 것이다. 이 옵션은 스크래치로부터 리눅스 시스템을 짓는것과 비슷하다. 그러나, 운영체제는 실제로 컴파일 되지는 않는다. 다른 접근은 이미 설치되고 설정된 리눅스 가상머신 기구를 사용하는 것이다. 이 옵션은 보통 기구를 다운받고 VirtualBox나 VMware같은 가상 머신 소프트웨어를 다운 받는 것이다. 


### 2.9.2 시스템 부트

운영체제가 만들어진 이후에, 그것은 하드웨어에 의해서 사용되면 가능해진다. 그러나 하드웨어는 커널이 어디에 있는지 어떻게 알고 커널을 로드할까?? 커널을 로딩함으로서 컴퓨터를 시작하는 프로세스는 시스템을 부팅하는 것이다. 대부분의 시스템에서, 부트 프로세스는 다음과 같다.

1. 작은 부트스트랩 프로그램이나 부트로더라는 코드의 조각이 커널에 존재한다.
2. 커널은 메모리로 들어오고 시작된다.
3. 커널은 하드웨어를 실행한다.
4. 루트 파일 시스템이 마운트된다.

이 절에서는, 우리는 부트 프로세스가 어떤 것인지 상세히 알아보겠다.

몇몇 컴퓨터시스템은 여러 스테이지의 부트 프로세스를 사용한다. 컴퓨터가 처음 켜지면, 바이오스라고 알려진 비휘발성 펌웨어에 있는 작은 부트 로더가 실행된다. 이 첫번째 부트 로더는 보통 두번째 부트로더를 부르는 것 외에는 하지않는다. 두번째 부트로더는 고정된 디스크 공간에 위치하며 부트 블록이라고 불린다. 부트 블럭에 저장되어있는 프로그램은 아마도 운영체제 전체를 메모리에 로드하기에 충분히 정교하고 그것의 실행을 시작한다. 더욱 보편적으로, 그것은 간단한 코드이고 디스크의 주소와 부트스트랩 프로그램의 길이만을 알고있다.

많은 최근의 컴퓨터 시스템은 바이오스 부트 프로세스를 **UEFI(Unified Extensible Firmware Interface)**로 변경했다. UEFI는 64비트 시스템을 지원하고 더 큰 디스크를 지원하는데 바이오스보다 유용하다. 아마도, UEFI의 가장 큰 장점은 하나의 완벽한 부트 매니저이고 그래서 멀티스테이지 바이오스 프로세스보다 빠르다.

바이오스나 UEFI에서 부팅될때, 부트스트랩 프로그램은 다양한 작업을 수행할 수 있다. 커널프로그램을 포함하는 파일을 메모리로 로딩하기 위해서 그것은 머신의 상태를 점검하는 진단프로그램을 실행한다. 예를 들어 메모리와 CPU를 검사하고 디바이스를 발견한다. 만약 진단프로그램이 끝나면, 프로그램은 부팅 스텝을 진행한다. 부트스트랩은 시스템의 모든 측변에서 시작되는데, CPU 레지스터 부터 디바이스 컨트롤러와 메인 메모리의 컨텐츠이다. 이르든 늦든, 그것은 운영체제를 시작하고 루트파일 시스템을 마운트한다. 그제서야 시스템은 실행된다고 할 수 있다.

GRUB는 리눅스와 유닉스 시스템의 오픈소스 부트스트랩 프로그램이다. 시스템을 위한 부트파라미터는 GRUB 설정 파일에 세팅되고 시작시에 로딩된다. GRUB는 유동적이고 부트 시점에 변경을 허용하는데, 커널 파라미터 면경과 다른 커널이 부팅되는 것을 포함한다. 이런 예제로 다음 과같은 커널 파라미터가 사용된다.
> BOOT_IMAGE = /boot/vmlinuz-4.4.0-59-generic
> root=UUID=5f2fkeke-gurj-4fe8-ab04-45janelf
부트 이미지는 메모리로 로드될 커널 이미지이고 루트는 루트 파일시스템을 정할 특별한 식별자이다.

공간을 절약하는 것과 부트타임을 줄이는 것은, 리눅스 커널 이미지는 메모리로 부터 로드되고나서 압축된 파일이다. 부트 과정중에, 부트 로더는 임시 램 파일 시스템을 생성하는데, initamfs라고 알려져 있다. 파일 시스템은 필수 드라이버와 실제 루트 파일 시스템을 지원할 모듈을 포함한다. 커널이 한번 시작되고 필수 드라이버가 설치되면, 커널은 루트 파일 시스템을 임시 램에서 적절한 루트파일 시스템 장소로 변경한다. 마침내 리눅스는 시스템의 첫번째 프로세스인 systemd 프로세스를 생성하고, 다른 서비스를 시작한다. 최종적으로, 시스템은 유저 로그인 프롬프트를 만드는 것이다. 11.5.2에서 윈도우 부트는 설명하겠다.

부팅 메커니즘은 부트 로더로부터 독립적이지 않다. 그러므로 바이오스와 UEFI를 위한 GRUB 부트로더가 있고 펌웨어는 반드시 어떤 부트로더가 필요한지 알아야한다.

모바일 시스템의 부트 프로세스는 전통적인 PC와는 다른다. 예를 들어 커널이 리눅스 베이스이지만, 안드로이드는 GRUB를 사용하지 않고 판매회사가 부트로더를 제공하게 내버려 두었다. 대부분의 안드로이드 부트로더는 LK이다. 안드로이드 시스템은 리눅스와 같은 압축된 이미지를 사용하고, 램 파일 시스템도 마찬가지이다. 그러나 만면에 리눅스는 initramfs를 필요한 드라이버가 로드되면 버리지만, 안드로이드는 이것을 루트 파일 시스템으로서 계속 유지한다. 한번 커널이 로드되고 루트 파일 시스템이 마운트되면, 안드로이드는 init 프로세스를 시작하고 홈스크린을 보여주기전에 수많은 서비스를 만든다.

마침내, 운영체제를 위한 부트로더는 하드웨어 문제를 진단하고, 파일 시스템 부패를 고치고, 운영체제 재설치를 위해서 리커버리 모드나 싱글 유저 모드로 부팅된다. 하드웨어 실패에 더불어, 컴퓨터 시스템은 소프트웨어 에러와 부족한 운영체제 성능때문에 느려진다.

## 2.19 운영체제 디버깅

우리는 이 챕터에서 디버깅을 참 많이 언급했다. 넓게 보면, 디버깅은 하드웨어나 소프트웨어에서 시스템의 에러를 찾고 고치는 일이다. 성늘 문제는 버글 고려되고 따라서 디버깅은 병목현상을 제거해서 성능을 높이는 성능 튜닝을 포함한다. 이 절에서는, 우리는 디버깅 프로세스와 커널 에러와 성능 문제를 찾겠다. 하드웨어 디버깅은 포함하지 않는다.

### 2.10.1 실패 분석

만약 프로세스가 실패하면, 대부분의 운영체제는 시스템 관리자나 유저에게 문제가 생긴 것을 경고하기 위해서 로그파일에 에러 정보를 쓴다. 운영체제는 또한 코어 덤프를 취하는데 프로세스의 메모리의 캡쳐이고 후의 분석을 위해서 파일안에 그것을 저장한다. 프로그램과 코어 덤프를 실행하는 것은 프로그래머가 코드와 실패 시점의 프로세스의 메모리를 탐험하는 디버거에 의해서 조사된다.

유저 레벨 코드를 디버깅하는 것은 어렵다. 운영체제 커널 디버깅은 그것의 크기와 복잡도, 하드웨어의 조작 때문에 더욱 어렵고, 유저 레벨 디버깅 툴의 부족도 있다. 커널의 실패는 **Crash**라고 불린다. 크래시가 생기면, 에러 정보가 로그 파일에 저장되고 메모리 스테이트는 크래시 덤프에 저장된다.

운영체제 디버깅과 프로세스 디버깅은 다른 툴과 기술로 빈번하게 사용되는데 두 일의 근본적인 환경 차이 때문이다. 파일 시스템 코드 속의 커널 실패는 커널이 그것의 상태를 리부팅하기전에 파일 시스템의 파일에 저장하는 것은 위험하다. 커널의 메모리 상태를 파일 시스템을 포함하지 않는 이 목적을 위한 디스크의 부분에 저장하는 기술이 자주 쓰인다. 만약 커널이 복구 불가능한 에러를 찾으면, 그것은 메모리의 전체 콘텐츠를 쓰고, 시스템 메모리의 커널이 가진 부분을 쓴다. 아니면 최소한 커널이 가진 시스템 메모리의 일부분을 디스크 영역에 쓴다. 시스템이 리부트되면, 프로세스는 그 구역에서 데이터를 모으고 파일 시스템 분석을 위해서 크래시 덤프 파일에 쓴다.  명백하게, 이런 전략은 일반적인 유저 레벨 프로세스를 디버깅할때는 불필요하다.

### 2.10.2 성능 모니터링과 튜닝

병목 현상을 제거함으로서 성능을 향상시키는 성능 튜닝은 앞서 말했었다. 병목현상을 발견하기위해서, 우리는 반드시 시스템 성능을 살펴보아야한다. 그러므로, 운영체제는 반드시 컴퓨팅과 시스템 행동의 측정 관찰을 보아야한다. 툴은 프리 프로세스나 시스템 와이드 관측으로 특정화될수 있다. 이런 관찰을 만들기 위해서, 툴들은 두가지(카운터와 트레이싱)으로 사용될 수 있다. 우리는 각각을 살펴보겠다.

#### 2.10.2.1 카운터

운영체제는 시스템 활동을 수많은 시스템 콜이나 네트워크 디바이스나 디스크에서 수행하는 명령어로 일련의 카운터로 추적한다. 리눅스에서 카운터를 사용하는 툴의 예시이다.

- Per-Process
- - ps - 단일 프로세스나 프로세스의 선택에 대한 정보를 리포트한다.
- - top - 현재 프로세스의 실시간 통계를 리포트한다.

- System-Wide
- - vmstat - 메모리 사용량을 리포트한다.
- - netstat - 네트워크 인터페이스를 위한 통게를 리포트하다.
- - iostat - 디스크의 I/O 사용을 리포트한다.

리눅스 시스템의 카운터 기반 툴들은 /proc 파일 시스템에서 통계를 불러온다. /proc은 오직 커널 메모리에서만 존재하는 파일 시스템이고 각 프로세스를 쿼링하는데 사용한다. 프록 파일 시스템은 디렉토리 계층으로 구성되고, 최하위 디렉토리로 프록을 가진다. 예를 들어서, 디렉토리 엔트리 /proc/2155는 2155라는 아이디를 가진 프로세스의 통계를 포함한다. 이번 챕터와 챕터 3에서, 우리는 프록 파일 시스템으로 접근하는 프로그래밍 프로젝트를 제공한다.

윈도우 시스템은 윈도우 태스크 매니저를 제공하는데, 프로세스, CPU, 메모리 사용, 네트워크 통계깉은 현재의 앱 정보를 제공한다. 

### 2.10.3 트레이싱

카운터 베이스 툴이 현재의 정보만을 필요로할때, 트레이싱 툴은 시스템 콜 혁신 같은 특별한 이벤트에 대한 데이터를 수집한다.

- Per-Process
- - strace - 프로세스에 의해서 발생된 시스템 콜을 따라간다.
- - gdb - 소스레벨 디버거

- System-Wide
- - perf - 리눅스 성능 툴의 집합
- - tcpdump - 네트워크 패킷 수집

### 2.10.4 BCC

유저레벨과 커널 레벨 코드 사이의 상호작용을 디버깅 하는 것은 두 코드를 이해하고 그들의 상호작용을 사용하는 툴셋 없이는 거의 불가능하다. 툴셋이 정말로 유용해질려면, 그것은 어떤 시스템의 영역도 디버그하고, 시스템 신뢰성을 전혀 영향주지 않아야한다. 이런 툴셋은 반드시 적은 성능 문제를 가지고 있어야하고 이상적으로는 그것은 사용되지 않을때 영향이 없고 사용할때는 부분적으로 영향을 주어야한다. BCC 툴킷은 이러한 요청을 동적이고 보안적이고 덜 영향주는 디버깅 환경으로 만족시켰다.

**BCC(BPF Compiler Collection)**은 리눅스 시스템을 트레이싱하는 풍부한 툴킷이다. BCC는 eBPF의 프론트 엔드 인터페이스 툴이다. BPF(Berkely Packet filter) 기술은 1990년대 초에 컴퓨터 네트워크간의 트래픽을 필터링하기 위해서 개발되었다. eBPF는 C로 쓰여졌고 eBPF 명령어로 컴파일되어서 리눅스 시스템에 동적으로 삽입된다. eBPF 명령어는 특정한 이벤트(시스템콜의 발생)을 캡처하거나 시스템 성능(disk I/O에 필요한 시간)을 모니터한다. eBPF 명령어가 잘 동작한다고 확신하려면, 그들은 리눅스 커널에 들어가기전에 **verifier**를 통과해야한다. verfier는 그 명령어가 다른 시스템 성능이나 보안에 영향을 끼치지 않는다는 것을 확신한다.

eBPF가 리눅스 커널을 위해서 다양한 기능을 제공하지만, 그것은 그것의 C 인터페이스로 프로그램 개발하는 것은 어려웠다. BCC는 eBPF를 파이썬 프론트엔드 인터페이스로 만들면서 쉽게 이용이 가능해졌다. BCC 툴은 파이썬으로 쓰여졌고 C코드의 eBPF 명령어를 내포한다. BCC 툴은 C 프로그램을 eBPF 명령어로 컴파일하고 그것을 커널에 삽입해서 리눅스 커널속의 이벤트를 추적하거나 감시하는데 사용된다.

BCC는 리눅스 커널 내부의 다양한 영역의 활동을 관찰할수 있게해준다. 오직 ./disksnoop.py 입력 만으로 우리는 현재 I/O 명령어가 일어나는 타임스탬프, 읽기/쓰기 명령어, 몇 바이트를 I/O에 포함하는지를 확인할 수있고 latency도 볼수 있다. 

BCC는 유저 앱(MySQL, 자바 파이썬 프로그램)또한 관찰하는데 사용된다. 관찰은 특정 프로세스가 될수도 있는데 ./opensnpoop -p 1225와 같이 가능하다. 이 명령어는 1225라는 식별자를 가진 open() system call을 추적할 것이다.

BCC가 특별한 이유는 그것의 생산 시스템이 시스템에 아무런 영향을 끼치지 않고 계속 사용되는 것이다. 이 기능은 특히 병목현상이나 보안 결함을 알아야하는 시스템 운영자에게 도움된다.