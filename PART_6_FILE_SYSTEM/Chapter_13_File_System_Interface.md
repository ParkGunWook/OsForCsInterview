## What we gonna learn

대부분의 유저들에게, 파일 시스템은 운영체제의 가장 잘 보이는 측면이다. 그것은 on-line 저장소 메커니즘과 운영체제의 데이터와 프로그램의 접근을 제공한다. 파일 시스템은 두가지 파트로 나누어진다. 파일의 집합, 연관 데이터 저장, 디렉토리 구조 같은 시스템의 모든 파일에 대한 정보를 제공한다. 대부분의 파일 시스템은 11장에 말했고 다음 장에서 다시 언급할 저장 기기에 있다. 이 장에서는, 우리는 파일의 다양한 측면과 주요한 디렉토리 구조에 대해서 말하겠다. 우리는 또한 다양한 프로세스, 유저, 컴퓨터간에 파일을 공유하는 구조에 대해서 말하겠다. 마지막으로, 우리는 우리가 다양한 유저가 있고 누가 파일에 접근하길 원할떄 파일 보호를 다루는 방법과 어떻게 파일이 접근되는지에 대해서 논의하겠다.

## Chapter Objectives

- 시스템의 함수에 대해서 설명한다.
- 파일 시스템의 인터페이스에 대해서 설명한다.
- 접근 메서드, 파일 셰어링, 파일 락킹, 디렉토리 구조를 포함한 파일 시스템 트레이드 오프를 설명한다.
- 파일 시스템 보호를 살펴본다.

## 13.1 File Concept

컴퓨터들은 NVM 디바이스, HDDs, 자성 테이프, 광학 디스크 같은 다양한 저장 매체에 정보를 저장한다. 그래서 컴퓨터 시스템은 사용하기 편리해지고, 운영체제는 저장된 정보의 일정한 논리적 관점을 제공한다. 운영체제는 그것의 저장 디바이스의 물리적 성질을 논리적 저장 유닛인 **file**로 추상화한다. 파일들은 운영체제에 의해서 물리적 디바이스에 매핑되어있다. 이런 저장 디바이스들은 보통 비휘발성이고, 컨텐츠들은 시스템 리부트에 상관이 없다.

파일은 2차 저장소에 저장된 관계형 정보의 집합으로 불린다. 유저의 관점으로부터, 파일은 논리적 2차 저장소의 가장 작은 할당이다. 즉, 데이터는 파일에 있지 않으면 2차 저장소에 쓰일 수 없다. 일반적으로, 파일들은 프로그램(소스와 오브젝트 형식)와 데이터를 대표한다. 데이터 파일들은 숫자, 알파벳, 숫자+알파벳, 바이너리의 형식이다. 파일들은 텍스트 파일 같이 자유 형식이거나 엄격하게 형식이 있을 수 있다. 일반적으로, 파일은 파일의 생성자와 유저에 의해서 정의되는 의미있는 비트,바이트,라인 또는 레코드의 시퀀스이다. 파일의 정의는 그러므로 극히 일반적이다.

파일들이 메소드 유저들이고 데이터를 저장하고 불러오는데 쓰이는 앱이다. 그리고 그들이 일반적인 목적이므로, 그들의 이용은 그것의 원래 범위를 넘어선다. 예를 들어서, 유닉스, 리눅스와 다른 운영체제는 시스템 정보에 접근을 제공하는 파일 시스템 인터페이스를 사용하는  `proc` 파일 시스템을 제공한다.

파일의 정보는 그것의 생성자에 의해서 정의된다. 정보의 다양한 타입들이 파일에 저장된다.(소스 또는 실행 프로그램, 숫자 또는 텍스트 데이터, 사진, 음악, 비디오 등등) 파일은 그것의 타입에 달린 특별한 저의의 구조를 가진다. **text file**은 라인으로 구성된 캐릭터의 시퀀스이다. **source file**은 실행가능한 문장으로 구성된 함수의 시퀀스이다. **executable file**은 로더가 메모리에 로드하고 실행가능한 코드 부분의 연속이다.

### 13.1.1 File Attributes

파일은 사람 이용자의 편의에 맞게 이름지어지고 그것의 이름으로 언급된다. 이름은 보통 문자열이다. 몇몇 시스템은 이름에 대문자와 소문자를 구분하고, 몇몇은 그러지 않는다. 파일이 이름을 얻으면, 그것은 프로세스로, 유저, 심지어는 그것을 만든 시스템으로부터 독립적이게 된다. 예를 들어 유저가 example.c라는 파일을 만들고, 다른 유저가 그것의 이름을 명세함으로서 파일을 수정했다. 파일의 소유자는 파일을 USB 드라이브에 썼고, 그것은 이메일 첨부해서 보내거나 네트워크를 통해서 복사했고 그것은 여전히 목적 시스템에서 example.c라고 불린다. 비록 셰어링과 동기화 메서드가 있었지만, 두번째 복사본은 이제 첫번쨰와 독립적이고 분리되었다.

파일의 특성은 운영체제마다 다르지만 보통은 다음을 포함한다.
- Name : Symbolic 파일 명은 사람이 읽을수 잇는 형태로 보관되는 유일한 정보이다.
- Identifier : 보통은 숫자인 유니크 태그는 파일 시스템에서 파일을 구별한다. 그것은 사람이 읽을 수 없는 이름을 가진다.
- Type : 이 정보는 다른 타입의 파일을 제공하는 시스템에게 필요하다.
- Location : 이 정보는 디바이스의 포인터이고 디바이스에서 파일의 위치이다.
- Size : 파일의 현재 사이즈이고 최대 사이즈는 이 특성에 포함된다.
- Protection : 누가 읽고, 쓰고 실행가능한지 결정하는 접근 제어 정보이다.
- Timestamps and user identification : 이 정보는 생성, 마지막 수정, 마지막 사용을 위해서 보존된다. 이런 정보들은 보호, 보안, 사용 모니터링에 유용하다.

몇몇 새로운 파일 시스템은 파일의 인코딩 캐릭터와 파일 체크섬같은 보안 기능을 포함한 **extended file attributes**를 지원한다.

디렉토리 구조에 보관된 모든 파일에 대한 정보는 파일 자체로 같은 디바이스에 존재한다. 일반적으로, 디렉토리 엔트리는 파일의 이름과 그것의 유니크 식별자를 포함한다. 식별자는 다른 파일 특성에도 존재한다. 그것은 각 파일의 정보를 저장하는데 킬로바이트 이상을 사용한다. 많은 파일의 시스템에서, 디렉토리의 크기는 메가바이트 또는 기가바이트이다. 디렉토리들이 파일의 변동성에 매치되어야하기 때문에, 그들은 디바이스에 저장되고 보통은 메모리 단편에 가져온다.

### 13.1.2 파일 명령어

파일은 추상 데이터 타입이다. 파일을 적절히 정의하기 위해서, 우리는 파일에 실행되는 명령어를 알 필요가 있다. 운영체제는 파일을 create, write, read, reposition, delete, truncate하기 위해서 시스템콜을 제공한다. 이런 7가지 기본 파일 명령어를 살펴보겠다. 그거슨 파일 이름 바꾸기 같은 비슷한 명령어가 어떻게 보이는지 구현하기 간단해야한다.

- Creating a file : 파일을 생성하는데 두가지 단계가 필요하다. 첫번째, 파일을 위한 파일 시스템의 공간을 찾는다. 우리는 14장에서 파일을 할당하는 방법을 보겠다. 두번째, 디렉토리에 새로운 파일의 엔트리가 반드시 만들어져야한다.
- Opening a file : 모든 파일 명령어가 파일 이름을 상세하기보다는, 운영체제가 이름을 평가하게하고, 접근 허용을 확인한다. create와 delete를 제외한 모든 명령어는 먼저 open()이 필요하다. open에 성공하면, open 콜은 다른 콜의 어규먼트로 쓰이는 파일 핸들을 리턴한다.
- Writing a file : 파일로부터 읽기 위해서, 우리는 파일 핸들을 상세하고 파일의 다음에 놓여질 블럭을 찾는 시스템콜을 사용한다. 다시, 시스템은 만약 연속적이라면, **read pointer**라는 다음 리드가 실행되는 파일의 위치를 유지할 필요가 있다. 프로세스는 reading from or writing to a file 이므로 현재 명령 위치는 **current file position pointer**의 프로세스별로 저장된다. 읽기와 쓰기 명령어는 같은 포인터를 사용하고, 공간을 아끼고 시스템 복잡성을 낮춘다. 
- Repositioning within a file : 열린 파일의 현재 파일 위치 포인터는 주어진 값으로 재위치된다. 파일의 재위치는 실제 I/O를 필요로하지 않는다. 파일 명령어는 오직 file **seek**으로 알려져있다.
- Deleting a file : 파일을 삭제하기 위해서, 우리는 이름있는 파일의 디렉토리를 검색한다. 연관된 디렉토리 엔트리를 찾으면, 우리는 모든 파일 공간을 해제하고, 그것은 다른 파일에 의해서 재사용되고 디렉토리 엔트리를 지우거나 여유있다고 마킹한다. 몇몇 시스템은 **hard links**를 허용하는데, 같은 파일이 다중의 이름을 갖는 것이다. 이 경우에 실제 파일 컨텐츠는 마지막 링크가 삭제될때까지는 삭제되지 않는다. 
- Truncating a file : 유저는 파일의 컨텐츠는 지우고 싶지만 그것의 성질은 유지하고 싶다. 유저가 파일을 삭제하게 강제하고 재 생성하기보다는, 이 함수는 파일의 길이를 제외한 파일의 성질을 바귀지 않은채로 허용한다. 파일은 길이는 0으로 리셋되고, 그것의 파일 공간은 해제된다.

이 7개의 기본 명령어는 필요한 파일 명령어의 최소 집합이다. 다른 일반적인 명령어는 새로운 정보를 존재하는 파일의 끝에 붙이고 존재하는 파일의 이름을 재설정하는 것이다. 이런 원시적인 명령어는 다른 파일 명령어를 수행하기 위해서 합쳐진다. 예를 들어서, 우리는 파일의 복사를 새로운 파일을 만들고 헌 것을 읽고 새것에 쓰는 것으로 실행한다. 우리는 또한 유저가 파일의 다양한 성질을 얻고 세팅하도록 허용하는 명령어를 원한다. 예를 들어서, 우리는 유저가 파일의 정보(파일의 길이, 파일의 소유자 성질 설정)를 결정하도록하는 명령어를 원한다.

말했듯이, 대부분의 파일 명령어는 네임드 파일에 관련된 디렉토리의 엔트리를 검색하는 것을 포함한다. 이 끊임없는 검색을 피하기 위해서, 많은 시스템은 파일이 처음 사용되기전에 `open()` 시스템 콜을 요구한다. 운영체제는 모든 오픈 파일의 정보를 포함하는 **open file table**이라는 테이블을 유지한다. 파일 명령어가 요청되면, 파일은 이 테이블의 인덱스로 특정되고, 검색은 더이상 필요하지 않다. 파일이 더이상 쓰이지 않으면, 그것은 프로세스에 의해서 닫히고, 운영체제는 오픈 파일 테이블에서 그것의 엔트리를 제거하고, 락을 해제한다. create()와 delete()는 오픈 파일보다는 클로즈 파일로 수행된다.

몇몇 시스템들은 첫번째 파일 레퍼런스가 생겼을때 파일을 내부적으로 오픈한다. 파일은 파일을 연 일 또는 프로그램이 종료하면 자동으로 닫힌다. 대부분의 시스템에서, 프로그래머는 파일을 사용하기 전에`open()` 시스템 콜로 명시적으로 파일을 열기를 필요로한다. `open()` 명령어는 파일 이름을 가지고 디렉토리를 검색하고 디렉토리 엔트리를 오픈 파일 테이블에 복사한다. `open()` 콜은 접근 모드 정보를 수용하고, create, read-only, read-write, append-only 등등을 한다. 이 모드는 파일의 허용에 따라서 체크된다. 만약 요청 모드가 허용되면, 파일은 프로세스에 의해서 열린다. `open()` 시스템콜은 보통 오픈 파일 테이블의 엔트리에 있는 포인터를 리턴한다. 실제 파일이름이 아닌 이 포인터는 모든 I/O 명령에어 사용되고, 검색을 피하고 시스템 콜 인터페이스를 단순화한다.

`open()`과 `close()` 명령어의 구현은 한개의 파일을 동시에 여러개의 프로세스가 오픈하면 복잡하다. 이것은 여러개의 다른 앱들이 동시에 같은 파일을 열때 일어난다. 일반적으로, 운영체제는 내부 테이블을 두단계로 나눈다. 프로세스 테이블과 시스템 와이드 테이블이다. 프로세스 테이블은 프로세스가 연 파일을 추적한다. 이 테이블에 저장된 것은 프로세스의 파일 사용에 따른 정보이다. 예를 들어서, 각 파일의 현재 파일 포인터가 여기서 찾아진다. 예를 들어서, 현재 파일 포인터는 여기서 찾아진다. 파일과 정보의 접근 권한이 포함될 수 있다.

프로세스 테이블의 각 엔트리는 시스템 와이드 오픈 파일 테이블을 가르킨다. 시스템 와이드 테이블은 디스크의 파일의 위치, 데이터 접근, 파일 사이즈 같은 프로세스 독립 정보를 포함한다. 한번 파일이 한 프로세스에 의해서 열리면, 시스템 와이드 테이블은 파일의 엔트리를 포함한다. 다른 프로세스가 open() 콜을 실행하면, 파일의 새로운 엔트리가 적절한 시스템 와이트 테이블의 엔트리를 가르키는 프로세스의 오픈 파일 테이블을 추가한다. 일반적으로, 오픈 파일 테이블은 얼마나 많은 프로세스가 파일을 오픈한지를 가르키는 **open count**를 가진다. 각 `close()`는 오픈 카운트를 줄이고, 오픈 카우늩가 0이되면, 파일의 엔트리는 오픈 파일 테이블에서 제거된다.

요약하면, 다음 정보들이 오픈 파일들과 연관이 있다.

- 파일 포인터 : read()와 write() 시스템 콜의 파트를 오프셋으로 포함하지 않은 시스템에서, 시스템은 반드시 현재 파일 위치 포인터로서 마지막 read-write 위치를 추적해야한다. 이 포인터는 파일의 각 프로세스에 유일하고 그러므로 온 디스크 파일 성질로부터 분리되어야한다.
- 파일 오픈 카운트 : 파일이 닫히면, 운영체제는 반드시 그것의 오픈 파일 테이블 엔트리를 재사용해야하고, 테이블의 공간이 부족해질 수 있다. 다양한 프로세스들은 파일을 열수 있고, 시스템은 반드시 오픈 파일 테이블 엔트리를 지우기전에 마지막 파일이 닫히기를 기다려야한다. 파일 오픈 카운트는 열려있는 수이고 마지막 닫힘으로 0에 도달한다. 시스템은 그때 엔트리를 삭제가능하다.
- 파일의 위치 : 대부분의 파일 명령어는 시스템으로 하여금 파일의 데이터를 읽고 쓰게한다. 파일을 위치하는데 필요한 정보는 메모리에 저장되고, 시스템은 각 명령어의 디렉토리 구조로부터 읽을 필요가 없다.
- 접근 권한 : 각 프로세스는 접근 모드를 가지고 파일을 연다. 이 정보는 각 프로세스 테이블에 저장되고 I/O 요청을 허용 또는 거부 할 수 있다.

몇몇 운영체제는 오픈 파일을 락킹하는 기능을 제공한다. 파일 락은 한개의 프로세스가 파일을 락하게 허용하고 다른 프로세스로 하여금 접근을 얻는 것을 방지한다. 파일 락들은 여러 프로세스에 의해서 공유되는데 파일에 유용하다. 예를 들어서, 시스템 로그 파일은 오직 시스템의 프로세스에 의해서만 접근되고 수정이 가능하다.

파일 락들은 reader-writer 락과 비슷한 기능을 제공한다. **shared lock**은 여러  프로세스가 동시에 락을 획득하는 reader lock과 비슷하다. **exclusive lock**은 writer lock과 비슷하다. 오직 한개의 프로세스가 이 락을 획득가능하다. 모든 운영체제가 이 두가지 타입의 락을 제공하는 것은 아니다. 몇몇 운영체제는 오직 exclusive file locking을 제공한다.

더 나아가서, 운영체제는 **mandatory** or **advisory** 파일 락킹 메커니즘을 제공한다. 의무적인 락킹은, 한번 프로세스가 exclusive lock을 획득하면, 운영체제는 다른 프로세스가 잠금된 파일에 접근하는 것을 방지한다. 예르 들어서, 프로세스가 파일 시스템에서 exclusive lock을 획득했다고 가정하겠다. 만약 우리가 system.log를 다른 프로세스로부터 열려고 시도하면, 운영체제는 exclusive lock이 해제될떄까지 접근을 방지한다. 대안으로는, 만약 락이 advisory라면, 운영체제는 텍스트 에디터가 system.log로부터 엑세스를 얻는 것을 방지하지 않는다. 오히려, 텍스트 에디터는 반드시 파일에 접근하기전에 수동으로 락을 획득하도록 쓰여야한다. 다른 말로는, 만약 락킹 구조가 mandatory라면, 운영체제는 락킹 무결성을 보장한다. advisory 락킹에서는, 락들이 적절하게 획득되고 해제되는 것은 소프트웨어 개발자에게 달려있다. 일반적인 룰로는, 윈도우는 mandatory locking을 채택하고 UNIX는 advisory locks를 채택했다.

파일 락의 사용은 일반적인 프로세스 동기화와 같은 주의가 필요하다. 예를 들어서, mandatory 락킹을 가진 시스템에서 개발하는 프로그래머는 그들이 파일에 접근하는 동안 exclusive file lock을 섬세하게 잡고 있어야한다. 다른경우에는, 그들은 다른 프로세스로부터 파일 접근을 막아버린다. 더나아가서, 몇몇 측정은 반드시 두개 또는 여러개의 프로세스들이 파일락을 획득하는 동안 데드락이 되지 않게 보장해야한다.

### 13.1.3 파일 타입

우리가 파일 시스테을 디자인할때, 전체 운영체제에서, 우리는 운영체제가 파일 타입을 인식하고 지원하는지 고려해야한다. 만약 운영체제가 파일의 타입을 인식하면, 그것은 합리적인 방식으로 파일을 운영해야한다. 예를 들어서, 일반적인 실수는 유저가 프로그램의 바이너리 파일의 아웃풋을 결과로 내려할 때 일어난다. 이 시도는 쓰레기통을 만든다. 그러나, 만약 시도가 성공하면 운영체제가 파일이 바이너리 오브젝트 파일이라고 말한다.

파일 타입을 구현하는 일반적인 기술은 파일이름의 일부로 타입을 포함하는 것이다. 이름은 두가지 파트로 나뉘는데, 이름과 기간에 의해서 나누어지는 확장자 명이다. 이 방법에서, 유저와 운영체제는 파일의 타입이 무엇인지 알려준다. 대부분의 운영체제는 문자의 연속으로 파일이름을 특정한다. 이 이름은 기간을 따르고 추가적인 확장자 문자에 의해서 끝난다. 예시는 `resume.docx`, `server.c`, `ReaderThread.cpp`를 포함한다.

시스템은 파일의 타입과 그 파일에 실행가능한 명령어의 타입을 알리는 확장자를 사용한다. 오직 .com, .exe, .sh같은 확장자들이 실행가능하다. .com과 .exe 파일들은 이진 실행파일의 두가지 형태이고, .sh는 운영체제의 아스키 포맷, 커맨드를 포함하는 **shell script**이다. 앱 프로그램은 또한 그들이 어디에 관심있는지를 알리는 파일 타입을 확장자를 이용해서 가르킨다. 예를 들어, 자바 컴파일러는 소스 파일들이 .java 확장자를 가지기를 원하고, 워드 프로세스는 .doc또는 .docs같은 확장자를 가진 파일을 기대한다. 이런 확장자들은 항상 필요하지 않은데, 그래서 유저는 확장자를 포함하지 않고 파일을 특정하고, 앱은 주어진 이름과 그들이 바라는 확장자를 찾는다. 확장자들이 운영체제에 의해서 지원되지 않기 때문에, 그들은 그들을 실행할 앱이 "hints"를 고려하게한다.

또한 macOS 운영체제를 고려해보겠다. 이 시스템에서, 각 파일은 .app같은 타입을 가진다. 각 파일은 프로그램의 이름을 포함하는 생성자 성질을 가진다. 성질은 `create()`콜에 동안에 운영체제에 의해서 세팅되고, 그래서 그것의 사용은 시스템에 의해서 강제되고 지원받는다. 예를 들어서, 워드 프로세서에 의해서 생성된 파일은 그것의 생성자로서 워드 프로세서의 이름을 가진다. 유저가 파일을 열면, 파일을 대표하는 아이콘을 마우스로 더블 클릭함으로서, 워드 프로세서는 자동으로 실행되고, 파일이 로드되고, 수정할 준비가 된다.

유닉스 시스템은 파일의 데이터 타입을 알리기 위해서 바이너리 파일의 시작에 **magic number**를 저장한다. 이와 같이, 그것은 파일의 타입을 알리기 위해서 텍스트 파일의 시작에 텍스트 매직 넘버를 사용한다. 모든 파일이 매직 넘버를 가지진 않았지만, 시스템 기능은 혼자서 기반되지 않는다. 유닉스는 생성한 프로그램의 이름을 저장하지 않고, 유닉스는 파일 이름 확장자를 허용한다. 그러나 이런 확장자들은 운영체제에 의해서 결정되거나 강제되지 않는다. 그들은 대부분 파일이 어떤 컨텐츠의 타입을 포함한지만 결정하는 것을 돕는다. 확장자는 주어진 앱에 의해서 사용되거나 무시되지만, 그것은 앱 프로그래머에게 달려있다.

### 13.1.4 파일 구조

파일 타입은 파일의 내부 구조를 가르키는데도 사용된다. 소스와 오브젝트 파일들은 프로그램의 기대에 맞는 구조를 가진다. 더 나아가, 특정 파일들은 운영체제가 이해할 수 있는 반드시 필요한 구조를 따라야한다. 예를 들어서, 운영체제는 실행 파일이 특정한 구조를 가지기를 필요한다. 그렇게 해서 그것은 메모리의 어디에 파일을 로드하고 첫번째 명령어의 위치가 무엇인지 판단한다. 몇몇 운영체제는 이 아이디어를 시스템 서포트 파일 구조로 확장했고, 이런 구조가진 파일을 조정하는 특별한 명령어 집합을 가진다.

이 관점은 운영체제가 다중 파일 구조를 지원하게 단점을 가져온다. 이것은 운영체제를 크고 다루기 힘들게한다. 만약 운영체제가 5개의 다른 파일 구조를 정의하면, 그것은 이런 파일 구조를 지원하는 코드를 포함한다. 추가로, 이것은 운영체제에 의해서 지원되는 모든 파일을 하나의 타입으로 정의할 필요가 있다. 새로운 앱이 운영체제에 지원하지 않는 방식으로 구조화된 정보를 필요로하면, 심각한 문제가 생길 것이다.

예를 들어서, 시스템이 2가지 타입의 파일을 지원한다고 가정하자. 텍스트 파일과 실행가능한 바이너리 파일. 이제, 만약 우리가 인가되지 않은 사람으로부터 컨텐츠를 지키기 위해서 암호화된 파일을 정의하면, 우리는 파일 타입이 두개 모두에 적절하지 않은 것을 알수 있다. 암호화된 파일은 ASCII 텍스트 라인이 아니고, 랜덤 비트이다. 비록 그것이 바이너리로 보여도, 그것은 실행이 가능하지 않다. 결과적으로 우리는 운영체제의 파일 타입 메커니즘을 피하거나 잘못사용하거나 우리의 암호화 구조를 포기해야한다.

몇몇 운영체제는 최소한의 파일 구조를 내포한다. 이 접근은 유닉스, 윈도우 다른 것에 의해서 채택되었다. 유닉스는 각 파일을 8비트 바이트의 연속으로 생각한다. 이 비트에 어떠한 해석도 운영체제가 하지 않는다. 이 구조는 최대의 유연성과 최소의 지원을 제공한다. 각 앱 프로그램은 인풋 파일을 해석할 수있는 코드를 포함해야한다. 그러나, 모든 운영체제는 반드시 하나의 구조는 가진다. 시스템이 프로그램을 로드하고 실행하는 실행가능한 파일이다.

### 13.1.5 Internal File Structure

내부적으로, 파일에 오프셋을 위치하는 것은 운영체제에 복잡할 수 있다. 디스크 시스템들은 일반적으로 섹터의 크기로 결정된 잘 정의된 블록 사이즈를 가진다. 모든 디스크 I/O는 하나의 블록의 유닛에서 작동하고, 모든 블록은 같은 사이즈이다. 물리적 레코드 사이즈가 원하는 로지컬 레코드의 길이에 딱 맞는 경우는 잘 없다. 로지컬 레코드들은 심지어 길이도 가변이다. 로지컬 레코드의 수를 물리 블록으로 싸는 것은 문제에 일반적인 해결책이다.

예를 들어서, 유닉스 운영체제는 모든 파일을 단순히 바이트의 스트림으로 정의한다. 각 바이트는 파일의 시작으로부터 오프셋으로 위치를 인도할 수 있다. 이런 경우에, 로지컬 레코드 사이즈는 1 바이트이다. 파일 시스템은 자동으로 바이트를 물리 디스크 블록으로 팩하고 언팩한다. 

논리 레코드 사이즈, 물리 블록 사이즈, 패킹 기술은 얼마나 많은 논리 레코드가 각 물리 블럭에 있을지 결정한다. 패킹은 유저의 앱에 의해서 또는 운영체제에 의해서 행해진다. 두 케이스 모두, 파일은 블록의 시퀀스로 고려된다. 모든 기본 I/O 함수는 블록의 관점에서 일어난다. 논리 레코드에서 물리 블록의 전환이 상대적으로 간단한 소프트웨어 문제이다.

디스크 공간이 항상 블록에 할당되있기 떄문에, 각 파일의 마지막 부분은 보통 버려진다. 만약 각 블럭이 512 바이트이면, 1949 바이트의 파일은 2048바이트를 할당하고 99바이트가 낭비된다. 이 낭비는 블럭의 유닛을 모두 같게 유지하기 대문에 생기는 내부 단편화이다. 모든 파일 시스템은 내부단편화에 고통받는다. 블럭사이즈가 클수록 내부단편화는 커진다.