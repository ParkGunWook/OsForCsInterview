## What we gonna learn

대부분의 유저들에게, 파일 시스템은 운영체제의 가장 잘 보이는 측면이다. 그것은 on-line 저장소 메커니즘과 운영체제의 데이터와 프로그램의 접근을 제공한다. 파일 시스템은 두가지 파트로 나누어진다. 파일의 집합, 연관 데이터 저장, 디렉토리 구조 같은 시스템의 모든 파일에 대한 정보를 제공한다. 대부분의 파일 시스템은 11장에 말했고 다음 장에서 다시 언급할 저장 기기에 있다. 이 장에서는, 우리는 파일의 다양한 측면과 주요한 디렉토리 구조에 대해서 말하겠다. 우리는 또한 다양한 프로세스, 유저, 컴퓨터간에 파일을 공유하는 구조에 대해서 말하겠다. 마지막으로, 우리는 우리가 다양한 유저가 있고 누가 파일에 접근하길 원할떄 파일 보호를 다루는 방법과 어떻게 파일이 접근되는지에 대해서 논의하겠다.

## Chapter Objectives

- 시스템의 함수에 대해서 설명한다.
- 파일 시스템의 인터페이스에 대해서 설명한다.
- 접근 메서드, 파일 셰어링, 파일 락킹, 디렉토리 구조를 포함한 파일 시스템 트레이드 오프를 설명한다.
- 파일 시스템 보호를 살펴본다.

## 13.1 File Concept

컴퓨터들은 NVM 디바이스, HDDs, 자성 테이프, 광학 디스크 같은 다양한 저장 매체에 정보를 저장한다. 그래서 컴퓨터 시스템은 사용하기 편리해지고, 운영체제는 저장된 정보의 일정한 논리적 관점을 제공한다. 운영체제는 그것의 저장 디바이스의 물리적 성질을 논리적 저장 유닛인 **file**로 추상화한다. 파일들은 운영체제에 의해서 물리적 디바이스에 매핑되어있다. 이런 저장 디바이스들은 보통 비휘발성이고, 컨텐츠들은 시스템 리부트에 상관이 없다.

파일은 2차 저장소에 저장된 관계형 정보의 집합으로 불린다. 유저의 관점으로부터, 파일은 논리적 2차 저장소의 가장 작은 할당이다. 즉, 데이터는 파일에 있지 않으면 2차 저장소에 쓰일 수 없다. 일반적으로, 파일들은 프로그램(소스와 오브젝트 형식)와 데이터를 대표한다. 데이터 파일들은 숫자, 알파벳, 숫자+알파벳, 바이너리의 형식이다. 파일들은 텍스트 파일 같이 자유 형식이거나 엄격하게 형식이 있을 수 있다. 일반적으로, 파일은 파일의 생성자와 유저에 의해서 정의되는 의미있는 비트,바이트,라인 또는 레코드의 시퀀스이다. 파일의 정의는 그러므로 극히 일반적이다.

파일들이 메소드 유저들이고 데이터를 저장하고 불러오는데 쓰이는 앱이다. 그리고 그들이 일반적인 목적이므로, 그들의 이용은 그것의 원래 범위를 넘어선다. 예를 들어서, 유닉스, 리눅스와 다른 운영체제는 시스템 정보에 접근을 제공하는 파일 시스템 인터페이스를 사용하는  `proc` 파일 시스템을 제공한다.

파일의 정보는 그것의 생성자에 의해서 정의된다. 정보의 다양한 타입들이 파일에 저장된다.(소스 또는 실행 프로그램, 숫자 또는 텍스트 데이터, 사진, 음악, 비디오 등등) 파일은 그것의 타입에 달린 특별한 저의의 구조를 가진다. **text file**은 라인으로 구성된 캐릭터의 시퀀스이다. **source file**은 실행가능한 문장으로 구성된 함수의 시퀀스이다. **executable file**은 로더가 메모리에 로드하고 실행가능한 코드 부분의 연속이다.

### 13.1.1 File Attributes

파일은 사람 이용자의 편의에 맞게 이름지어지고 그것의 이름으로 언급된다. 이름은 보통 문자열이다. 몇몇 시스템은 이름에 대문자와 소문자를 구분하고, 몇몇은 그러지 않는다. 파일이 이름을 얻으면, 그것은 프로세스로, 유저, 심지어는 그것을 만든 시스템으로부터 독립적이게 된다. 예를 들어 유저가 example.c라는 파일을 만들고, 다른 유저가 그것의 이름을 명세함으로서 파일을 수정했다. 파일의 소유자는 파일을 USB 드라이브에 썼고, 그것은 이메일 첨부해서 보내거나 네트워크를 통해서 복사했고 그것은 여전히 목적 시스템에서 example.c라고 불린다. 비록 셰어링과 동기화 메서드가 있었지만, 두번째 복사본은 이제 첫번쨰와 독립적이고 분리되었다.

파일의 특성은 운영체제마다 다르지만 보통은 다음을 포함한다.
- Name : Symbolic 파일 명은 사람이 읽을수 잇는 형태로 보관되는 유일한 정보이다.
- Identifier : 보통은 숫자인 유니크 태그는 파일 시스템에서 파일을 구별한다. 그것은 사람이 읽을 수 없는 이름을 가진다.
- Type : 이 정보는 다른 타입의 파일을 제공하는 시스템에게 필요하다.
- Location : 이 정보는 디바이스의 포인터이고 디바이스에서 파일의 위치이다.
- Size : 파일의 현재 사이즈이고 최대 사이즈는 이 특성에 포함된다.
- Protection : 누가 읽고, 쓰고 실행가능한지 결정하는 접근 제어 정보이다.
- Timestamps and user identification : 이 정보는 생성, 마지막 수정, 마지막 사용을 위해서 보존된다. 이런 정보들은 보호, 보안, 사용 모니터링에 유용하다.

몇몇 새로운 파일 시스템은 파일의 인코딩 캐릭터와 파일 체크섬같은 보안 기능을 포함한 **extended file attributes**를 지원한다.

디렉토리 구조에 보관된 모든 파일에 대한 정보는 파일 자체로 같은 디바이스에 존재한다. 일반적으로, 디렉토리 엔트리는 파일의 이름과 그것의 유니크 식별자를 포함한다. 식별자는 다른 파일 특성에도 존재한다. 그것은 각 파일의 정보를 저장하는데 킬로바이트 이상을 사용한다. 많은 파일의 시스템에서, 디렉토리의 크기는 메가바이트 또는 기가바이트이다. 디렉토리들이 파일의 변동성에 매치되어야하기 때문에, 그들은 디바이스에 저장되고 보통은 메모리 단편에 가져온다.

### 13.1.2 파일 명령어

파일은 추상 데이터 타입이다. 파일을 적절히 정의하기 위해서, 우리는 파일에 실행되는 명령어를 알 필요가 있다. 운영체제는 파일을 create, write, read, reposition, delete, truncate하기 위해서 시스템콜을 제공한다. 이런 7가지 기본 파일 명령어를 살펴보겠다. 그거슨 파일 이름 바꾸기 같은 비슷한 명령어가 어떻게 보이는지 구현하기 간단해야한다.

- Creating a file : 파일을 생성하는데 두가지 단계가 필요하다. 첫번째, 파일을 위한 파일 시스템의 공간을 찾는다. 우리는 14장에서 파일을 할당하는 방법을 보겠다. 두번째, 디렉토리에 새로운 파일의 엔트리가 반드시 만들어져야한다.
- Opening a file : 모든 파일 명령어가 파일 이름을 상세하기보다는, 운영체제가 이름을 평가하게하고, 접근 허용을 확인한다. create와 delete를 제외한 모든 명령어는 먼저 open()이 필요하다. open에 성공하면, open 콜은 다른 콜의 어규먼트로 쓰이는 파일 핸들을 리턴한다.
- Writing a file : 파일로부터 읽기 위해서, 우리는 파일 핸들을 상세하고 파일의 다음에 놓여질 블럭을 찾는 시스템콜을 사용한다. 다시, 시스템은 만약 연속적이라면, **read pointer**라는 다음 리드가 실행되는 파일의 위치를 유지할 필요가 있다. 프로세스는 reading from or writing to a file 이므로 현재 명령 위치는 **current file position pointer**의 프로세스별로 저장된다. 읽기와 쓰기 명령어는 같은 포인터를 사용하고, 공간을 아끼고 시스템 복잡성을 낮춘다. 
- Repositioning within a file : 열린 파일의 현재 파일 위치 포인터는 주어진 값으로 재위치된다. 파일의 재위치는 실제 I/O를 필요로하지 않는다. 파일 명령어는 오직 file **seek**으로 알려져있다.
- Deleting a file : 파일을 삭제하기 위해서, 우리는 이름있는 파일의 디렉토리를 검색한다. 연관된 디렉토리 엔트리를 찾으면, 우리는 모든 파일 공간을 해제하고, 그것은 다른 파일에 의해서 재사용되고 디렉토리 엔트리를 지우거나 여유있다고 마킹한다. 몇몇 시스템은 **hard links**를 허용하는데, 같은 파일이 다중의 이름을 갖는 것이다. 이 경우에 실제 파일 컨텐츠는 마지막 링크가 삭제될때까지는 삭제되지 않는다. 
- Truncating a file : 유저는 파일의 컨텐츠는 지우고 싶지만 그것의 성질은 유지하고 싶다. 유저가 파일을 삭제하게 강제하고 재 생성하기보다는, 이 함수는 파일의 길이를 제외한 파일의 성질을 바귀지 않은채로 허용한다. 파일은 길이는 0으로 리셋되고, 그것의 파일 공간은 해제된다.

이 7개의 기본 명령어는 필요한 파일 명령어의 최소 집합이다. 다른 일반적인 명령어는 새로운 정보를 존재하는 파일의 끝에 붙이고 존재하는 파일의 이름을 재설정하는 것이다. 이런 원시적인 명령어는 다른 파일 명령어를 수행하기 위해서 합쳐진다. 예를 들어서, 우리는 파일의 복사를 새로운 파일을 만들고 헌 것을 읽고 새것에 쓰는 것으로 실행한다. 우리는 또한 유저가 파일의 다양한 성질을 얻고 세팅하도록 허용하는 명령어를 원한다. 예를 들어서, 우리는 유저가 파일의 정보(파일의 길이, 파일의 소유자 성질 설정)를 결정하도록하는 명령어를 원한다.

말했듯이, 대부분의 파일 명령어는 네임드 파일에 관련된 디렉토리의 엔트리를 검색하는 것을 포함한다. 이 끊임없는 검색을 피하기 위해서, 많은 시스템은 파일이 처음 사용되기전에 `open()` 시스템 콜을 요구한다. 운영체제는 모든 오픈 파일의 정보를 포함하는 **open file table**이라는 테이블을 유지한다. 파일 명령어가 요청되면, 파일은 이 테이블의 인덱스로 특정되고, 검색은 더이상 필요하지 않다. 파일이 더이상 쓰이지 않으면, 그것은 프로세스에 의해서 닫히고, 운영체제는 오픈 파일 테이블에서 그것의 엔트리를 제거하고, 락을 해제한다. create()와 delete()는 오픈 파일보다는 클로즈 파일로 수행된다.

몇몇 시스템들은 첫번째 파일 레퍼런스가 생겼을때 파일을 내부적으로 오픈한다. 파일은 파일을 연 일 또는 프로그램이 종료하면 자동으로 닫힌다. 대부분의 시스템에서, 프로그래머는 파일을 사용하기 전에`open()` 시스템 콜로 명시적으로 파일을 열기를 필요로한다. `open()` 명령어는 파일 이름을 가지고 디렉토리를 검색하고 디렉토리 엔트리를 오픈 파일 테이블에 복사한다. `open()` 콜은 접근 모드 정보를 수용하고, create, read-only, read-write, append-only 등등을 한다. 이 모드는 파일의 허용에 따라서 체크된다. 만약 요청 모드가 허용되면, 파일은 프로세스에 의해서 열린다. `open()` 시스템콜은 보통 오픈 파일 테이블의 엔트리에 있는 포인터를 리턴한다. 실제 파일이름이 아닌 이 포인터는 모든 I/O 명령에어 사용되고, 검색을 피하고 시스템 콜 인터페이스를 단순화한다.

`open()`과 `close()` 명령어의 구현은 한개의 파일을 동시에 여러개의 프로세스가 오픈하면 복잡하다. 이것은 여러개의 다른 앱들이 동시에 같은 파일을 열때 일어난다. 일반적으로, 운영체제는 내부 테이블을 두단계로 나눈다. 프로세스 테이블과 시스템 와이드 테이블이다. 프로세스 테이블은 프로세스가 연 파일을 추적한다. 이 테이블에 저장된 것은 프로세스의 파일 사용에 따른 정보이다. 예를 들어서, 각 파일의 현재 파일 포인터가 여기서 찾아진다. 예를 들어서, 현재 파일 포인터는 여기서 찾아진다. 파일과 정보의 접근 권한이 포함될 수 있다.

프로세스 테이블의 각 엔트리는 시스템 와이드 오픈 파일 테이블을 가르킨다. 시스템 와이드 테이블은 디스크의 파일의 위치, 데이터 접근, 파일 사이즈 같은 프로세스 독립 정보를 포함한다. 한번 파일이 한 프로세스에 의해서 열리면, 시스템 와이드 테이블은 파일의 엔트리를 포함한다. 다른 프로세스가 open() 콜을 실행하면, 파일의 새로운 엔트리가 적절한 시스템 와이트 테이블의 엔트리를 가르키는 프로세스의 오픈 파일 테이블을 추가한다. 일반적으로, 오픈 파일 테이블은 얼마나 많은 프로세스가 파일을 오픈한지를 가르키는 **open count**를 가진다. 각 `close()`는 오픈 카운트를 줄이고, 오픈 카우늩가 0이되면, 파일의 엔트리는 오픈 파일 테이블에서 제거된다.

요약하면, 다음 정보들이 오픈 파일들과 연관이 있다.

- 파일 포인터 : read()와 write() 시스템 콜의 파트를 오프셋으로 포함하지 않은 시스템에서, 시스템은 반드시 현재 파일 위치 포인터로서 마지막 read-write 위치를 추적해야한다. 이 포인터는 파일의 각 프로세스에 유일하고 그러므로 온 디스크 파일 성질로부터 분리되어야한다.
- 파일 오픈 카운트 : 파일이 닫히면, 운영체제는 반드시 그것의 오픈 파일 테이블 엔트리를 재사용해야하고, 테이블의 공간이 부족해질 수 있다. 다양한 프로세스들은 파일을 열수 있고, 시스템은 반드시 오픈 파일 테이블 엔트리를 지우기전에 마지막 파일이 닫히기를 기다려야한다. 파일 오픈 카운트는 열려있는 수이고 마지막 닫힘으로 0에 도달한다. 시스템은 그때 엔트리를 삭제가능하다.
- 파일의 위치 : 대부분의 파일 명령어는 시스템으로 하여금 파일의 데이터를 읽고 쓰게한다. 파일을 위치하는데 필요한 정보는 메모리에 저장되고, 시스템은 각 명령어의 디렉토리 구조로부터 읽을 필요가 없다.
- 접근 권한 : 각 프로세스는 접근 모드를 가지고 파일을 연다. 이 정보는 각 프로세스 테이블에 저장되고 I/O 요청을 허용 또는 거부 할 수 있다.

몇몇 운영체제는 오픈 파일을 락킹하는 기능을 제공한다. 파일 락은 한개의 프로세스가 파일을 락하게 허용하고 다른 프로세스로 하여금 접근을 얻는 것을 방지한다. 파일 락들은 여러 프로세스에 의해서 공유되는데 파일에 유용하다. 예를 들어서, 시스템 로그 파일은 오직 시스템의 프로세스에 의해서만 접근되고 수정이 가능하다.

파일 락들은 reader-writer 락과 비슷한 기능을 제공한다. **shared lock**은 여러  프로세스가 동시에 락을 획득하는 reader lock과 비슷하다. **exclusive lock**은 writer lock과 비슷하다. 오직 한개의 프로세스가 이 락을 획득가능하다. 모든 운영체제가 이 두가지 타입의 락을 제공하는 것은 아니다. 몇몇 운영체제는 오직 exclusive file locking을 제공한다.

더 나아가서, 운영체제는 **mandatory** or **advisory** 파일 락킹 메커니즘을 제공한다. 의무적인 락킹은, 한번 프로세스가 exclusive lock을 획득하면, 운영체제는 다른 프로세스가 잠금된 파일에 접근하는 것을 방지한다. 예르 들어서, 프로세스가 파일 시스템에서 exclusive lock을 획득했다고 가정하겠다. 만약 우리가 system.log를 다른 프로세스로부터 열려고 시도하면, 운영체제는 exclusive lock이 해제될떄까지 접근을 방지한다. 대안으로는, 만약 락이 advisory라면, 운영체제는 텍스트 에디터가 system.log로부터 엑세스를 얻는 것을 방지하지 않는다. 오히려, 텍스트 에디터는 반드시 파일에 접근하기전에 수동으로 락을 획득하도록 쓰여야한다. 다른 말로는, 만약 락킹 구조가 mandatory라면, 운영체제는 락킹 무결성을 보장한다. advisory 락킹에서는, 락들이 적절하게 획득되고 해제되는 것은 소프트웨어 개발자에게 달려있다. 일반적인 룰로는, 윈도우는 mandatory locking을 채택하고 UNIX는 advisory locks를 채택했다.

파일 락의 사용은 일반적인 프로세스 동기화와 같은 주의가 필요하다. 예를 들어서, mandatory 락킹을 가진 시스템에서 개발하는 프로그래머는 그들이 파일에 접근하는 동안 exclusive file lock을 섬세하게 잡고 있어야한다. 다른경우에는, 그들은 다른 프로세스로부터 파일 접근을 막아버린다. 더나아가서, 몇몇 측정은 반드시 두개 또는 여러개의 프로세스들이 파일락을 획득하는 동안 데드락이 되지 않게 보장해야한다.

### 13.1.3 파일 타입

우리가 파일 시스테을 디자인할때, 전체 운영체제에서, 우리는 운영체제가 파일 타입을 인식하고 지원하는지 고려해야한다. 만약 운영체제가 파일의 타입을 인식하면, 그것은 합리적인 방식으로 파일을 운영해야한다. 예를 들어서, 일반적인 실수는 유저가 프로그램의 바이너리 파일의 아웃풋을 결과로 내려할 때 일어난다. 이 시도는 쓰레기통을 만든다. 그러나, 만약 시도가 성공하면 운영체제가 파일이 바이너리 오브젝트 파일이라고 말한다.

파일 타입을 구현하는 일반적인 기술은 파일이름의 일부로 타입을 포함하는 것이다. 이름은 두가지 파트로 나뉘는데, 이름과 기간에 의해서 나누어지는 확장자 명이다. 이 방법에서, 유저와 운영체제는 파일의 타입이 무엇인지 알려준다. 대부분의 운영체제는 문자의 연속으로 파일이름을 특정한다. 이 이름은 기간을 따르고 추가적인 확장자 문자에 의해서 끝난다. 예시는 `resume.docx`, `server.c`, `ReaderThread.cpp`를 포함한다.

시스템은 파일의 타입과 그 파일에 실행가능한 명령어의 타입을 알리는 확장자를 사용한다. 오직 .com, .exe, .sh같은 확장자들이 실행가능하다. .com과 .exe 파일들은 이진 실행파일의 두가지 형태이고, .sh는 운영체제의 아스키 포맷, 커맨드를 포함하는 **shell script**이다. 앱 프로그램은 또한 그들이 어디에 관심있는지를 알리는 파일 타입을 확장자를 이용해서 가르킨다. 예를 들어, 자바 컴파일러는 소스 파일들이 .java 확장자를 가지기를 원하고, 워드 프로세스는 .doc또는 .docs같은 확장자를 가진 파일을 기대한다. 이런 확장자들은 항상 필요하지 않은데, 그래서 유저는 확장자를 포함하지 않고 파일을 특정하고, 앱은 주어진 이름과 그들이 바라는 확장자를 찾는다. 확장자들이 운영체제에 의해서 지원되지 않기 때문에, 그들은 그들을 실행할 앱이 "hints"를 고려하게한다.

또한 macOS 운영체제를 고려해보겠다. 이 시스템에서, 각 파일은 .app같은 타입을 가진다. 각 파일은 프로그램의 이름을 포함하는 생성자 성질을 가진다. 성질은 `create()`콜에 동안에 운영체제에 의해서 세팅되고, 그래서 그것의 사용은 시스템에 의해서 강제되고 지원받는다. 예를 들어서, 워드 프로세서에 의해서 생성된 파일은 그것의 생성자로서 워드 프로세서의 이름을 가진다. 유저가 파일을 열면, 파일을 대표하는 아이콘을 마우스로 더블 클릭함으로서, 워드 프로세서는 자동으로 실행되고, 파일이 로드되고, 수정할 준비가 된다.

유닉스 시스템은 파일의 데이터 타입을 알리기 위해서 바이너리 파일의 시작에 **magic number**를 저장한다. 이와 같이, 그것은 파일의 타입을 알리기 위해서 텍스트 파일의 시작에 텍스트 매직 넘버를 사용한다. 모든 파일이 매직 넘버를 가지진 않았지만, 시스템 기능은 혼자서 기반되지 않는다. 유닉스는 생성한 프로그램의 이름을 저장하지 않고, 유닉스는 파일 이름 확장자를 허용한다. 그러나 이런 확장자들은 운영체제에 의해서 결정되거나 강제되지 않는다. 그들은 대부분 파일이 어떤 컨텐츠의 타입을 포함한지만 결정하는 것을 돕는다. 확장자는 주어진 앱에 의해서 사용되거나 무시되지만, 그것은 앱 프로그래머에게 달려있다.

### 13.1.4 파일 구조

파일 타입은 파일의 내부 구조를 가르키는데도 사용된다. 소스와 오브젝트 파일들은 프로그램의 기대에 맞는 구조를 가진다. 더 나아가, 특정 파일들은 운영체제가 이해할 수 있는 반드시 필요한 구조를 따라야한다. 예를 들어서, 운영체제는 실행 파일이 특정한 구조를 가지기를 필요한다. 그렇게 해서 그것은 메모리의 어디에 파일을 로드하고 첫번째 명령어의 위치가 무엇인지 판단한다. 몇몇 운영체제는 이 아이디어를 시스템 서포트 파일 구조로 확장했고, 이런 구조가진 파일을 조정하는 특별한 명령어 집합을 가진다.

이 관점은 운영체제가 다중 파일 구조를 지원하게 단점을 가져온다. 이것은 운영체제를 크고 다루기 힘들게한다. 만약 운영체제가 5개의 다른 파일 구조를 정의하면, 그것은 이런 파일 구조를 지원하는 코드를 포함한다. 추가로, 이것은 운영체제에 의해서 지원되는 모든 파일을 하나의 타입으로 정의할 필요가 있다. 새로운 앱이 운영체제에 지원하지 않는 방식으로 구조화된 정보를 필요로하면, 심각한 문제가 생길 것이다.

예를 들어서, 시스템이 2가지 타입의 파일을 지원한다고 가정하자. 텍스트 파일과 실행가능한 바이너리 파일. 이제, 만약 우리가 인가되지 않은 사람으로부터 컨텐츠를 지키기 위해서 암호화된 파일을 정의하면, 우리는 파일 타입이 두개 모두에 적절하지 않은 것을 알수 있다. 암호화된 파일은 ASCII 텍스트 라인이 아니고, 랜덤 비트이다. 비록 그것이 바이너리로 보여도, 그것은 실행이 가능하지 않다. 결과적으로 우리는 운영체제의 파일 타입 메커니즘을 피하거나 잘못사용하거나 우리의 암호화 구조를 포기해야한다.

몇몇 운영체제는 최소한의 파일 구조를 내포한다. 이 접근은 유닉스, 윈도우 다른 것에 의해서 채택되었다. 유닉스는 각 파일을 8비트 바이트의 연속으로 생각한다. 이 비트에 어떠한 해석도 운영체제가 하지 않는다. 이 구조는 최대의 유연성과 최소의 지원을 제공한다. 각 앱 프로그램은 인풋 파일을 해석할 수있는 코드를 포함해야한다. 그러나, 모든 운영체제는 반드시 하나의 구조는 가진다. 시스템이 프로그램을 로드하고 실행하는 실행가능한 파일이다.

### 13.1.5 Internal File Structure

내부적으로, 파일에 오프셋을 위치하는 것은 운영체제에 복잡할 수 있다. 디스크 시스템들은 일반적으로 섹터의 크기로 결정된 잘 정의된 블록 사이즈를 가진다. 모든 디스크 I/O는 하나의 블록의 유닛에서 작동하고, 모든 블록은 같은 사이즈이다. 물리적 레코드 사이즈가 원하는 로지컬 레코드의 길이에 딱 맞는 경우는 잘 없다. 로지컬 레코드들은 심지어 길이도 가변이다. 로지컬 레코드의 수를 물리 블록으로 싸는 것은 문제에 일반적인 해결책이다.

예를 들어서, 유닉스 운영체제는 모든 파일을 단순히 바이트의 스트림으로 정의한다. 각 바이트는 파일의 시작으로부터 오프셋으로 위치를 인도할 수 있다. 이런 경우에, 로지컬 레코드 사이즈는 1 바이트이다. 파일 시스템은 자동으로 바이트를 물리 디스크 블록으로 팩하고 언팩한다. 

논리 레코드 사이즈, 물리 블록 사이즈, 패킹 기술은 얼마나 많은 논리 레코드가 각 물리 블럭에 있을지 결정한다. 패킹은 유저의 앱에 의해서 또는 운영체제에 의해서 행해진다. 두 케이스 모두, 파일은 블록의 시퀀스로 고려된다. 모든 기본 I/O 함수는 블록의 관점에서 일어난다. 논리 레코드에서 물리 블록의 전환이 상대적으로 간단한 소프트웨어 문제이다.

디스크 공간이 항상 블록에 할당되있기 떄문에, 각 파일의 마지막 부분은 보통 버려진다. 만약 각 블럭이 512 바이트이면, 1949 바이트의 파일은 2048바이트를 할당하고 99바이트가 낭비된다. 이 낭비는 블럭의 유닛을 모두 같게 유지하기 대문에 생기는 내부 단편화이다. 모든 파일 시스템은 내부단편화에 고통받는다. 블럭사이즈가 클수록 내부단편화는 커진다.

## 13.2 Access Method

파일은 정보를 저장한다. 그것이 사용되면, 이 정보는 컴퓨터 메모리에 접근되고 읽혀야한다. 파일의 정보는 여러가지 방법으로 접근이 가능하다. 몇몇 시스템들은 파일 접근을 위해서 한가지 접근을 제공한다. 다른 것들은 많은 접근 메서드를 지원하고, 특정 앱을 위해서 하나를 선택하는 것은 주요한 디자인 문제이다.

### 13.2.1 Sequential Access

가장 간단한 접근 메서드는 **sequential access**이다. 파일의 정보는 순서대로 처리되고, 한 레코드 후에 다른 것을 처리한다. 이 접근의 모드는 가장 일반적이다. 예를 들어서, 에디터와 컴파일러는 이 방식으로 접근한다.

읽기와 쓰기는 파일에 많은 명령어로 구성한다. 읽기 명령어-`read_next()`-는 파일의 다음 부분을 읽고 I/O 위치를 추적하는 파일 포인터로 진행한다. 비슷하게, 쓰기 명령은-`write_next()`-는 파일의 끝에 추가하고 쓰여진 것의 마지막으로 진행한다. 이런 파일들은 시작점으로 리셋가능하고, 프로그램은 몇몇 정수단위로 n 레코드만큼 앞, 뒤로 넘길 수 있다. Sequential access는 파일의 테이프 모델을 기반으로하고 그것은 랜덤 엑세스 디바이스와 sequntial access 디바이스에서 잘 작동한다.

### 13.2.2 Direct Access

다른 메서드는 **direct access**(**relative access**)이다. 여기서 파일은 프로그램이 특정 순서없이 빠르게 레코드를 읽고 쓸 수 있는 고정된 길이의 **logical records**로 만들어진다. 디스크는 어떠한 파일 블락에도 랜덤 엑세스를 허용하기에, direct-access 메서드는 파일의 디스크 모델에 기반한다. Direct access에서, 파일은 블록 또는 레코드의 숫자가 매겨진 시퀀스로 보여진다. 그러므로, 우리는 블럭 14를 읽고 53을 읽고, 7에 쓴다. direct access에서는 순서에 대한 제약이 없다.

Direct-access 파일들은 큰 양의 정보를 즉시 접근하는 데에 유용하다. 데이터베이스들은 보통 이런 타입이다. 특정 목적을 원하는 쿼리가 도착하면, 우리는 정답을 포함하는 블락을 연산하고 원하는 정보를 제공하기 위해서 블럭을 직접 읽는다.

간단한 예시로, 비행기 예약 시스템에서, 우리는 비행기 숫자로 구별되는 블럭의 비행기에 대한 모든 정보를 저장한다. 그러므로, 비행기의 남은 자리는 비행기의 예약 파일에 저장된다. 사람같은 큰 집합에 대한 정보를 저장하려면, 우리는 사람의 이름으로 해시 함수를 계산하거나 읽고 검색할 블록을 결정하기 위한 인덱스를 검색해야한다.

직접 접근 메서드에서, 파일 명령어들은 블록넘버를 파라미터로 포함하기 위해서 수정되어야한다. 그러므로, 우리는 n이 블럭 넘버인 `read(n)`을 사용한다. 즉 `read_next()`와 `write_next()`보다는 `read(n)`과 `write(n)`을 사용하는 것이다. 다른 접근 방법은 next 연산과 `position_file(n)`을 이용하는 것이다. `read(n)`과 같이 작동하려면, 우리는 `position_file(n)`을 한후에, `read_next()`를 실행한다.

유저에 의해서 제공되는 블럭넘버는 **relative block number**이다. 상대적 블럭 넘버는 파일의 시작에 상대적인 인덱스이다. 그러므로, 파일의 첫번째 상대적 블럭은 0이고, 다음은 1인데, 절대적인 디스크 주소는 14703일 수 있다. 상대적 블럭 넘버의 사용은 운영체제가 어디에 파일이 주어져야하는지 판단하게 해주고 유저가 그녀의 파일의 부분이 아닌 파일 시스템을 접근하는 것을 방지한다. 몇몇 시스템들은 그들의 상대적인 블록 넘버 0에서 시작하고 1에서 시작하기도 한다.

어떻게 시스템은 파일의 레코드 N에 대한 요청을 만족할까? 우리가 논리 레코드 길이 L을 가지고 요청된 레코드 N은 L*N을 시작으로 L바이트를 가진 I/O 요청으로 변한다. 논리 레코드들이 고정된 크기이기에, 레코드를 일고, 쓰고 삭제하는 것은 간단하다.

모든 운영체제가 sequential과 direct access를 둘다 지원하지는 않는다. 몇몇 시스템은 오직 전자만 허용하고, 몇몇은 후자만 지원한다. 몇몇 시스템은 생성되었을때 sequential인지 direct인지 정의할 필요가 있기도 하다. 이런 파일은 그것의 정의와 일관된 방법으로만 정의할 수 있다. 우리는 현재의 위치를 정의하는 cp만으로 direct에서 sequential을 시뮬레이션 가능하다. 반대로, sequential에서 direct access를 구현하는 것은 매우 비효율적이고 서투르다.

### 13.2.3 Other Access Methods

다른 접근 메서드는 direct-access 메서드의 위에서 구현된다. 이런 메서드들은 보통 파일에 인덱스의 양식이 보함된다. 책에 있는 인덱스처럼 **index**는 다양한 블럭의 포인터를 포함한다. 파일에서 레코드를 찾으려면, 우리는 먼저 인덱스를 검색하고 적접 파일에 접근하고 원하는 레코드를 찾기 위해서 포인터를 사용한다.

예를 들어서, 소매 가격 파일은 제품마다 universal product codes로 리스트 되어있다. 각 레코드는 10자리의 제품 코드를 포함하고 6자리의 가격으로 16바이트의 레코드를 가진다. 만약 우리의 디스크가 블럭마다 1024 바이트를 가지면, 우리는 블럭마다 64개의 레코드를 가진다. 120000의 파일은 총 2000 블럭을 차지한다. UPC로 정렬된 파일을 유지하면서, 우리는 각 블럭의 첫번째 UPC를 포함한 인덱스를 정의한다. 이 인덱스는 10자리로 2000개의 엔트리이고 메모리에 보관된다. 특정 아이템의 가격을 찾기 위해서, 우리는 인덱스의 바이너리 서치를 만들 수 있다. 이 검색에서, 우리는 원하는 레코드를 가진 블럭을 정확히 알수 있고 블럭에 접근한다. 이런 구조는 조금의 I/O로 큰 파일을 검색하게 허용한다.

큰 파일에서, 인덱스 파일은 메모리에 두기에 너무 클 수도 있다. 한가지 솔루션은 인덱스 파일을 위한 인덱스를 생성하는 것이다. primary 인덱스 파일은 실제 데이터 아이템을 가르키는 secondary 인덱스 파일의 포인터를 포함한다. 예를 들어서, IBM의 indexed sequential access method(ISAM)은 2차 인덱스의 디스크 블럭을 가르키는 작은 마스터 인덱스를 사용한다. 2차 인덱스 블럭은 실제 파일 블럭을 가르킨다. 파일은 정의된 키로 정렬되어 있다. 특정 아이템을 찾기위해서, 우리는 먼저 마스터 인덱스의 이진 탐색을 통해서 2차 인덱스의 블럭넘버를 제공한다. 이 블럭이 읽히면, 다시한번 이진 검색이 원하는 레코드를 찾기위해서 사용된다. 마지막으로, 이 블럭은 sequentially 검색된다. 이런 방법으로, 2번의 direct access reads로 레코드를 찾는다.

## 13.3 Directory Structure

디렉토리는 파일이름을 그들의 컨트롤 블럭으로 번역하는 심벌 테이블로 보인다. 만약 우리가 이런 뷰를 가지면, 우리는 디렉토리 자체가 많은 방식으로 구성된 것을 볼 수 있다. 구성은 반드시 엔트리 추가와 삭제, 엔트리 이름으로 검색, 디렉토리의 모든 엔트리 리스트하는 것을 허용해야한다. 이 절에서, 우리는 디렉토리 시스템의 몇가지 논리적 구조를 살펴보겠다.

특정 디렉토리 구조를 고려할 때 우리는 다음과 같은 명령어가 디렉토리에서 작동하는 것을 명심해야한다.

- Search for a file : 우리는 특정 파일에서 엔트리를 찾기 위해서 디렉토리 구조를 검색할 수 있어야한다. 파일이 심벌릭 네임을 가지고 비슷한 이름이 파일 사이에서 관계를 가르키기에, 우리는 특정 패턴을 가진 이름을 가진 모든 파일을 찾을 수 있기를 원한다.
- Create a file : 새로운 파일을 만들고 디렉토리에 추가한다.
- Delete a file : 파일이 더이상 필요 없어지면, 우리는 그것을 디렉토리로부터 제거하기를 원한다. 삭제는 디렉 토리 구조에서 구멍을 남기고 파일 시스템은 조각을 모을 메서드를 가지고 있다.
- List a directory : 우리는 디렉토리의 파일과 디렉토리 엔트리의 컨텐츠를 리스트할 수 있어야한다.
- Rename a file : 파일의 이름이 그것의 컨텐츠를 대표하기 때문에, 우리는 파일의 컨텐츠 또는 사용이 바뀌면 이름을 바꾸어야한다. 파일의 이름을 바꾸는 것은 디렉토리 구조 내부도 그것의 위치를 바꾸도록 허용한다.
- Traverse the file system : 우리는 디렉토리 구조내의 모든 디렉토리와 모든 파일에 접근하기를 원한다. 신뢰성을 위해서, 컨텐츠와 전체 파일 시스템의 구조를 적당한 주기로 저장하는 것은 좋은 생각이다. 자주, 우리는 모든 파일을 마그네틱 테이프, 2차 저장소, 네트워크를 통해서 클라우드 또는 다른 시스템에 복사한다. 이 기술은 시스테미 실패했을 때의 백업으로 사용된다. 추가로, 만약 파일이 더이상 사용되지 않으면 파일은 백업 타겟으로부터 카피되고 파일의 디스크 공간은 다른 파일을 위해서 재사용될 것이다.

다음 절에서 우리는 첫번째 일반적인 디렉토리 논리 구조를 보겠다.

### 13.3.1 Single-Level Directory

가장 간단한 디렉토리 구조는 single-level 디렉토리이다. 모든 파일들은 같은 디렉토리에 저장되어 있고, 지원과 이해가 쉽다. 

싱글 레벨 디렉토리는 큰 제한을 가지는데, 파일의 수가 증가하거나 시스템이 하나 이상의 유저를 가질때이다. 모든 파일들이 같은 디렉토리에 있기 때문에, 그들은 반드시 유일한 이름을 가져야한다. 만약에 두명의 유저가 데이터 파일 `test.txt`를 호출하면, 유일한 이름 룰이 어겨지는 것이다. 예를 들어서, 한개의 프로그래밍 강좌에서, 23명의 학생들이 그들의 2번째 숙제를 `prog2.c`, 나머지 11명이 `assign2.c`라고 제출한다. 다행히도, 대부분의 파일 시스템은 255개의 문자열까지 지원하기에, 유일한 파일 이름을 지정하는 것은 할만하다.

싱글 레벨 디렉토이에서 싱글 유저는 파일의 수가 증가하면 파일의 모든 이름을 기억하는 것이 힘들 것이다. 유저들이 컴퓨터시스템에서 수백개의 파일을 가지고 다른 시스템에서 같은 수의 추가 파일을 가지는 것은 흔한일이다. 이 파일을 기억하는 것은 벅찬 일이다.

### 13.3.2 Two level directory

우리가 보았듯이, 싱글 레벨 디렉토리는 보통 다른 유저간에 파일 이름의 혼동을 부른다. 일반적인 해결책은 각 유저에게 분리된 디렉토리를 만들어주는 것이다.

2단계 디렉토리 구조에서, 각 유저는 그들의 **user file directory(UFD)**를 가진다. UFDs는 비슷한 구조를 가지지만, 각각은 단일 유저의 파일만을 리스트한다. 유저 일이 시작하거나 유저가 로그인하면, 시스템의 **master file directory(MFD)**가 검색된다. MFD는 유저이름 또는 계정 숫자, 유저의 UFD 엔트리를 가진다. 

유저가 특정 파일을 언급하면, 그의 UFD에서만 검색된다. 그러므로, 다른 유저들은 같은 이름의 파일을 가지고, 각 UFD에서의 모든 파일 이름은 유니크하다. 유저의 파일을 만들기 위해서, 운영체제는 오직 유저의 UFD에서만 그 파일의 이름이 있는지 알아본다. 파일을 삭제하려면, 운영체제는 그것의 로컨 UFD에만 검색을 국한시키고, 그러므로 그것은 같은 이름의 다른 유저의 파일을 실수로 삭제하지 않는다.

유저 디렉토리들은 필요한만큼 생성되고 삭제된다. 특별한 시스템 프로그램이 적절한 유저이름과 계정정보에서 실행된다. 프로그램은 새로운 UFD를 만들고 MFD에 엔트리를 추가한다. 프로그램의 실행은 오직 시스템 관리자에게만 제한된다. 프로그램의 실행은 시스템 관리자에게 한정된다. 이 프로그램의 실행은 시스템 운영자에게 제한될 수 있다. 유저 디렉트리에 디스크 공간의 할당은 14장에서 언급하겠다.

비록 2단 디렉토리 구조가 이름 충돌 문제를 해결하지만, 여전히 불리한 점은 존재한다. 이 구조는 한 유저로부터 다른 유저를 효과적으로 고립한다. 고립은 유저가 완벽히 독립적이라면 장점이지만 유저가 몇몇 태스크를 협력하고 다른이의 파일에 접근하면 단점이다. 몇몇 시스템은 단순히 로컬 유저파일이 다른 유저에 의한 접근을 허용하지 않는다.

만약 접근이 허용되면, 한 유저는 반드시 다른 유저의 디렉토리에 있는 파일을 명명할 능력이 필요하다. 특정한 파일을 독립적으로 이름붙히기 위해서, 우리는 유저이름과 파일이름을 둘다 제공한다. 2단 디렉토리는 높이가 2인 인버티드 트리이다. 트리의 루트는 MFD이다. 그것의 직계 후손은 UFD들이다. UFD의 후손들은 파일 그자체이다. 파일은 트리의 leaves이다. 유저이름과 파일 이름을 명시하는 것은 루트에서 리프로의 트리 패스를 정의한다. 그러므로, 유저 이름과 파일이름은 **path name**을 정의한다. 시스템의 모든 파일들은 패스 이름을 가진다. 파일을 유일하게 부르려면, 유저는 반드시 원하는 파일의 패스를 알아야한다.

예를 들어서, 만약 유저 A가 그녀의 테스트 파일 test.txt를 원하면 단순히 `test.txt`를 언급하면된다. 하지만 유저 B가 가진 test.txt에 접근하려면, 그녀는 `/userb/test.txt`라고 언급해야한다. 모든 시스템은 디렉 토리를 명명하는 자체 문법을 가진다.

추가적인 문법은 파일의 볼륨을 명세하는데 필요하다. 예를 들어서, 윈도우에서 볼륨은 콜론에 따라오는 문자이다. 그러므로, 파일 명세는 `C:\userb\test.txt`가 될 것이다. 몇몇 시스템들은 더 나아가서 볼륨, 디렉토리 이름, 파일이름을 쪼갠다. OpenVMS에서, 파일 `login.com`은 `u:[sst.crissmeyer]login.com;1`로 명세되는데, u는 볼륨의 이름, sst는 디렉토리의 이름, crissmeyer는 서브디렉토리의 이름, 1은 버전넘버이다. 유닉스나 리눅스같은 시스템에서는 볼륨 이름을 디렉토리 이름의 부분으로 취급한다. 첫번째 이름은 볼륨의 이름이고 나머지는 디렉토리와 파일이다. 예를 들어서, `/u/pgalvin/test`는 볼륨 u, 디렉토리 pgalvin, 파일 test이다.

이 상황의 특별한 예시는 시스템 파일에서 생긴다. 시스템의 일부로 제공된 프로그램-로더, 어셈블러, 컴파일러, 유틸리티 루틴, 라이브러리 등등-들은 파일로 정의된다. 적절한 커맨드가 운영체제에 주어지면, 이런 파일들은 로더에 의해서 읽히고 실행된다. 많은 커맨드 인터프리터들이 이런 커맨드를 파일의 이르을 로드하고 실행하는 용도로 취급한다. 디렉토리 시스템에서, 이 파일 이름은 현재의 UFD에서 검색된다. 한가지 해결책은 각 UFD에 시스템 파일을 복사하는 것이다. 그러나 모든 시스템 파일을 복사하는 것은 어마어마한 공간의 낭비이다.

일반적인 해결책은 검색 단계를 약간 복잡하게 하는 것이다. 특별한 유저 디렉토리가 시스템 파일을 포함하기 위해서 정의된다. 파일 이름이 로드될때마다, 운영체제는 로컬 UFD를 먼저 검색한다. 만약 파일을 찾으면, 그것이 사용된다. 만약 찾지 못하면 시스템은 자동으로 시스템 파일을 포함한 특별한 유저 디렉토리를 검색한다. 파일이 이름을 가지면 검색되는 디렉토리의 시퀀스가 **search path**라고 불린다. 서치 패스는 일반적인 이름이 주어지면 검색할 디렉토리의 무한한 리스트로 확장이 가능하다. 이 메서드는 유닉스와 윈도우에서 가장 많이 사용된다. 시스템들은 또한 각 유저가 그의 서치패스를 가지도록 디자인되어있다.

### 13.3.3 Tree Structured Directories

우리가 어떻게 2단 디렉토리를 2레벨 트리로 본것처럼, 자연스러운 일반화는 임의의 높이를 가진 트리로 확장된다. 이 일반화는 유저가 그들의 자체적인 서브 디렉토리를 만들고 그들의 파일을 구성하는것을 허용한다. 트리는 가장 일반적인 디렉토리 구조이다. 트리는 루트 디렉토리를 가지고, 모든 시스템의 파일은 유일한 path이름을 가진다.

디렉토리는 파일또는 서브디렉토리의 집합이다. 많은 구현에서, 디렉토리는 단순히 다른 파일이지만, 특별한 방법으로 관리된다. 모든 디렉토리는 같은 내부 포맷을 가진다. 각 디렉토리 엔트리의 한 비트는 file인지 subdirecory인지 정의한다. 특별한 시스템 콜들이 디렉토리를 생성하고 삭제하는데 사용된다. 운영체제는 디렉토리의 다른 파일 포맷도 구현되었다.

일반적인 사용에서, 각 프로세스는 현재의 디렉토리를 가진다. **current directory**는 반드시 프로세스가 현재 관심있는 파일을 포함한다. 레퍼런스가 파일에 만들어지면, 현재 디렉토리는 검색된다. 만약 파일이 현재 디렉토리에 없는채로 필요하면, 유저는 일반적으로 패스 이름을 명시하거나 그 파일을 가진 디렉토리로 변경해야한다. 디렉토리를 바꾸려면, 시스템 콜이 디렉토리 이름을 파라미터로서 전달되고 현재의 디렉토리를 재정의하는데 사용된다. 그러므로, 유저는 그녀의 현재 디렉토리를 원할때마다 바꿀수 있다. 다른 시스템은 shell이라는 앱을 이용해서 현재 디렉토리를 추적하고 실행한다. 각 프로세스는 다른 현재 디렉토리를 가질 수 있다.

유저 로그인 쉘의 첫번쨰 현재 디렉토리는 유저 업무가 시작하거나 유저가 로그인할때 지정된다. 운영체제는 accounting file을 검색해서 이 유저의 엔트리를 찾는다. accounting 파일은 유저의 첫 디렉토리를 가르키는 포인터이다. 이 포인터는 유저의 로컬 변수에 복사되고 유저의 초기 디렉토리를 특정한다. 쉘로부터, 다른 프로세스들은 생성된다. 서브 프로세스의 현재 디렉토리는 보통 현재 디렉토리의 부모이다.

패스 이름은 두가지 타입을 가진다. 유닉스와 리눅스는 **absolute path name**은 루트에서 시작하고(initial "/"로 지정된) 특정한 파일의 패스를 따르고, 패스에서 디렉토리 이름을 제공한다. **relative path name**은 현재의 디렉토리로부터 정의되는 패스이다. 예를 들어서, 현재의 디렉토리가 `/spell/mail`이면, 상대 패스는 `prt/first`이면 absolute path는 `/spell/mail/prt/first`이다.

유저가 그녀의 서브디렉토리를 정의하게 허용하는 것은 그녀가 그녀의 파일에 구조를 내포하게하는 것을 허용한다. 이 구조는 다른 토픽에 관련된 파일 또는 다른 형태의 정보에 대한 디렉토리의 분리를 만든다. 예를 들어서, 디렉토리 `programs`는 소스 프로그램을 포함한다. 디렉토리 `bin`은 바이너리를 포함한다.(실행 파일들은 많은 시스템에서 "binaries"라고 불리고 그들은 `bin`디렉토리에 저장된다.)

트리 구조에서의 흥미로운 정책은 디렉토리의 삭제를 어떻게 핸들할지이다. 만약 디렉토리가 비어있으면, 디렉토리의 엔트리는 단순히 삭제된다. 그러나, 삭제될 디렉토리가 비어있지 않고 다수의 파일또는 서브디렉토리를 가졌다고 가정하자. 두가지 방법이 존재한다. 몇몇 시스템은 디렉토리가 비어있지 않은한 삭제하지 않는다. 그러므로, 디렉토리를 삭제하려면, 유저는 우선 디렉토리의 모든 파일을 먼저 삭제한다. 만약 서브디렉토리가 존재하면, 이 단계는 재귀적으로 일어나서, 그들은 드디어 지워진다. 다른 접근은 유닉스의 `rm` 커맨드이고 옵션이 주어진다. 디렉토리를 삭제하라는 요청이 오면, 디렉토리의 모든 파일과 서브디렉토리는 또한 지워진다. 두 방법은 쉽게 구현이 된다. 선택은 둘중하나이다. 후자는 간편하지만, 꽤 위험하다. 왜냐하면 전체 디렉토리 구조가 한번의 커맨드로 삭제되기 때문이다. 만약 커맨드가 에러가 생기면, 많은 수의 파일과 디렉토리들이 복구될 필요가 있다.

트리 구조 디렉토리 시스템에서, 유저들은 그들의 파일, 다른 유저의 파일을 접근하기위해서 허용될수 있다. 예를 들어서, 유저 B는 유저 A의 패스이름만 정확히 명시함으로서 접근가능하다. 유저 B는 상대적 또는 절대적 패스 이름을 사용하면 된다. 대안으로는, 유저 B는 그녀의 디렉토리를 A의 디렉토리로 변경하고 그것의 파일이름으로 접근한다.