## What we gonna learn

대부분의 유저들에게, 파일 시스템은 운영체제의 가장 잘 보이는 측면이다. 그것은 on-line 저장소 메커니즘과 운영체제의 데이터와 프로그램의 접근을 제공한다. 파일 시스템은 두가지 파트로 나누어진다. 파일의 집합, 연관 데이터 저장, 디렉토리 구조 같은 시스템의 모든 파일에 대한 정보를 제공한다. 대부분의 파일 시스템은 11장에 말했고 다음 장에서 다시 언급할 저장 기기에 있다. 이 장에서는, 우리는 파일의 다양한 측면과 주요한 디렉토리 구조에 대해서 말하겠다. 우리는 또한 다양한 프로세스, 유저, 컴퓨터간에 파일을 공유하는 구조에 대해서 말하겠다. 마지막으로, 우리는 우리가 다양한 유저가 있고 누가 파일에 접근하길 원할떄 파일 보호를 다루는 방법과 어떻게 파일이 접근되는지에 대해서 논의하겠다.

## Chapter Objectives

- 시스템의 함수에 대해서 설명한다.
- 파일 시스템의 인터페이스에 대해서 설명한다.
- 접근 메서드, 파일 셰어링, 파일 락킹, 디렉토리 구조를 포함한 파일 시스템 트레이드 오프를 설명한다.
- 파일 시스템 보호를 살펴본다.

## 13.1 File Concept

컴퓨터들은 NVM 디바이스, HDDs, 자성 테이프, 광학 디스크 같은 다양한 저장 매체에 정보를 저장한다. 그래서 컴퓨터 시스템은 사용하기 편리해지고, 운영체제는 저장된 정보의 일정한 논리적 관점을 제공한다. 운영체제는 그것의 저장 디바이스의 물리적 성질을 논리적 저장 유닛인 **file**로 추상화한다. 파일들은 운영체제에 의해서 물리적 디바이스에 매핑되어있다. 이런 저장 디바이스들은 보통 비휘발성이고, 컨텐츠들은 시스템 리부트에 상관이 없다.

파일은 2차 저장소에 저장된 관계형 정보의 집합으로 불린다. 유저의 관점으로부터, 파일은 논리적 2차 저장소의 가장 작은 할당이다. 즉, 데이터는 파일에 있지 않으면 2차 저장소에 쓰일 수 없다. 일반적으로, 파일들은 프로그램(소스와 오브젝트 형식)와 데이터를 대표한다. 데이터 파일들은 숫자, 알파벳, 숫자+알파벳, 바이너리의 형식이다. 파일들은 텍스트 파일 같이 자유 형식이거나 엄격하게 형식이 있을 수 있다. 일반적으로, 파일은 파일의 생성자와 유저에 의해서 정의되는 의미있는 비트,바이트,라인 또는 레코드의 시퀀스이다. 파일의 정의는 그러므로 극히 일반적이다.

파일들이 메소드 유저들이고 데이터를 저장하고 불러오는데 쓰이는 앱이다. 그리고 그들이 일반적인 목적이므로, 그들의 이용은 그것의 원래 범위를 넘어선다. 예를 들어서, 유닉스, 리눅스와 다른 운영체제는 시스템 정보에 접근을 제공하는 파일 시스템 인터페이스를 사용하는  `proc` 파일 시스템을 제공한다.

파일의 정보는 그것의 생성자에 의해서 정의된다. 정보의 다양한 타입들이 파일에 저장된다.(소스 또는 실행 프로그램, 숫자 또는 텍스트 데이터, 사진, 음악, 비디오 등등) 파일은 그것의 타입에 달린 특별한 저의의 구조를 가진다. **text file**은 라인으로 구성된 캐릭터의 시퀀스이다. **source file**은 실행가능한 문장으로 구성된 함수의 시퀀스이다. **executable file**은 로더가 메모리에 로드하고 실행가능한 코드 부분의 연속이다.

### 13.1.1 File Attributes

파일은 사람 이용자의 편의에 맞게 이름지어지고 그것의 이름으로 언급된다. 이름은 보통 문자열이다. 몇몇 시스템은 이름에 대문자와 소문자를 구분하고, 몇몇은 그러지 않는다. 파일이 이름을 얻으면, 그것은 프로세스로, 유저, 심지어는 그것을 만든 시스템으로부터 독립적이게 된다. 예를 들어 유저가 example.c라는 파일을 만들고, 다른 유저가 그것의 이름을 명세함으로서 파일을 수정했다. 파일의 소유자는 파일을 USB 드라이브에 썼고, 그것은 이메일 첨부해서 보내거나 네트워크를 통해서 복사했고 그것은 여전히 목적 시스템에서 example.c라고 불린다. 비록 셰어링과 동기화 메서드가 있었지만, 두번째 복사본은 이제 첫번쨰와 독립적이고 분리되었다.

파일의 특성은 운영체제마다 다르지만 보통은 다음을 포함한다.
- Name : Symbolic 파일 명은 사람이 읽을수 잇는 형태로 보관되는 유일한 정보이다.
- Identifier : 보통은 숫자인 유니크 태그는 파일 시스템에서 파일을 구별한다. 그것은 사람이 읽을 수 없는 이름을 가진다.
- Type : 이 정보는 다른 타입의 파일을 제공하는 시스템에게 필요하다.
- Location : 이 정보는 디바이스의 포인터이고 디바이스에서 파일의 위치이다.
- Size : 파일의 현재 사이즈이고 최대 사이즈는 이 특성에 포함된다.
- Protection : 누가 읽고, 쓰고 실행가능한지 결정하는 접근 제어 정보이다.
- Timestamps and user identification : 이 정보는 생성, 마지막 수정, 마지막 사용을 위해서 보존된다. 이런 정보들은 보호, 보안, 사용 모니터링에 유용하다.

몇몇 새로운 파일 시스템은 파일의 인코딩 캐릭터와 파일 체크섬같은 보안 기능을 포함한 **extended file attributes**를 지원한다.

디렉토리 구조에 보관된 모든 파일에 대한 정보는 파일 자체로 같은 디바이스에 존재한다. 일반적으로, 디렉토리 엔트리는 파일의 이름과 그것의 유니크 식별자를 포함한다. 식별자는 다른 파일 특성에도 존재한다. 그것은 각 파일의 정보를 저장하는데 킬로바이트 이상을 사용한다. 많은 파일의 시스템에서, 디렉토리의 크기는 메가바이트 또는 기가바이트이다. 디렉토리들이 파일의 변동성에 매치되어야하기 때문에, 그들은 디바이스에 저장되고 보통은 메모리 단편에 가져온다.

### 13.1.2 파일 명령어

파일은 추상 데이터 타입이다. 파일을 적절히 정의하기 위해서, 우리는 파일에 실행되는 명령어를 알 필요가 있다. 운영체제는 파일을 create, write, read, reposition, delete, truncate하기 위해서 시스템콜을 제공한다. 이런 7가지 기본 파일 명령어를 살펴보겠다. 그거슨 파일 이름 바꾸기 같은 비슷한 명령어가 어떻게 보이는지 구현하기 간단해야한다.

- Creating a file : 파일을 생성하는데 두가지 단계가 필요하다. 첫번째, 파일을 위한 파일 시스템의 공간을 찾는다. 우리는 14장에서 파일을 할당하는 방법을 보겠다. 두번째, 디렉토리에 새로운 파일의 엔트리가 반드시 만들어져야한다.
- Opening a file : 모든 파일 명령어가 파일 이름을 상세하기보다는, 운영체제가 이름을 평가하게하고, 접근 허용을 확인한다. create와 delete를 제외한 모든 명령어는 먼저 open()이 필요하다. open에 성공하면, open 콜은 다른 콜의 어규먼트로 쓰이는 파일 핸들을 리턴한다.
- Writing a file : 파일로부터 읽기 위해서, 우리는 파일 핸들을 상세하고 파일의 다음에 놓여질 블럭을 찾는 시스템콜을 사용한다. 다시, 시스템은 만약 연속적이라면, **read pointer**라는 다음 리드가 실행되는 파일의 위치를 유지할 필요가 있다. 프로세스는 reading from or writing to a file 이므로 현재 명령 위치는 **current file position pointer**의 프로세스별로 저장된다. 읽기와 쓰기 명령어는 같은 포인터를 사용하고, 공간을 아끼고 시스템 복잡성을 낮춘다. 
- Repositioning within a file : 열린 파일의 현재 파일 위치 포인터는 주어진 값으로 재위치된다. 파일의 재위치는 실제 I/O를 필요로하지 않는다. 파일 명령어는 오직 file **seek**으로 알려져있다.
- Deleting a file : 파일을 삭제하기 위해서, 우리는 이름있는 파일의 디렉토리를 검색한다. 연관된 디렉토리 엔트리를 찾으면, 우리는 모든 파일 공간을 해제하고, 그것은 다른 파일에 의해서 재사용되고 디렉토리 엔트리를 지우거나 여유있다고 마킹한다. 몇몇 시스템은 **hard links**를 허용하는데, 같은 파일이 다중의 이름을 갖는 것이다. 이 경우에 실제 파일 컨텐츠는 마지막 링크가 삭제될때까지는 삭제되지 않는다. 
- Truncating a file : 유저는 파일의 컨텐츠는 지우고 싶지만 그것의 성질은 유지하고 싶다. 유저가 파일을 삭제하게 강제하고 재 생성하기보다는, 이 함수는 파일의 길이를 제외한 파일의 성질을 바귀지 않은채로 허용한다. 파일은 길이는 0으로 리셋되고, 그것의 파일 공간은 해제된다.

이 7개의 기본 명령어는 필요한 파일 명령어의 최소 집합이다. 다른 일반적인 명령어는 새로운 정보를 존재하는 파일의 끝에 붙이고 존재하는 파일의 이름을 재설정하는 것이다. 이런 원시적인 명령어는 다른 파일 명령어를 수행하기 위해서 합쳐진다. 예를 들어서, 우리는 파일의 복사를 새로운 파일을 만들고 헌 것을 읽고 새것에 쓰는 것으로 실행한다. 우리는 또한 유저가 파일의 다양한 성질을 얻고 세팅하도록 허용하는 명령어를 원한다. 예를 들어서, 우리는 유저가 파일의 정보(파일의 길이, 파일의 소유자 성질 설정)를 결정하도록하는 명령어를 원한다.

말했듯이, 대부분의 파일 명령어는 네임드 파일에 관련된 디렉토리의 엔트리를 검색하는 것을 포함한다. 이 끊임없는 검색을 피하기 위해서, 많은 시스템은 파일이 처음 사용되기전에 `open()` 시스템 콜을 요구한다. 운영체제는 모든 오픈 파일의 정보를 포함하는 **open file table**이라는 테이블을 유지한다. 파일 명령어가 요청되면, 파일은 이 테이블의 인덱스로 특정되고, 검색은 더이상 필요하지 않다. 파일이 더이상 쓰이지 않으면, 그것은 프로세스에 의해서 닫히고, 운영체제는 오픈 파일 테이블에서 그것의 엔트리를 제거하고, 락을 해제한다. create()와 delete()는 오픈 파일보다는 클로즈 파일로 수행된다.

몇몇 시스템들은 첫번째 파일 레퍼런스가 생겼을때 파일을 내부적으로 오픈한다. 파일은 파일을 연 일 또는 프로그램이 종료하면 자동으로 닫힌다. 대부분의 시스템에서, 프로그래머는 파일을 사용하기 전에`open()` 시스템 콜로 명시적으로 파일을 열기를 필요로한다. `open()` 명령어는 파일 이름을 가지고 디렉토리를 검색하고 디렉토리 엔트리를 오픈 파일 테이블에 복사한다. `open()` 콜은 접근 모드 정보를 수용하고, create, read-only, read-write, append-only 등등을 한다. 이 모드는 파일의 허용에 따라서 체크된다. 만약 요청 모드가 허용되면, 파일은 프로세스에 의해서 열린다. `open()` 시스템콜은 보통 오픈 파일 테이블의 엔트리에 있는 포인터를 리턴한다. 실제 파일이름이 아닌 이 포인터는 모든 I/O 명령에어 사용되고, 검색을 피하고 시스템 콜 인터페이스를 단순화한다.

`open()`과 `close()` 명령어의 구현은 한개의 파일을 동시에 여러개의 프로세스가 오픈하면 복잡하다. 이것은 여러개의 다른 앱들이 동시에 같은 파일을 열때 일어난다. 일반적으로, 운영체제는 내부 테이블을 두단계로 나눈다. 프로세스 테이블과 시스템 와이드 테이블이다. 프로세스 테이블은 프로세스가 연 파일을 추적한다. 이 테이블에 저장된 것은 프로세스의 파일 사용에 따른 정보이다. 예를 들어서, 각 파일의 현재 파일 포인터가 여기서 찾아진다. 예를 들어서, 현재 파일 포인터는 여기서 찾아진다. 파일과 정보의 접근 권한이 포함될 수 있다.

프로세스 테이블의 각 엔트리는 시스템 와이드 오픈 파일 테이블을 가르킨다. 시스템 와이드 테이블은 디스크의 파일의 위치, 데이터 접근, 파일 사이즈 같은 프로세스 독립 정보를 포함한다. 한번 파일이 한 프로세스에 의해서 열리면, 시스템 와이드 테이블은 파일의 엔트리를 포함한다. 다른 프로세스가 open() 콜을 실행하면, 파일의 새로운 엔트리가 적절한 시스템 와이트 테이블의 엔트리를 가르키는 프로세스의 오픈 파일 테이블을 추가한다. 일반적으로, 오픈 파일 테이블은 얼마나 많은 프로세스가 파일을 오픈한지를 가르키는 **open count**를 가진다. 각 `close()`는 오픈 카운트를 줄이고, 오픈 카우늩가 0이되면, 파일의 엔트리는 오픈 파일 테이블에서 제거된다.

