## What we gonna learn

13장에서 보았듯이, 파일 시스템은 데이터와 프로그램을 포함한 온라인 저장소와 파일 컨텐츠 접근을 위한 메커니즘을 제공한다. 이 장에서 내부 구조와 파일 시스템의 명령어를 주로 고려하겠다. 우리는 파일 사용을 구조화하고 저장공간을 할당하고, 여유 공간을 회복하고, 데이터의 위치를 추적하고, 운영체제의 다른 부분과 상호작용하는 상세한 방법을 살펴보겠다. 

## Objectives

- Delve into the details of file systems and their implementation
- Explore booting and file sharing
- Describe remote file systems, using NFS as an example

## 15.1 File Systems

확실히, 어떠한 범용 컴퓨터도 하나의 파일만 저장하지 않는다. 보통은 컴퓨터안에는 수천 수만개의 파일이 있다. 파일들은 하드 디스크 드라이브, 광학 디스크와 비휘발성 메모리 디바이스를 포함한 랜덤 액세스 저장 디바이스에 저장된다. 볼륨 매니저에 따라서, 볼륨은 다중 파티션을 거친다. 

컴퓨터 시스템들은 다양한 수의 파일 시스템을 가지고, 파일 시스템들은 다양한 타입을 가진다. 예를 들어서, 일반적인 솔라리스 시스템은 여러개의 타입의 파일 시스템을 가진다.

이 책에서, 우리는 오직 범용 파일 시스템을 고려하겠다. 알아두면 좋은 것은, 특수목적을 위한 파일 시스템이 다양하다는 것이다. 솔라리스 예시로 위의 파일 시스템의 타입을 보이겠다.
- `tmpfs` - "temprary" 파일 시스템은 휘발성 메인 메모리에서 생기고 만약 시스템이 리부트되거나 충돌을 일으키면 그것의 컨텐츠를 삭제한다.
- `objfs` - "virtual" 파일 시스템(파일 시스템 같이 생긴 커널 대상 인터페이스)은 디버거에 커널 심벌에 접근을 허용한다.
- `ctfs`  - 시스템이 부트하거나 명령어 중에 실행을 지속하는 어떤 프로세스가 시작할때 "contract" 정보를 관리하기 위한 가상 파일 시스템이다.
- `lofs`  - 하나의 파일 시스템이 다른 파트에 접근하는 것을 허용하는 "loop back" 파일 시스템
- `procfs`- 파일 시스템처럼 모든 프로세스에 정보를 보여주는 가상 파일 시스템
- `ufs, zfs` - 범용 파일 시스템

컴퓨터의 파일 시스템은 광범위할 수 있다. 파일 시스템안이어도, 그것은 파일을 그룹으로 분리하고 그 그룹에서 관리와 활동하는데 유용하다. 이 구성은 디렉토리이 사용을 포함한다.

## 15.2 File System Mounting

파일이 사용되기전에 반드시 열려야하듯이, 파일 시스템은 반드시 시스템의 프로세스에 가용하기 전에 마운트되어야한다. 더 특정하게, 디렉토리 구조는 파일 시스템 네임 스페이스 안에서 가용할수있도록 마운트되는 볼륨을 포함한 다중 파일 시스템에 생겨야한다.

마운트 과정은 직관적이다. 운영체제는 디바이스의 이름과 파일 시스템이 부착된 파일 구조안의 장소인 **mount poing**가 주어진다. 몇몇 운영체제는 다른 것들이 디바이스의 구조를 관찰하고 파일 시스템의 타입을 결정하는 파일 시스템 타입이 제공되는 것을 필요로한다. 일반적으로, 마운트 포인트는 빈 디렉토리이다. 예를 들어서, 유닉스 시스템에서, 유저의 홈 디렉토리를 포함한 파일 시스템은 파일 시스템 안의 디렉토리 구조에 접근하기 위해서 `/home`으로 마운트되고, 우리는 디렉 토리 이름은 `home/jane`과 같이 `/home`으로 지정할 수 있다.

다음으로, 운영체제는 디바이스가 유효한 파일 시스템을 포함했는지 입증한다. 그것은 디스크 드라이버에게 디바이스 디렉토리를 읽도록 물어보고 디렉토리가 예상한 포맷인지 검증한다. 마지막으로, 운영체제는 파일 시스템이 특정 마운트 포인트에서 마운트되었다고 쓴다. 이 구조는 운영체제가 그것의 디렉토리 구조를 탐색하게 하고, 파일 시스템, 다양한 타입의 파일 시스템간에 바꾼다.

시스템은 기능을 명료하게하기위해서 시맨틱을 내포한다. 예를 들어서, 시스템은 파일을 포함한 디렉토리를 넘어서 마운트를 거부한다. 또는 그것은 디렉토리에서 마운티드 파일 시스템을 유효하게 만들고 파일 시스템이 언마운트될떄까지 디렉토리의 존재파일을 애매하게하고, 파일 시스템의 사용을 종료하고 디렉토리에서 원본 파일 접근을 허용한다. 다른 예시로, 시스템은 파일 시스템이 반복적으로 마운트하게 허용하거나 파일 시스템마다 마운트할 수 있다.

macOS 운영체제를 살펴보겠다. 시스템이 디스크를 처음 마주할때, macOS 운영체제는 디바이스에서 파일 시스템을 검색한다. 만약 한가지를 찾게되면, 그것은 자동으로 `/Volumes` 디렉토리 아래에 파일 시스템을 마운트하고, 파일 시스템의 이름으로 라벨링된 폴더 아이콘을 추가한다. 유저는 그러면 아이콘을 클릭하고 새롭게 마운트된 파일 시스템을 보인다.

마이크로소프트 윈도우 패밀리의의 운영체제는 확장된 two-level 디렉토리 구조를, 디바이스와 드라이브 레터에 할당된 볼륨으로 구현한다. 각 볼륨은 범용 디렉토리 구조를 가진다. 특정 파일로의 패스는 `드라이브 레터:\path\to\file`를 가진다. 최근의 윈도우 버전은 파일 시스템이 디렉토리 트리의 어디든지 마운트되게 허용한다. 윈도우 운영체제는 부트시점에 자동으로 모든 디바이스를 찾아내고 모든 파일 시스템을 마운트한다. 몇몇 운영체제에서는, 마운트 커맨드가 확실하다. 시스템 설정 파일은 디바이스의 리스트를 포함하고 부트 시점에 자동 마운팅 포인트를 마운트하지만, 다른 마운트들은 수동으로 실행된다.

## 15.3 Partitions and Mounting

디스크의 레이아웃은 운영체제와 볼륨 관리 소프트웨어에 따라서 다양한 변형을 가진다. 디스크는 다중 파티션으로 슬라이스되거나 볼륨은 다중 디스크의 다중 파티션을 가진다. 두번쨰 것은 RAID의 형태로 고려하면 된다.

각 파티션은 파일 시스템을 포함하지 않은 "raw"이거나, 파일 시스템을 포함한 "cooked"이다. **Raw disk**는 어떠한 파일 시스템도 적절하지 않은 곳에서 쓰인다. 유닉스 스왑 공간은, 예를 들어서, 그것이 디스크위의 전용 포맷을 사용하고 파일 시스템을 이용하지 않는다. Raw disk는 어떤 블럭이 미러링되었는지 어떤 것이 변하고 미러가 필요한지 알리는 비트맵같은 디스크 RAID 시스템에 의해서 필요한 정보를 가진다. 비슷하게, raw disk는 어떤 디스크가 각 RAID 집합의 멤버인지 알리는 RAID 설정 정보를 가진 미니어처 데이터베이스를 포함한다. Raw disk는 11.5.1에서도 언급되었다. 

만약 파티션이 적절하게 설치되고 운영체제에게 설정되는 부트가능한 파일 시스템을 포함하면, 파티션은 또한 부트 정보를 필요로한다. 이 정보는 그것의 전용 포맷을 가지고, 시스템이 로드된 파일 시스템 코드를 가지고 있지 않고 그러므로 파일 시스템 포맷으로 해석되지 않는다. 