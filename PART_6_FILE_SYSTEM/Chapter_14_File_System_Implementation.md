## What we gonna learn

13장에서 보았듯이, 파일 시스템은 온라인 저장소와 데이터와 프로그램을 포함한 파일컨텐츠에 접근을 위한 메커니즘을 제공한다. 파일 시스템들은 보통 2차 저장소에 영구적으로 저장되고, 큰 양의 데이터를 잡기위해서 디자인되었다. 이번 장은 파일 저장소와 2차저장소의 접근을 둘러싼 주요한 문제를 고려하겠다. 우리는 파일 사용을 구조화하고, 저장 공간을 할당하고, 풀린 공간을 회복하고, 데이터의 위치를 추적하고, 운영체제에서 2차저장소로의 인터페이스를 하는 몇가지 방법을 살펴보았다. 성능 문제는 전반적으로 살펴보겠다.

일반적인 운영체제는 다양한 파일시스템을 제공한다. 추가적으로, 많은 운영체제는 관리자 또는 유저가 파일 시스템을 추가하도록 허용한다. 파일 시스템은 기능, 성능, 신뢰성, 디자인 목적을 포함한 다양한 측면을 가진다. 예를 들어서, 임시 파일 시스템은 빠른 저장소와 비영구 파일의 회수로 사용되고, 일반적인 2차 저장소 파일 시스템은 신뢰성과 기능을 위해서 성능을 희생한다. 우리가 운영체제의 공부로 보았듯이, 다양한 선택과 변형이 있고 다양한 도전으로 채운다. 이 장에서, 우리는 일반적인 분모에 집중하겠다.

## Objectives

- 로컬 파일 시스템과 디렉토리 구조를 구현하는 상세한 방법을 설명하겠다.
- 블럭 할당과 자유 블럭 알고리즘과 트레이드오프를 살펴보겠다.
- 파일 시스템 효율성과 성능 이슈를 살펴보겠다.
- 파일 시스템 실패로부터의 회복을 보겠다. 
- WAFL 파일 시스템을 예시로 보겠다.

## 14.1 파일 시스템 구조

디스크들은 파일 시스템을 유지하는 2차 저장소의 대부분을 제공한다. 두가지 성질이 그들을 이 목적을 편하게 달성하기 위해서 있다.

1. 디스크는 한 장소에서 다시 쓰일 수 있다. 그것은 디스크로부터 블럭을 읽고, 블럭을 수정하고, 같은 블럭에 쓸 수 있다.
2. 디스크는 그것을 포함하는 어떠한 정보에도 직접 접근할 수 있다. 그러므로, 어떠한 파일에 연속적으로 또는 무작위로 접근하는 것은 단순하고, 한 파일에서 다른 파일로 변경하는 것은 읽기-쓰기 헤드를 움직이는 것과 미디어가 회전하기를 기다리는 것을 필요로한다.

NVM 디바이스들은 파일 저장소로 점점 상용화되어가고 있고 그러므로 파일 시스템의 위치이다. 그들은 그들이 제자리에 다시 쓰일 수 없고 다른 성능 성질을 가지고있다는 차이가 존재한다. 우리는 디스크와 NVM 구조는 11장에서 다루었다.

I/O 효율을 증가시키기 위해서, 메모리와 대량 저장소 사이의 I/O 전송은 **block**단위로 수행된다. 하드 디스크 드라이브의 각 블럭은 하나 또는 여러개의 섹터를 가진다. 디스크 드라이브에 따라서, 섹터 사이즈는 보통 512 바이트 또는 4096바이트이다. NVM 디바이스는 보통 4096 바이트의 블럭을 가지고, 전송 메서드들은 디스크 드라이브에 쓰이는 것과 비슷하다.

**File systems**는 저장되고, 위치되고, 복구될 데이터를 허용함으로서 저장 디바이스에 효율적이고 간편한 접근을 제공한다. 파일 시스템은 2가지 꽤 다른 디자인 문제를 취한다. 첫번째 문제는 파일 시스템이 유저에게 어떻게 보여주는 가이다. 이 태스크는 파일과 그것의 성질, 파일에 허용된 명령어와 파일을 구성하는 디렉토리 구조를 정의하는 것을 포함한다. 두번째 문제는 논리적 파일 시스템 위에 물리적 2차 저장소 디바이스를 매핑하는 데이터 구조와 알고리즘을 만드는 것이다.

파일 시스템은 다른 레벨로 구성되어있다. 각 레벨은 낮은 단계의 기능을 이용하고 높은 레벨에 의해서 새롭게 사용되는 기능을 생성한다.

**I/O control** 레벨은 디바이스 드라이브를 포함하고 메인 메모리와 디스크 시스템 사이의 정보를 전송한다. 디바이스 드라이버는 번역기로서 생각될 수 있다. 그것의 인풋은 `retrieve block 123`과 같이 높은 레벨 커맨드로 구성되어있다. 그것의 아웃풋은 로우 레벨이고, 하드웨어 컨트롤러에 의해서 사용되는 I/O 디바이스에서 시스템의 나머지 하드웨어에 인터페이스하는 특정 명령어를 포함한다. 디바이스 드라이버는 보통 특정 비트 패턴을 컨트롤러에게 어떤 디바이스 위치에서 행동하고 어떤 행동을 취할지 알려주는 I/O 컨트롤러의 메모리안의 특별한 위치에 쓴다. 디바이스 드라이버와 I/O 기반 구조는 12장에서 다루었다.

**basic file system**은 적절한 디바이스 드라이버가 저장 디바이스에 블럭을 읽고 쓰는 제너릭 커맨드를 발행한다. 논리 블럭 주소에 기반한 드라이버에 명령을 발행한다. 그것은 또한 I/O 요청 스케쥴링을 포함한다. 이 층은 다양한 파일시스템, 디렉토리, 데이터 블럭을 유지하는 메모리 버퍼와 캐시를 관리한다. 버퍼안의 블럭은 대규모 저장소 블럭의 전송이 일어나기전에 할당된다. 버퍼가 가득차면, 버퍼 매니저는 반드시 많은 버퍼 메모리를 찾거나 요청된 I/O가 완료되기 위해서 버퍼 공간을 해제해야한다. 캐시들은 자주 사용되는 파일 시스템 메타데이터를 저장해서 성능을 향상시키고, 그들의 컨텐츠를 관리하는 것은 최적의 시스템 성능에 중요하다.

**file organization module**은 파일과 그들의 논리 블럭을 알고 있다. 각 파일의 논리 블럭들은 0부터 N까지 번호를 가진다. 파일 구성 모듈은 할당되지 않은 블럭을 추적하고 요청이 있을때 이런 블럭을 제공하는 여유 공간 매니저를 포함한다.

마지막으로, **logical file system**은 메타 데이터 정보를 관리한다. 메타 데이터는 실제 데이터를 제외한 모든 파일 시스템의 구조를 포함한다. 논리 파일 시스템은 후에 필요한 심벌릭 파일 네임과 함께 파일 구성 모듈을 제공하기 위해서 디렉토리 구조를 관리한다. 그것은 파일 컨트롤 블럭을 통해서 파일 구조를 유지한다. **File control block(FCB)**는 파일에 관한 소유권, 허가, 파일 컨텐츠의 위치같은 정보를 포함한다. 논리 파일 시스템은 또한 13장과 17장에서 언급할 보호에도 책임이 있다.

계층 구조가 파일 시스템 구현을 위해서 사용되면, 코드의 복제는 최소화된다. I/O 컨트롤과 가끔 기본 파일 시스템 코드는 다양한 파일 시스템을 위해서 사용될 수 있다. 각 파일 시스템은 그것의 논리 파일 시스템과 파일 구성 모듈을 가진다. 불행히도, 레이어링은 더 많은 운영체제 오버헤드를 초래해서 성능을 낮출 수 있다. 레이어링의 사용, 얼마나 많은 레이어를 사용하고 각 레이어가 무엇을 할지를 포함하는 결정은 새로운 시스템을 디자인하는데에 큰 도전과제이다.

오늘날의 많은 파일 시스템과 운영체제는 하나이상을 지원한다. 예를 들어서, 대부분의 CD-ROMs들은 CD-ROM 생산자들이 쓰는 표준 ISO 9660 포맷으로 쓰였다. 삭제 가능한 미디어 파일 시스템에서는, 각 운영 체제는 하나 이상의 파일 시스템을 가진다. 유닉스는 버클리 Fast File System(FFS)를 기반으로한 **UNIX file system(UFS)**를 사용한다. 윈도우는 FAT, FAT32, NTFS의 디스크 파일 시스템 포맷을 지원한다. 비록 리눅스는 130개의 다른 파일 시스템을 지원하지만, 표준 리눅스 파일 시스템은 **extended file system**이다. 서버에서의 분산 파일 시스템은 네트워크를 통해서 마운트된 하나 이상의 클라이언트 컴퓨터이다.

파일 시스템 연구는 운영체제 디자인과 구현의 영역에서 지속된다. 구글은 큰 디스크를 걸친 많은 클라이언트로부터의 높은 성능의 접근을 포함한 회사의 특정 저장소와 복귀 능력을 충족하는 자신의 파일 시스템을 만들었다. 다른 흥미로운 프로젝트는 FUSE 파일 시스템인데, 커널 레벨 코드보다는 유저 레벨에서 파일 시스템을 구현하고 실행해서 파일 시스템 개발과 사용에 유연성을 제공한다. FUSE를 사용하면, 유저는 운영체제에 새로운 파일 시스템을 추가할 수 있고 그녀의 파일을 관리하기 위해서 파일 시스템을 사용할 수 있다.

## 14.2 File System Operations

13.1.2에서 보앗듯이, 운영체제는 프로세스를 위해 파일 컨텐츠로의 접근을 요청하는 `open()`과 `close()` 시스템 콜을 구현했다. 이 절에서, 우리는 파일 시스템 명령어를 구현하기 위한 구조와 명령어를 뒤지겠다.

### 14.2.1 Overview

몇가지 온 스토리지와 인 메모리 구조는 파일 시스템을 구현하기 위해서 사용된다. 이런 구조들은 운영체제와 파일 시스템에 따라서 다양하지만, 몇몇 일반적인 원리가 적용된다.

저장소에서, 파일 시스템은 저장된 운영체제를 어떻게 부트할지, 블럭의 전체 수, 여유 블럭의 위치와 수, 디렉토리 구조, 개인 파일에 대한 정보가 담겨 있다. 이런 구조들이 이 장의 전반에 담겨 있다. 여기서는 간단하게 그들을 설명하겠다.

- **Boot control Block**은 시스템이 운영체제를 부팅할 정보를 포함한다. 만약 디스크가 운영체제를 포함하지 않으면, 이 블럭은 비어진다. 그것은 보통 볼륨의 첫 블럭이다. UFS에서 그것은 **boot block**이라고 불린다. NTFS에서는 **partition boot sector**라고 불린다.
- **volume control block**은 볼륨의 블럭의 수, 블럭의 사이즈, 여유 블럭 수, 여유 블럭 포인터와 여유 FCB 카운트와 FCB 포인터 같은 볼륨 상세를 포함한다. UFS에서 **super block**이라하고 NTFS에서 **master file table**이라고 한다.
- 디렉 토리 구조는 파일을 구성하기 위해서 사용된다. UFS에서, 이것은 파일 이름과 연관된 inode 수를 포함한다. NTFS에서는, master file table에 저장한다.
- 파일당 FCB는 파일에 관한 많은 상세정보를 포함한다. 그것은 디렉토리 엔트리에 관련된 유일 식별자수를 가진다. NTFS에서, 이 정보는 마스터 파일 테이블에 사용되고, 관계형 데이터 구조를 파일당 열로 가진다.

인 메모리 정보는 파일 시스템 관리와 성능 향상을 캐싱을 통해서 사용한다. 데이터들은 마운트 시간에 로드되고, 파일 시스템 명령 중에 업데이트되고 디스마운트에 버려진다. 몇가지 타입의 구조가 포함된다.

- 인 메모리 **mount table**은 각 마운트된 볼륨에 관한 정보를 가진다.
- 인 메모리 디렉토리 구조 캐시는 최근에 접근한 디렉토리의 정보를 가진다.
- **system-wide open file table**은 각 오픈 파일의 FCB의 복사본을 포함한다.
- **per process open file table**은 시스템 와이드 오픈 파일 테이블의 적절한 엔트리 포인터를 가진다. 프로세스가 오픈한 모든 파일이다.
- 버퍼는 그들이 파일 시스템에서 읽고 쓸때 파일 시스템 블럭을 가진다.

새로운 파일을 생성하기 위해서, 프로세스는 논리 파일 시스템을 콜한다. 논리적 파일 시스템은 디렉토리 구조의 포맷을 안다. 새로운 파일을 만들기 위해서, 그것은 새로운 FCB를 할당한다.(대안으로, 만약 파일 시스템 구현이 모든 FCB를 파일 시스템 생성시간에 만들면, FCB는 여유 FCB의 집합에 할당된다.) 시스템은 그리고 적절한 디렉토리를 읽는다.

몇몇 운영체제는 디렉토리를 파일과 같이 취급하고, "type"을 디렉토리로 가르킨다. 다른 운영체제는 파일과 디렉토리에 분리된 시스템 콜을 구현하고 파일로부터 분리된 엔티티를 디렉토리로 취급한다. 구조적 이슈가 더 클수록, 논리 파일 시스템은 저장소 블록 위치로 디렉토리 I/O를 맵하기 위해서 파일 구성 모듈을 콜한다. 

### 14.2.2 Usage

이제 파일은 생성되었고, 그것은 I/O를 위해서 사용될 수 있다. 먼저, 그것은 열려야한다. `open()` 콜은 파일 네임을 논리 파일 시스템에 패스한다. `open()` 시스템 콜은 먼저 시스템 와이드 오픈 파일을 이용해서 다른 프로세스가 접근중인지 확인한다. 만약 그렇다면, per process open file table 엔트리는 존재하는 시스템 와이드 오픈 파일 테이블을 가르키고 있다. 이 알고리즘은 오버헤드를 아끼게한다. 만약 파일이 미리 열리지 않았으면, 디렉 토리 구조는 주어진 파일 이름을 위해서 검색된다. 디렉토리 구조의 일부는 디렉토리 명령어를 가속하기 위해서 메모리에 캐시된다. 파일을 찾으면, FCB는 메모리의 시스템 와이드 오픈 파일 테이블에 복사된다. 이 테이블은 FCB를 저장할 뿐만 아니라 파일을 연 프로세스의 수 또한 추적한다.

다음으로, 엔트리는 per process open file table에서 시스템 와이드 오픈 파일 테이블과 다른 영역의 엔트리를 가르키는 포인터로 만들어진다. 이런 다른 필드들은 파일의 현재위치를 알리는 포인터와 어떤 파일이 열릴떄의 엑세스 모드를 포함한다. `open()`콜은 적절한 엔트리의 포인터를 리턴한다. 모든 파일 명령어들은 포인터를 통해서 수행된다. 파일 이름은 오픈 파일 테이블의 일부가 아니고, 시스템은 한번 적절한 FCB가 디스크에 위치될때 필요가 없다. 엔트리에 의해서 주어진 이름은 다양한데, 유닉스는 **file descriptor** 윈도우는 **file handle**이라고 한다.

프로세스가 파일을 닫으면, per process table 엔트리는 사라지고, 시스템 와이드 엔트리의 오픈 카운트는 줄어든다. 파일을 열었던 모든 유저가 닫으면, 업데이트된 메타데이터들은 디스크 베이스의 디렉토리 구조에 복사되고 시스템 와이드 오픈 파일 테이블은 제거된다.

파일 시스템의 캐싱또한 간과하면 안된다. 대부분의 운영체제들은 오픈 파일에 대한 모든 정보를포함한다. BSD 유닉스 시스템은 디스크 I/O가저장가능할떄마다 캐시를 사용한다. 그것의 캐시 히트 레이트는 85퍼센트가량된다. BSD 유닉스는 Appendix C에서 더 다룬다.

## 14.3 디렉토리 구현

디렉토리 할당과 디렉토리 관리 알고리즘의 선택은 효율성, 성능, 파일 시스템의 신뢰성에 큰 영향을 준다. 이 절에서, 우리는 이 알고리즘을 선택하는 것에 대한 트레이드 오프를 보겠다.

### 14.3.1 리니어 리스트

디렉토리를 구현하는 가장 간단한 메서드는 데이터 블럭을 향한 포인터를 가진 파일이름의 리니어 리스트를 사용하는 것이다. 이 메서드는 구현은 간단하지만 실행에 시간을 소모한다. 새로운 파일을 생성하기 위해서, 우리는 같은 파일의 이름이 디렉토리에 없는 것을 먼저 찾아야한다. 그리고, 우리는 디렉토리의 끝에 새로운 파일을 추가한다. 파일을 삭제하기 위해서, 우리는 파일 이름을 디렉토리에서 찾고 할당된 공간을 해제한다. 디렉토리 엔트리를 재사용하기 위해서, 우리는 몇가지 일을 할 수 있다. 우리는 엔트리를 비사용이라고 마크하거나, 우리는 여유 디렉토리 엔트리의 리스트를 붙인다. 3번째 대안은 여유로워진 위치에 디렉토리의 마지막 엔트리를 복사하는 것이다. 그리고 디렉토리의 길이를 줄이는 것이다. 

리니어 리스트의 단점은 파일을 찾는 것이 선형 검색을 필요로하는 것이다. 디렉토리 정보는 자주 사용되고, 유저들은 만약 접근이 너무 느리면 통보한다. 실제로, 많은 운영체제가 가장 최근에 사용한 디렉토리 정보를 저장하는 소프트웨어 캐시를 구현한다. 캐시 히트는 2차 저장소로부터 다시 읽는 것을 피한다. 정렬된 리스트는 이진 검색을 허용하고 평균 검색 시간을 감소시킨다. 그러나, 리스트를 정렬된채로 두는 것은 파일의 생성과 삭제를 복잡하게 하고, 우리는 정렬된 디렉토리를 유지하기 위해서 디렉토리 정보를 더 써야한다. 정렬 트리의 장점은 정렬된 디렉토리 리스팅은 분리된 정렬 과정이 생략된다.

### 14.3.2 해시 테이블

파일 디렉토리에 사용되는 다른 데이터 구조는 해시 테이블이다. 여기서, 리니어 리스트는 디렉토리 엔트리를 저장하지만, 해시 테이블 구조도 사용한다. 해시 테이블은 파일이름으로부터 계산된 값을 가지고 파일 이름의 포인터를 리턴한다. 그러므로, 이것은 디렉토리 검색시간을 최대로 줄일 수 있다. 삽입, 삭제 또한 직관적이고, 몇몇 영역은 충돌을 일으킬수있긴하다.

해시테이블의 주요한 어려움은 그것의 일반적인 고정사이즈와 그사이즈에 따른 해시 함수의 의존성이다. 예를 들어서, 우리가 64개의 엔트리를 가진 해시 테이블을 만들었다. 해시 함수는 파일 이름은 0~63으로 정수화했다. 만약 우리가 65를 찾으면, 우리는 디렉토리 해시 테이블을 크게하고 128 엔트리가 된다. 결과적으로 0~127을 위한 새로운 해시 함수가 필요하고 존재하는 디렉토리 엔트리를 새로운 해시 함수 값을 반영하기 위해서 재구성해야한다.

대안으로, 우리는 체인드 오버 플로 해시테이블을 사용한다. 각 해시 엔트리는 개인 값대신 링크드 리스트를 가지고 링크드 리스트에 새로운 엔트리를 추가해서 충돌을 해결한다. 룩업은 조금 느려지겠지만, 왜냐하면 링크드 시스트의 충돌 테이블 엔트리를 선형으로 찾아야기 때문이다. 그러나, 이 메서드는 여전히 전체 디렉토리를 선형검색하는 것보다 빠르다.