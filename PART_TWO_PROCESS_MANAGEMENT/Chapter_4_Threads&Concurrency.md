# what we gonna study

챕터3에서 프로세스 모델은 한개의 스레드가 작동하는 프로그램이다. 가상적으로 모든 운영체제 시스템에서는 프로세스가 다중의 스레드를 작동하는 기능을 제공한다. 스레드의 사용을 통한 병렬처리 식별은 멀티 CPU를 제공하는 멀티코어 시스템에서 점점 중요해지고 있다. 

이 장에서는, 우리는 많은 개념을 소개하는데, Pthreads, Windows, Java Thread API의 토론을 멀티스레드 컴퓨터 시스템과 연관지어서 공부한다. 덧붙여서, 우리는 스레드 생성 추상화, 병렬처리를 지원하는 개발자 허용, 언어 기능과 API 프레임워크을 실행, 스레드 관리의 명세를 보이겠다. 우리는 멀티스레드 프로그래밍과 관련된 이슈와 그것이 운영체제에 미치는 영향을 공부한다. 마지막으로, 우리는 윈도우와 리눅스 운영체제가 커널레벨에서 지원하는 스레드 기능을 보겠다.

# Chapter Objectives

- 스레드의 기본 구성요소를 보고, 스레드와 프로세스의 차이를 알아본다.
- 멀티스레드 프로세스를 디자인하고 주요한 장점을 보겠다.
- 내재적인 스레드 풀, 포크-조인, Grand Central Disaptch을 포함한 내재적인 스레딩 접근을 설명하겠다.
- 윈도우와 리눅스 운영체제를 대표하는 스레드를 구현한다.
- Pthreads, Java, 윈도우 스레딩 API를 사용하는 멀티스레드를 디자인한다.

## 4.1 Overview

스레드는 CPU 효율성의 기초 단위이다. 그것은 스레드 ID, PC, 레지스터 셋과 스택으로 구성되어있다. 그것은 다른 스레드와 코드, 데이터, 운영체제 리소스(파일, 신호)를 공유한다. 전통적인 프로세스는 싱글 스레드 컨트롤이었다. 만약 프로세스가 다중 스레드라면, 그것은 같은 시간동안 한개보다 많은 일을 할 수 있다.

### 4.1.1 동기

대부분의 소프트웨어 앱들은 멀티스레드이다. 앱들은 여러개의 스레드를 가진 분리된 프로세스로 구현된다. 우리는 몇개의 멀티스레드 앱을 보겠다.

- 이미지 컬렉션으로부터 각각의 이미지로 섬네일을 만드는 것은 분리된 스레드를 사용할 수도 있다.

- 웹 브라우저는 이미지나 텍스트를 띄우는 다른 스레드는 동안 네트워크로부터 데이터를 순회하고 있다.

- 워드 프로세스는 그래픽을 띄우면서, 다른 스레드는 유저로부터 키입력을 반응하고, 3번째 스레드는 스펠링과 문법체크를 백그라운드에서 수행한다.

앱들은 멀티시스템에서 'leverage(영향력) processing capablilities'로 디자인된다. 이런 앱들은 멀티 컴퓨팅 코어에서 CPU 집중 태스크를 실행할 수 있다.

어떤 상황에서는, 단일 앱은 비슷한 태스크를 실행하는 것을 필요로 할 수 있다. 예를 들어서, 웹 서버는 웹페이지, 이미지, 사운드 등을 클라이언트 요청으로 수락할 수 있다. 바쁜 웹 서버는 병렬적으로 접근하는 클라이언트를 가질 수 있다. 만약 웹서버가 단일 스레드에서 작동하면, 그것은 오직 한명의 클라이언트만 가능할 것이고, 클라이언트는 서비스가 실행되도록 긴 시간을 기다려야 한다.

한가지 해결책은 한개의 프로세스로만 요청을 받아들이는 서버를 가지는 것이다. 서버가 요청을 받아들이면, 그것은 요청을 서비스하도록 분리된 프로세스를 생성한다. 실제로, 이런 프로세스 생성 메소드는 스레드가 유명해지기 전에 일반적인 방법이었다. 프로세스 생성은 시간을 많이 소요하고 리소스를 많이 먹는다. 만약 새로운 프로세스가 존재하는 프로세스와 같은 일을 하면 뭐하러 간접비를 또 지불하는가?? 한개의 프로세스가 다중 스레드를 가지는 것이 훨씬 효율적이다. 만약 웹-서버 플세스가 멀티 스레드이면, 서버는 클라이언트 요청을 들을 분리된 스레드를 만들면 된다. 요청이 만들어지면, 프로세스를 새로 만드는 것보다는, 서버가 새로운 스레드를 만들어서 요청을 처리하고 추가 요청을 듣는 것을 재시작한다.

대부분의 운영체제 커널들은 보통 멀티스레드이다. 예를 들어서, 리눅스의 시스템 부트동안에, 몇몇 커널 스레드는 생성된다. 각각의 스레드는 특정한 업무(디바이스 관리, 메모리 관리, 인터럽트 관리)를 실행한다. 커맨드 ps -ef는 리눅스에서 실행중인 커널스레드를 보인다. 이 커밴드의 결과물은 모든 커널 스레드의 부모를 제공하는 커널 스레드 *ktreadd*를 보여준다. 

많은 앱들은 다중 스레드의 장점을 가지는데, 소팅, 트리, 그래프 알고리즘이 포함되어있다. 덧붙여서, 데이터 마이닝, 그래픽스, AI 같은 현대의 CPU 집중 문제들을 해결해야하는 프로그래머들은 병렬적으로 수행하도록 멀티코어 시스템을 디자인 함으로서 기능을 올릴 수 있다.

### 4.1.2 장점

멀티 스레드 프로그래밍의 장점은 4가지로 나뉜다.

1. Responsiveness(반응성) : 상호작용하는 앱들을 멀티스레딩하는 것은 프로그램이 일부분이 막히거나, 긴 명령어를 실행해서 유저의 responsiveness를 증가시킬때에도 계속 실행하도록 허용한다. 퀄리티는 유저 인터페이스를 디자인할 때 특히 유용해진다. 예를 들어서, 유저가 시간을 많이 잡아먹는 명령어 실행 버튼을 클릭할때를 고려해보자. 싱클 스레드 앱들은 명령어가 완료될떄까지 반응을 하지 않을 것이다. 반면에, 만약 시간을 잡아먹는 명령어가 분리된, 비동기화된 스레드에서 작동하면, 앱은 유저에게 반응성을 유지한다.

2. Resource sharing : 프로세스는 공유 메모리와 메시지 패싱을 통해서 리소르를 공유한다. 그런 기술들은 프로그래머에 의해서 확실히 생성되어야한다. 그러나, 스레드들은 메모리를 공유하고 그들이 가진 프로세스의 리소스를 디폴트로 가진다. 코드와 데이터를 공유하는 장점은 앱들이 같은 주소영역안에서 활동의 여러가지 다른 스레드를 가지도록한다.

3. Economy : 프로세스 생성을 위한 메모리와 리소스 할당은 비용이 크다. 스레드들이 그들이 속한 리소스를 공유하기에, 스레드를 만들고 컨텍스트-스위치하는 것은 훨씬 경제적이다. 경험적으로 간접비를 검량하는 것은 힘들지만, 일반적으로 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 차지한다. 추가적으로, 컨텍스트 스위칭은 프로세스간보다는 스레드에서 훨씬 빠르다.

4. Scalability(확장성) : 멀티 스레딩의 장점은 스레드가 다른 프로세싱 코어에서 병렬적으로 작동하는 멀티 프로세서 아키텍처보다 훨씬 클수도 있다. 싱글 스레드 프로세스는 여러개가 있어도 오직 한개의 프로세서에서 작동한다. 우리는 다음 절에서 이것을 보겠다.

## 4.2 Multicore Programming

컴퓨터 디자인의 초기 역사에서, 더 좋은 컴퓨팅 성능을 위해서, 싱글 CPU 시스템은 멀티 CPU 시스템으로 진화했다. 후에, 시스템 디자인의 트렌드는 여러개의 코어를 가진 단독 칩으로 멀티 컴퓨팅 코어를 가지도록 되었다. 우리는 이런 시스템을 **multicore**라고 했고, 멀티 스레드 프로그래밍은 멀티 프로그래밍 컴퓨팅 코어와 향상된 병렬성을 더욱 효율적인 메커니즘에서 제공하도록 했다. 4개의 스레드를 가진 앱을 생각해보겠다. 단독 컴퓨팅 코어를 가진 시스템에서, 컨커런시는 스레드의 실행을 끼우는 것을 의미할 수도 있는데, 왜냐하면 프로세싱 코어는 오직 하나의 스레드를 한번에 작동하기에 적합하다. 멀티 코어 시스템을 가진 시스템에서는, 컨커런시는 여러개의 스레드가 병렬적으로 처리되는 것을 의미하는데, 왜냐하면 시스템은 각각의 코어에서 분산된 스레드이기 때문이다.

*concurrency*와 *parallelism*은 여거시 확실한 차이를 배우겠다. concurrent 시스템은 모든 태스크를 단계적으로 실행함으로서 한개보다 많은 태스크를 지원한다. 반대로, 병렬 시스템은 동시에 한개보다 많은 일을 실행하게 한다. 그러므로, parallelsm 없는 concurrency는 존재한다. 멀티 프로세서와 멀티코어 아키텍처의 급발전 전에는, 대부분의 컴퓨터는 오직 싱글 프로세서만 가졌기에, CPU 스케쥴러는 고속으로 프로세스간에 스위칭함으로서 parallelism의 환상을 제공했고, 각 프로세스가 단계적으로 실행하게 만들었다. 이런 프로세스들은 Concurrently이지 parallel은 아니다.

### 4.2.1 프로그래밍 챌린지

멀티코어 시스템의 트렌드는 시스템 디자이너와 앱 프로그래머들이 더욱 나은 멀티 컴퓨팅 코어를 더 좋게 사용하게끔 압박을 주었다. 운영체제의 디자이너들은 멀티 프로세싱 코어가 parallel 실행을 하게끔 스케쥴링 알고리즘을 썼다. 앱 프로그래머들은, 현존하는 프로그램을 새로운 프로그램이 멀티스레드하게 수정하는 챌린지를 받았다.

일반적으로 멀티코어 시스템에는 5가지 챌린지가 존재한다.

1. Identifying tasks : 이것은 분리된, concurrent한 태스크를 나누는 영역을 앱을 통해서 찾는 것이다. 이상적으로는, 태스크들은 다른 것과 독립적이므로 각각의 코어들은 병렬적으로 개인 코어를 가진다.

2. balance : 병렬적으로 실행할 태스크를 구분하는 동안, 프로그래머들은 같은 가치의 같은 일을 태스크가 수행하는 것을 확신해야한다. 몇가지 예시로, 어떤 일은 다른 태스크보다 전체의 프로세스에 큰 결과를 공헌하지 않을 수 있다. 분리된 코어 실행을 사용하는 태스크는 사실 코스트의 가치를 없는 것이다. 

3. Data splitting : 분리된 태스크로 앱들이 구별되있는 것처럼, 데이터 접근과 조작은 반드시 분리된 코어에서 쪼개져야한다.

4. Data dependency : 태스크에 데이터 접근은 두개 또는 더 많은 태스크는 반드시 의존성을 가져야한다. 하나의 태스크가 다른 데이터로 의존하면, 프로그래머들은 반드시 데이터 의존성을 가지는 동기화 태스크 실해을 해야만 한다. 이 전략은 6장에서 공부한다.

5. Testing and debugging : 프로그램이 병렬 코어에서 실행될때에, 많은 실행 경로가 가능하다. 이런 concurrent 프로그램의 테스팅과 디버깅은 싱글 스레드 앱보다 훨씬 힘들다.

이런 챌린지 때문에, 많은 소프트웨어 개발자들은 멀티코어 시스템의 급발전이 소프트웨어 미래에 새로운 접근을 만들어냈다고 주장한다.(비슷하게 많은 컴퓨터 공학 교육자들은 병렬 프로그래밍의 강조를 많이 해야하다고 한다.)

### 4.2.2 병렬의 종류

보통, 두가지의 병렬이 있다. 데이터 병렬과 태스크 병렬이다. **Data parallelism**은 다중 컴퓨팅 코어사이의 같은 데이터 분산과 각 코어의 같은 명령어 수행에 집중한다. 예를 들어서, N 사이즈의 행렬을 더하는 것을 생각하겠다. 한개의 스레드는 0~N-1까지를 간단하게 더하는 것이다. 그러나 듀얼 코어 시스템에서는 A가 0~N/2, B가 N/2+1~N-1까지를 더한다. 두개의 스레드는 분리된 컴퓨팅 코어에서 병렬적으로 수행된다.

태스크 병렬은 데이터 분산이 아니라 멀티 컴퓨팅 코어에서의 태스크 분산이다. 각 스레드는 고유한 명령어를 실행한다. 다른 스레드들은 같은 데이터에서 작동하거나, 그들은 다른 데이터에서 실행된다. 위의 예시를 다시하겠다. 그 상황과 다르게, 태스크 병렬은 두개의 예시는 각각은 행렬의 원소에 특별한 통계적인 명령어를 실행한다. 스레드는 분리된 코어에서 병렬적인 명령을하지만, 각각은 특별한 명령을 실행한다.

기초적으로, 데이터 병렬은 멀티 코어의 분산된 데이터를 포함하고, 태스크 병렬은 멀티 코어의 분산된 태스크를 포함한다. 그러나, 데이터와 태스크 병렬은 상호적으로 배제하지 않고, 앱들은 두 전략의 하이브리드를 가진다.

## 4.3 멀티스레딩 모델

우리의 논의는 일반적인 사오항의 스레드 관리이다. 그러나, 스레드 지원은 유저레벨에서 제공되고, 유저 스레드, 커널 스레드가 있다. 유저 스레드는 커널 위에서 지원하고 커널의 지원없이 관리된다. 반면에 커널 스레드는 운영체제에 의해서 직접 지원/관리된다. 가상적으로 모든 현대 운영체제는 커널 스레드를 지원한다.

최종적으로, 유저스레드와 커널스레드는 관계를 가진다. 이 절에서는, 우리는 이런 관계를 확립하는 3가지 방법을 보겠다. many-to-one model, one-to-one model, many-to-many model이다.

### 4.3.1 Many-to-One Model

이 모델은 많은 유저레벨 스레드를 하나의 커널 스레드에 맵핑한다. 스레드 관리는 유저 공간의 스레드 라이브러리에서 실행되는데, 효율적이다.(스레드 라이브러리는 4.4에서 알아본다.) 그러나, 전체 프로세스는 만약 스레드가 블럭킹 시스템 콜을 만들면 블락한다. 또한, 오직 한개의 스레드가 동시에 커널에 접근하기에, 다중 스레드들은 멀티코어 시스템에서 병렬적으로 수행불가능하다. **Green threads**는 솔라리스 시스템에 적용되고 자바의 초기 버전에 채택되어서, many-to-one 모델을 사용한다. 그러나 소수의 시스템이 이제는 대부분의 컴퓨터 시스템에서 사용되는 멀티 프로세싱 코어 장점을 못받아드려도 사용중이다.

### 4.3.2 One-to-One Model

이 모델은 각각의 유저 스레드를 커널 스레드에 연결한다. 그것은 다른 스레드가 스레드가 블럭킹 시스템콜을 만들때도 실행함으로서 many-to-one 모델보다 concurrency를 제공한다. 그것은 또한 멀티 프로세서에서 멀티 스레드가 작동하도록 허용한다. 이 모델의 유일한 단점은 유저 스레드를 만드는 것은 커널 스레드를 만드는 것을 필요로하고 많은 커널 스레드는 시스템에 큰 부담을 주게된다. 리눅스, 윈도우는 One-to-One 모델을 사용한다.

### 4.3.3. Many-to-Many Model

many-to-many 모델은 많은 유저레벨 스레드를 작거나 같은 수의 커널 스레드로 연결하는 것이다. 커널 스레드는 특정 앱이나 특정 기계에 따라서 달라진다.(앱은 4개의 코어보다 8개의 코어 시스템에서 더 많은 커널 스레드를 할당할 수 있다.)

concurrency의 디자인 효과를 고려해보자. many-to-one 모델이 개발자가 많은 유저 스레드를 원하는 만큼 만들도록 허용했지만, 그것은 parallelism을 얻어내지 못했는데 왜냐하면 커널이 오직 한개의 커널 스레드를 가졌기 때문이다. one-to-one 모델은 큰 concurrency를 가져왔지만, 개발자들은 앱에서 너무 많은 커널을 만들지 않도록 조심해야한다. many-to-many 모델은 이런 결점을 겪지는 않았다. 개발자는 많은 유저 스레드를 필요한만큼 생성하고 관련있는 커널 스레드는 멀티 프로세서에서 parallel하게 돌아갔다. 또한, 스레드가 blocking 시스템 콜을 실행해도, 커널은 다른 스레드를 실행을 위해서 스케쥴했다.

한가지 many-to-many의 버라이에이션은 많은 유저 레벨 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스하지만, 유저 스레드가 커널 스레드에 바인드되게 하는 것이다. 이것은 **two-level mode**이라고 한다.

비록 many-to-many 모델이 모델중에서 가장 유연하지만, 실전에서는 구현이 어렵다. 덧붙여서, 대부분의 시스템에서 프로세싱 코어가 늘어감에 따라서, 커널 스레드를 제한하는 것은 덜 중요해졌다. 결과적으로, 대부분의 운영체제느느 one-to-one 모델을 사용한다. 그러나 우리가 4.5절에서는, 몇가지 현대 concurrency 라이브러리는 개발자가 many-to-many 모델을 사용해서 매핑된 스레드에서 태스크를 구별하는 것을 가진다.

## 4.4 스레드 라이브러리

스레드 라이브러리는 프로그래머에게 스레드 관리와 생성을 위한 API를 제공한다. 두가지 방법의 주요한 스레드 라이브러리가 존재한다. 첫번째 방법은 커널의 도움없이 유저 스페이스 전체에서 제공하는 것이다. 모든 코드와 데이터 구조는 유저 공간에 존재한다. 이것은 유저 공간에서의 로컬 함수 호출을 통해서 함수를 호출하고 시스템 콜은 이용하지 않는 것이다.

두번째 방법은 커널 레벨 라이브러리에서 제공하는 방법이다. 이런 경우에는 라이브러리의 코드와 데이터 구조는 커널 공간에 존재한다. 이런 라이브러리 API는 커널의 시스템콜을 이용한다.

현재 쓰이는 3가지 주요한 스레드 라이브러리는 포식스 Pthread, 윈도우, 자바가 있다. 3가지 라이브러리는 모두 POSIX 표준의 확장이고, 유저/커널 레벨을 지원한다. 윈도우 스레드 라이브러리는 윈도우 시스템에 있는 커널 레벨의 라이브러리이다. 자바 스레드 API는 자바 프로그램에서 직접 관리하고 생성된다. 그러나, 대부분의 JVM 인스턴스는 호스트 운영체제의 위에서 작동되므로, 자바 스레드 API는 운영체제에 있는 스레드라이브러리를 보통 이용한다. 이것은 윈도우 시스템에서, 자바 스레드는 윈도우 API를 이용한다는 것이다. 유닉스, 리눅스, macOS는 보통 Pthreads를 이용한다.

포식스와 윈도우 스레딩은 데이터가 전역으로 선언되는데, 즉, 함수의 바깥에서 선언되고 같은 프로세스내에서 모든 스레드가 공유된다는 것이다. 자바는 전역 데이터에 대한 개념이 없기 때문에 스레드사이에 공유 데이터 접근이 반드시 정렬되어야한다.

이 절의 나머지 부분에서, 우리는 3가지 스레드 라이브러리를 이용한 스레드 생성을 설명하겠다. 표현된 예시는, 우리는 양수 정수를 분리된 스레드에서 모두 더하는 것이다. 예를 들어서, 5까지의 숫자를 더하면 1~5의 숫자를 더하고 답은 15일 것이다. 각각의 3개의 프로그램은 커맨드 라인에 입력된 수까지의 합을 ㅍ현한다. 

예시를 시작하기전에, 우리는 두가지 전형적인 전략을 보이겠다. **asynchronous threading**과 **synchronous threading**이다. 비동기화 스레딩은, 한번 부모가 자식 스레드를 만들면, 부모는 그것의 실행을 재시작하고, 부모와 자식은 같이 동작하고 각자가 독립적으로 작동한다. 스레드들은 독립적이기 때문에, 그들 사이에 공유하는 데이터는 보통 적다. 비동기화 스레딩은 멀티 스레드 서버에서 쓰인다. 그리고 반응형 유저 인터페이스에서 주로 쓰인다.

동기화 스레딩은 부모 스레드가 1개 또는 그 이상의 자식을 만들면, 그들은 반드시 자식의 종료후에 시작한다. 여기서, 부모에 의해서 생성된 스레드는 동시에 작동하는데, 부모는 이 일들이 끝나기 전까지 일을 실행할 수 없다. 한번 스레드가 그들의 일을 종료하면, 그것은 종료되고 그것의 부모에 참여한다. 모든 자식이 참여한 후에야 부모는 일을 다시 시작한다. 일반적으로, 동기화 스레딩은 스레드 사이에 큰 데이터 공유를 포함한다. 예를 들어서, 부모 스레드가 다양한 자식들이 계산한 결과를 합치는 것이다. 뒤에 나오는 모든 예시는 동기화 스레딩이다.

### 4.4.1 Pthread

Pthreads는 POSIX 표준에서 정의하는 스레드 생성과 동기화를 의미한다. 이것은 스레드 행동에 특화되있지, 구현에는 아니다. 운영체제 디자이너는 그들이 원하는 되로 특화할수있다. 많은 시스템들이 Pthread specification으로 구현한다. 대부분은 유닉스 타입 시스템이다. 비록 윈도우가 Pthreads를 지원하지 않지만, 몇몇 서드파티 구현이 존재하긴한다.

예시 코드는 분리된 스레드에서 양수합을 계산하는 멀티 스레드 프로그램이다. Pthreads 프로그램에서, 분리된 스레드들은 정의된 함수를 실행한다. runner 함수가 즉 스레드이다. 프로그램이 시작되면 싱글 스레드가 메인문을 시작한다. 몇가지 초기화 후에, 메인문은 2번째 스레드인 러너 함수를 시작한다. 두가지 스레드는 전역 데이터 sum을 공유할 것이다.

프로그램을 자세히 살펴보겠다. 모든 Pthreads 프로그램은 반드시 pthread.h를 include해야 한다. pthread_t tid는 스레드의 식별자로서 선언한다. 각각의 스레드는 그것의 특성 정보를 가지고 있고, 스택사이즈와 스케쥴링 정보일 것이다. pthread_attr_t attr이 스레드의 특성을 표현한다. 우리는 함수콜 pthread_attr_init(&attr)로 특성을 세팅한다. 우리가 어떠한 특성도 explicitly 정의하지 앟ㄴ았기 때문에, 우리는 디폴트 특성을 사용한다. 분리된 스레드는 pthread_create() 함수콜로 생성된다. 추가적으로 스레드를 위해서 스레드 식별자와 특성을 전달하기 위해서, 우리는 새로운 스레드가 시작하는 곳에서 함수의 이름을 전달한다.(여기서는 runner() 함수이다.) 마지막으로 우리는 정수 파라미터 argv[1]을 전한다.

여기서, 프로그램은 두개의 스레드를 가진다. 첫번째(부모) 스레드는 메인에 있고 합하는 스레드 runner() 스레드이다. 프로그램은 스레드 create/join 전략을 따르고, 합하는 스레드 생성후에 부모 스레드는 pthread_join() 함수가 끝날때까지 대기한다. 합하는 스레드가 종료하면 우리는 pthread_exit()를 부른다. 한번 합하는 스레드가 리턴되면 부모 스레드는 sum을 아웃풋으로 출력한다.

이 예제는 오직 한개의 스레드를 만들었다. 증가하는 멀티코어 시스템에 따라서, 프로그램은 여러가지 스레드를 사용하는 것이 일반적으로 되고있다. 루프문을 통해서 여러개의 스레드를 만드는 것고 가능하다.

### 4.4.2 윈도우 스레드

윈도우 스레드 라이브러리로 스레드를 만드는 방식은 Pthread와 비슷하다. 우리는 반드시 윈도우 API 이용을 위해서 windows.h 헤더를 추가해야는 것을 생각하자.

Phtread와 비슷하게 데이터는 전역으로 선언된 스레드를 통해서 공유된다.(DWORD 데이터는 32비트 정수이다.) 우리는 Summation() 함수를 분리된 스레드로 작동한다. 이 함수는 보이트 포인터를 넘겨주고, LPVOID로 정의된다. 스레드는 0부터 전해진 파라미터로 합을 실행한다.

스레드는 윈도우 API에서 생성되었고 CreateThread() 함수를 이요한다. 그리고 이 함수에서 스레드로 특성을 보낸다. 이런 특성은 보안 정보, 스택 사이즈, 스레드가 정지된 상태에서 시작했는지 확인하는 플래그이다. 한번 서메이션 스레드가 생성되면 부모는 Sum의 결과가 나오기까지 기다린다. Pthread 프로그램처럼 pthread_join()을 이용해서 부모 스레드가 기다렸다. 우리는 윈도우 API에서 비슷하게 WaitForSingleObject() 함수를 사용한다. 이것은 스레드가 서메이션 스레드가 끝날때까지 기다리게한다.

다양한 스레드가 종료되길 기다리는 상황에서, WaitForMultipleObjects() 함수는 사용된다. 함수는 4가지 파라미터를 전달한다.

1. 기다리는 오브젝트 수
2. 오브젝트의 포인터 행렬
3. 모든 오브젝트가 신호보냈는지 확인하는 플래그
4. 타임아웃 시간(무한도 가능)

예를 들어서, THandles는 스레드 Handle 오브젝트의 사이즈 N이다. 부모 스레드는 자식이 끝날때까지 기다리는 것을 다음과 같이 정의 가능하다.

`WaitForMultipleObjects(N, THandles, TRUE, INFINITE);`

### 4.4.3 JAVA 스레드

스레드들은 자바프로그램에서 프로그램 실행의 기초 모델이다. 자바와 그것의 API는 스레드의 관리와 생성에 대해서 풍부한 기능을 제공한다. 모든 자바 프로그램들은 스레드 하나하나의 통제로 이루어져있고 심지어 JVM에서의 메인도 하나의 스레드이다. 자바 스레드들은 윈도우, 리눅스 macOS를 포함하는 JVM에서 어떤 시스템에서도 실행된다. 자바 스레드 API는 안드로이드 앱에서도 가능하다.

자바 프로그램에서 스레드를 만드는 두가지 기술이 있다. 한가지는 Thread 클래스로부터 새로운 클래스를 만들고 그것의 run() 메서드를 오버라이드하는 것이다. 다른 방법은 Runnable 인터페이스를 정의하는 것이다. 이 인터페이스는 한가지 추상 메서드를 public void run()으로 정의하는 것이다. run() 메서드의 코드는 Runnalble을 구현했고 분리된 스레드로 작동한다. 예시는 다음과 같다.

```java
class Task implements Runnable
{
    public void run() {
        System.out.println("I am a thread.");
    }
}
```

자바에서의 스레드 생성은 스레드 오브젝트 만드는 것과 그것을 Runnable을 구현하는 클래스의 인스턴스에게 넘기는 것을 포함하는데, start() 메소드를 실행하는 것부터 시작한다. 다음과 같다.
```java
Thread worker = new Thread(new Task());
worker.start();
```

새로운 스레드 오브젝트를 위해서 start() 메소드 호출은 2가지 일을 한다.

1. 그것은 JVM에 새로운 스레드를 초기화하고 메모리를 할당한다.
2. run() 메서드를 호출하고, JVM에 의해서 돌아가는 스레드를 만든다.(우리는 run() 메서드를 직접 부르지 않는다. 대신에, 우리는 start() 메서드를 부르고 그것이 run() 메서드를 실행한다.)

Pthreads와 윈도우 라이브러에서의 부모 스레드는 pthread_join()과 waitForSingleObject()를 스레드가 서메이션을 끝날때까지 기다리게한다. join() 메서드가 자바에서는 비슷하게 제공된다.(join(0)은 InterruptedException을 throw하고 우리는 무시하도록 선택가능하다.)

```java
try {
    worker.join();
}
catch(InterruptedExcption ie) { }
```

만약 부모가 반드시 스레드의 종료까지 기다려야하면 우리는 for 루프를 비슷하게 이용할 수 있다.

### 4.4.3 자바 Excutor Framework

자바는 스레드를 우리가 앞서 말한것으로 구현가능했다. 그러나 1.5버전과 API가 소개되면서 새로운 방법이 우리에게 주어졌다. 이러한 툴은 java.util.concurrent 패키지에 존재한다.

스레드 오브젝트를 만드는 것보다는, 스레드 생성은 대신에 Executor 인터페이스를 만든다.

```java
public interface Excutor
{
    void execute(Runnable command);
}
```

이 인터페이스를 구현하는 클래스는 반드시 execute(0)를 정의하고 Runnable 오브젝트에 의해서 건내져야한다. 자바 개발자에게, 이것은 Executor을 사용하는 것보다는 분리된 스레드를 만드는 것이고 start() 메서드를 호출한다. Executor은 다음과 같다.

```java
Executor service = new Executor;
service.execute(new Task());
```
Executor 프레임워크는 생산자-소비자 모델을 기초로 한다. Runnable 인터페이스를 구현한 태스크는 생산되고 이런 태스크를 소비하는 스레드를 가진다. 이 접근의 장점은 스레드 생성을 실행과 나눌뿐만이 아니라 현재 실행중인 태스크간의 통신 메커니즘을 제공한다.

스레드간의 데이터 공유는 윈도우와 Pthreads 사이에서 쉽게 가지는데, 공유 데이터가 전역으로 선언되기 때문이다. 순수한 OOL에서는, 자바는 전역이라는 정의가 없다. 우리는 Runnable을 통해서 파라미터를 전할수 있다. 그러나 자바 스레드는 결과를 리턴할 수 없다. 이런 필요를 충족하기 위해서 java.util.concurrent 패키지는 Callable 인터페이스를 추가로 정의해서 Runnable이 결과를 리턴하는 것을 돕는다. 예시코드는 이 기능을 이용한다.

서메이션 클래스는 Callable 인터페이스를 구현한다. 그것은 call() 메서드이고 여기서 분리된 스레드에서 실행되는 call() 메서드이다. 이 코드를 실행할려면, 우리는 newSingleThreadExecutor 오브젝트를 만들고, ExecutorService의 종류이고 submit 메서드를 사용하는 callable 메서드이다.(execute와 submit의 큰 차이는 결과를 리턴하지않는다와 한다이다.) 한번 우리가 callable 태스크를 스레드에 제출하면, 우리는 그것의 get() 메서드를 불러서 Future 오브젝트가 리턴되는 것을 기다린다.

단순하게 스레드를 만들고 그것의 종료를 조인하는 것보다 어려워 보일수도 있다. 그러나 이 방법을 하는 것은 문제의 단계에 이득을 준다. 우리가 보았듯이, Callable과 Future은 스레드가 결과를 리턴하는 것을 허용한다.

추가적으로, 이런 접근은 그들이 만드는 결과와 스레드의 생성을 분할한다. 결과가 나오기까지 스레드를 기다리는 것보다는, 부모가 대신에 결과물이 생길떄까지 기다리는 것이다. 마지막으로, 4.5.1절에서, 이 프레임워크는 많은 수의 스레드 관리를 위한 단단한 기능을 제공한다.

## 4.5 Implicit Threading
