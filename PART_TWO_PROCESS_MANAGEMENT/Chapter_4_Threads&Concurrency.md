# what we gonna study

챕터3에서 프로세스 모델은 한개의 스레드가 작동하는 프로그램이다. 가상적으로 모든 운영체제 시스템에서는 프로세스가 다중의 스레드를 작동하는 기능을 제공한다. 스레드의 사용을 통한 병렬처리 식별은 멀티 CPU를 제공하는 멀티코어 시스템에서 점점 중요해지고 있다. 

이 장에서는, 우리는 많은 개념을 소개하는데, Pthreads, Windows, Java Thread API의 토론을 멀티스레드 컴퓨터 시스템과 연관지어서 공부한다. 덧붙여서, 우리는 스레드 생성 추상화, 병렬처리를 지원하는 개발자 허용, 언어 기능과 API 프레임워크을 실행, 스레드 관리의 명세를 보이겠다. 우리는 멀티스레드 프로그래밍과 관련된 이슈와 그것이 운영체제에 미치는 영향을 공부한다. 마지막으로, 우리는 윈도우와 리눅스 운영체제가 커널레벨에서 지원하는 스레드 기능을 보겠다.

# Chapter Objectives

- 스레드의 기본 구성요소를 보고, 스레드와 프로세스의 차이를 알아본다.
- 멀티스레드 프로세스를 디자인하고 주요한 장점을 보겠다.
- 내재적인 스레드 풀, 포크-조인, Grand Central Disaptch을 포함한 내재적인 스레딩 접근을 설명하겠다.
- 윈도우와 리눅스 운영체제를 대표하는 스레드를 구현한다.
- Pthreads, Java, 윈도우 스레딩 API를 사용하는 멀티스레드를 디자인한다.

## 4.1 Overview

스레드는 CPU 효율성의 기초 단위이다. 그것은 스레드 ID, PC, 레지스터 셋과 스택으로 구성되어있다. 그것은 다른 스레드와 코드, 데이터, 운영체제 리소스(파일, 신호)를 공유한다. 전통적인 프로세스는 싱글 스레드 컨트롤이었다. 만약 프로세스가 다중 스레드라면, 그것은 같은 시간동안 한개보다 많은 일을 할 수 있다.

### 4.1.1 동기

대부분의 소프트웨어 앱들은 멀티스레드이다. 앱들은 여러개의 스레드를 가진 분리된 프로세스로 구현된다. 우리는 몇개의 멀티스레드 앱을 보겠다.

- 이미지 컬렉션으로부터 각각의 이미지로 섬네일을 만드는 것은 분리된 스레드를 사용할 수도 있다.

- 웹 브라우저는 이미지나 텍스트를 띄우는 다른 스레드는 동안 네트워크로부터 데이터를 순회하고 있다.

- 워드 프로세스는 그래픽을 띄우면서, 다른 스레드는 유저로부터 키입력을 반응하고, 3번째 스레드는 스펠링과 문법체크를 백그라운드에서 수행한다.

앱들은 멀티시스템에서 'leverage(영향력) processing capablilities'로 디자인된다. 이런 앱들은 멀티 컴퓨팅 코어에서 CPU 집중 태스크를 실행할 수 있다.

어떤 상황에서는, 단일 앱은 비슷한 태스크를 실행하는 것을 필요로 할 수 있다. 예를 들어서, 웹 서버는 웹페이지, 이미지, 사운드 등을 클라이언트 요청으로 수락할 수 있다. 바쁜 웹 서버는 병렬적으로 접근하는 클라이언트를 가질 수 있다. 만약 웹서버가 단일 스레드에서 작동하면, 그것은 오직 한명의 클라이언트만 가능할 것이고, 클라이언트는 서비스가 실행되도록 긴 시간을 기다려야 한다.

한가지 해결책은 한개의 프로세스로만 요청을 받아들이는 서버를 가지는 것이다. 서버가 요청을 받아들이면, 그것은 요청을 서비스하도록 분리된 프로세스를 생성한다. 실제로, 이런 프로세스 생성 메소드는 스레드가 유명해지기 전에 일반적인 방법이었다. 프로세스 생성은 시간을 많이 소요하고 리소스를 많이 먹는다. 만약 새로운 프로세스가 존재하는 프로세스와 같은 일을 하면 뭐하러 간접비를 또 지불하는가?? 한개의 프로세스가 다중 스레드를 가지는 것이 훨씬 효율적이다. 만약 웹-서버 플세스가 멀티 스레드이면, 서버는 클라이언트 요청을 들을 분리된 스레드를 만들면 된다. 요청이 만들어지면, 프로세스를 새로 만드는 것보다는, 서버가 새로운 스레드를 만들어서 요청을 처리하고 추가 요청을 듣는 것을 재시작한다.

대부분의 운영체제 커널들은 보통 멀티스레드이다. 예를 들어서, 리눅스의 시스템 부트동안에, 몇몇 커널 스레드는 생성된다. 각각의 스레드는 특정한 업무(디바이스 관리, 메모리 관리, 인터럽트 관리)를 실행한다. 커맨드 ps -ef는 리눅스에서 실행중인 커널스레드를 보인다. 이 커밴드의 결과물은 모든 커널 스레드의 부모를 제공하는 커널 스레드 *ktreadd*를 보여준다. 

많은 앱들은 다중 스레드의 장점을 가지는데, 소팅, 트리, 그래프 알고리즘이 포함되어있다. 덧붙여서, 데이터 마이닝, 그래픽스, AI 같은 현대의 CPU 집중 문제들을 해결해야하는 프로그래머들은 병렬적으로 수행하도록 멀티코어 시스템을 디자인 함으로서 기능을 올릴 수 있다.

### 4.1.2 장점

멀티 스레드 프로그래밍의 장점은 4가지로 나뉜다.

1. Responsiveness(반응성) : 상호작용하는 앱들을 멀티스레딩하는 것은 프로그램이 일부분이 막히거나, 긴 명령어를 실행해서 유저의 responsiveness를 증가시킬때에도 계속 실행하도록 허용한다. 퀄리티는 유저 인터페이스를 디자인할 때 특히 유용해진다. 예를 들어서, 유저가 시간을 많이 잡아먹는 명령어 실행 버튼을 클릭할때를 고려해보자. 싱클 스레드 앱들은 명령어가 완료될떄까지 반응을 하지 않을 것이다. 반면에, 만약 시간을 잡아먹는 명령어가 분리된, 비동기화된 스레드에서 작동하면, 앱은 유저에게 반응성을 유지한다.

2. Resource sharing : 프로세스는 공유 메모리와 메시지 패싱을 통해서 리소르를 공유한다. 그런 기술들은 프로그래머에 의해서 확실히 생성되어야한다. 그러나, 스레드들은 메모리를 공유하고 그들이 가진 프로세스의 리소스를 디폴트로 가진다. 코드와 데이터를 공유하는 장점은 앱들이 같은 주소영역안에서 활동의 여러가지 다른 스레드를 가지도록한다.

3. Economy : 프로세스 생성을 위한 메모리와 리소스 할당은 비용이 크다. 스레드들이 그들이 속한 리소스를 공유하기에, 스레드를 만들고 컨텍스트-스위치하는 것은 훨씬 경제적이다. 경험적으로 간접비를 검량하는 것은 힘들지만, 일반적으로 스레드 생성은 프로세스 생성보다 시간과 메모리를 덜 차지한다. 추가적으로, 컨텍스트 스위칭은 프로세스간보다는 스레드에서 훨씬 빠르다.

4. Scalability(확장성) : 멀티 스레딩의 장점은 스레드가 다른 프로세싱 코어에서 병렬적으로 작동하는 멀티 프로세서 아키텍처보다 훨씬 클수도 있다. 싱글 스레드 프로세스는 여러개가 있어도 오직 한개의 프로세서에서 작동한다. 우리는 다음 절에서 이것을 보겠다.

## 4.2 Multicore Programming

컴퓨터 디자인의 초기 역사에서, 더 좋은 컴퓨팅 성능을 위해서, 싱글 CPU 시스템은 멀티 CPU 시스템으로 진화했다. 후에, 시스템 디자인의 트렌드는 여러개의 코어를 가진 단독 칩으로 멀티 컴퓨팅 코어를 가지도록 되었다. 우리는 이런 시스템을 **multicore**라고 했고, 멀티 스레드 프로그래밍은 멀티 프로그래밍 컴퓨팅 코어와 향상된 병렬성을 더욱 효율적인 메커니즘에서 제공하도록 했다. 4개의 스레드를 가진 앱을 생각해보겠다. 단독 컴퓨팅 코어를 가진 시스템에서, 컨커런시는 스레드의 실행을 끼우는 것을 의미할 수도 있는데, 왜냐하면 프로세싱 코어는 오직 하나의 스레드를 한번에 작동하기에 적합하다. 멀티 코어 시스템을 가진 시스템에서는, 컨커런시는 여러개의 스레드가 병렬적으로 처리되는 것을 의미하는데, 왜냐하면 시스템은 각각의 코어에서 분산된 스레드이기 때문이다.

*concurrency*와 *parallelism*은 여거시 확실한 차이를 배우겠다. concurrent 시스템은 모든 태스크를 단계적으로 실행함으로서 한개보다 많은 태스크를 지원한다. 반대로, 병렬 시스템은 동시에 한개보다 많은 일을 실행하게 한다. 그러므로, parallelsm 없는 concurrency는 존재한다. 멀티 프로세서와 멀티코어 아키텍처의 급발전 전에는, 대부분의 컴퓨터는 오직 싱글 프로세서만 가졌기에, CPU 스케쥴러는 고속으로 프로세스간에 스위칭함으로서 parallelism의 환상을 제공했고, 각 프로세스가 단계적으로 실행하게 만들었다. 이런 프로세스들은 Concurrently이지 parallel은 아니다.

### 4.2.1 프로그래밍 챌린지

멀티코어 시스템의 트렌드는 시스템 디자이너와 앱 프로그래머들이 더욱 나은 멀티 컴퓨팅 코어를 더 좋게 사용하게끔 압박을 주었다. 운영체제의 디자이너들은 멀티 프로세싱 코어가 parallel 실행을 하게끔 스케쥴링 알고리즘을 썼다. 앱 프로그래머들은, 현존하는 프로그램을 새로운 프로그램이 멀티스레드하게 수정하는 챌린지를 받았다.

일반적으로 멀티코어 시스템에는 5가지 챌린지가 존재한다.

1. Identifying tasks : 이것은 분리된, concurrent한 태스크를 나누는 영역을 앱을 통해서 찾는 것이다. 이상적으로는, 태스크들은 다른 것과 독립적이므로 각각의 코어들은 병렬적으로 개인 코어를 가진다.

2. balance : 병렬적으로 실행할 태스크를 구분하는 동안, 프로그래머들은 같은 가치의 같은 일을 태스크가 수행하는 것을 확신해야한다. 몇가지 예시로, 어떤 일은 다른 태스크보다 전체의 프로세스에 큰 결과를 공헌하지 않을 수 있다. 분리된 코어 실행을 사용하는 태스크는 사실 코스트의 가치를 없는 것이다. 

3. Data splitting : 분리된 태스크로 앱들이 구별되있는 것처럼, 데이터 접근과 조작은 반드시 분리된 코어에서 쪼개져야한다.

4. Data dependency : 태스크에 데이터 접근은 두개 또는 더 많은 태스크는 반드시 의존성을 가져야한다. 하나의 태스크가 다른 데이터로 의존하면, 프로그래머들은 반드시 데이터 의존성을 가지는 동기화 태스크 실해을 해야만 한다. 이 전략은 6장에서 공부한다.

5. Testing and debugging : 프로그램이 병렬 코어에서 실행될때에, 많은 실행 경로가 가능하다. 이런 concurrent 프로그램의 테스팅과 디버깅은 싱글 스레드 앱보다 훨씬 힘들다.

이런 챌린지 때문에, 많은 소프트웨어 개발자들은 멀티코어 시스템의 급발전이 소프트웨어 미래에 새로운 접근을 만들어냈다고 주장한다.(비슷하게 많은 컴퓨터 공학 교육자들은 병렬 프로그래밍의 강조를 많이 해야하다고 한다.)

### 4.2.2 병렬의 종류

보통, 두가지의 병렬이 있다. 데이터 병렬과 태스크 병렬이다. **Data parallelism**은 다중 컴퓨팅 코어사이의 같은 데이터 분산과 각 코어의 같은 명령어 수행에 집중한다. 예를 들어서, N 사이즈의 행렬을 더하는 것을 생각하겠다. 한개의 스레드는 0~N-1까지를 간단하게 더하는 것이다. 그러나 듀얼 코어 시스템에서는 A가 0~N/2, B가 N/2+1~N-1까지를 더한다. 두개의 스레드는 분리된 컴퓨팅 코어에서 병렬적으로 수행된다.

태스크 병렬은 데이터 분산이 아니라 멀티 컴퓨팅 코어에서의 태스크 분산이다. 각 스레드는 고유한 명령어를 실행한다. 다른 스레드들은 같은 데이터에서 작동하거나, 그들은 다른 데이터에서 실행된다. 위의 예시를 다시하겠다. 그 상황과 다르게, 태스크 병렬은 두개의 예시는 각각은 행렬의 원소에 특별한 통계적인 명령어를 실행한다. 스레드는 분리된 코어에서 병렬적인 명령을하지만, 각각은 특별한 명령을 실행한다.

기초적으로, 데이터 병렬은 멀티 코어의 분산된 데이터를 포함하고, 태스크 병렬은 멀티 코어의 분산된 태스크를 포함한다. 그러나, 데이터와 태스크 병렬은 상호적으로 배제하지 않고, 앱들은 두 전략의 하이브리드를 가진다.

## 4.3 멀티스레딩 모델

우리의 논의는 일반적인 사오항의 스레드 관리이다. 그러나, 스레드 지원은 유저레벨에서 제공되고, 유저 스레드, 커널 스레드가 있다. 유저 스레드는 커널 위에서 지원하고 커널의 지원없이 관리된다. 반면에 커널 스레드는 운영체제에 의해서 직접 지원/관리된다. 가상적으로 모든 현대 운영체제는 커널 스레드를 지원한다.

최종적으로, 유저스레드와 커널스레드는 관계를 가진다. 이 절에서는, 우리는 이런 관계를 확립하는 3가지 방법을 보겠다. many-to-one model, one-to-one model, many-to-many model이다.

### 4.3.1 Many-to-One Model

이 모델은 많은 유저레벨 스레드를 하나의 커널 스레드에 맵핑한다. 스레드 관리는 유저 공간의 스레드 라이브러리에서 실행되는데, 효율적이다.(스레드 라이브러리는 4.4에서 알아본다.) 그러나, 전체 프로세스는 만약 스레드가 블럭킹 시스템 콜을 만들면 블락한다. 또한, 오직 한개의 스레드가 동시에 커널에 접근하기에, 다중 스레드들은 멀티코어 시스템에서 병렬적으로 수행불가능하다. **Green threads**는 솔라리스 시스템에 적용되고 자바의 초기 버전에 채택되어서, many-to-one 모델을 사용한다. 그러나 소수의 시스템이 이제는 대부분의 컴퓨터 시스템에서 사용되는 멀티 프로세싱 코어 장점을 못받아드려도 사용중이다.

### 4.3.2 One-to-One Model

이 모델은 각각의 유저 스레드를 커널 스레드에 연결한다. 그것은 다른 스레드가 스레드가 블럭킹 시스템콜을 만들때도 실행함으로서 many-to-one 모델보다 concurrency를 제공한다. 그것은 또한 멀티 프로세서에서 멀티 스레드가 작동하도록 허용한다. 이 모델의 유일한 단점은 유저 스레드를 만드는 것은 커널 스레드를 만드는 것을 필요로하고 많은 커널 스레드는 시스템에 큰 부담을 주게된다. 리눅스, 윈도우는 One-to-One 모델을 사용한다.

### 4.3.3. Many-to-Many Model

many-to-many 모델은 많은 유저레벨 스레드를 작거나 같은 수의 커널 스레드로 연결하는 것이다. 커널 스레드는 특정 앱이나 특정 기계에 따라서 달라진다.(앱은 4개의 코어보다 8개의 코어 시스템에서 더 많은 커널 스레드를 할당할 수 있다.)

concurrency의 디자인 효과를 고려해보자. many-to-one 모델이 개발자가 많은 유저 스레드를 원하는 만큼 만들도록 허용했지만, 그것은 parallelism을 얻어내지 못했는데 왜냐하면 커널이 오직 한개의 커널 스레드를 가졌기 때문이다. one-to-one 모델은 큰 concurrency를 가져왔지만, 개발자들은 앱에서 너무 많은 커널을 만들지 않도록 조심해야한다. many-to-many 모델은 이런 결점을 겪지는 않았다. 개발자는 많은 유저 스레드를 필요한만큼 생성하고 관련있는 커널 스레드는 멀티 프로세서에서 parallel하게 돌아갔다. 또한, 스레드가 blocking 시스템 콜을 실행해도, 커널은 다른 스레드를 실행을 위해서 스케쥴했다.

한가지 many-to-many의 버라이에이션은 많은 유저 레벨 스레드를 적거나 같은 수의 커널 스레드로 멀티플렉스하지만, 유저 스레드가 커널 스레드에 바인드되게 하는 것이다. 이것은 **two-level mode**이라고 한다.

비록 many-to-many 모델이 모델중에서 가장 유연하지만, 실전에서는 구현이 어렵다. 덧붙여서, 대부분의 시스템에서 프로세싱 코어가 늘어감에 따라서, 커널 스레드를 제한하는 것은 덜 중요해졌다. 결과적으로, 대부분의 운영체제느느 one-to-one 모델을 사용한다. 그러나 우리가 4.5절에서는, 몇가지 현대 concurrency 라이브러리는 개발자가 many-to-many 모델을 사용해서 매핑된 스레드에서 태스크를 구별하는 것을 가진다.

## 4.4 스레드 라이브러리