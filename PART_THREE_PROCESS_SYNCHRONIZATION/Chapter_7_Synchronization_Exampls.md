## what we gonna study

6장에서, 우리는 임계영역 문제를 보이고 다양한 동시 프로세스가 데이터를 공유할 때 생기는 레이스 컨디션에 집중했다. 우리는 레이스 컨디션이 생기는 것을 방지해서 임계영역을 조절하는 몇가지 툴을 배웠다. 이러한 툴들은 로우레벨 하드웨어 해결책(메모리 배리어, CAS 명령어)와 하이레벨 툴(뮤텍스락, 세마포어, 모니터)를 배웠다. 우리는 또한 데드락 같은 실시간 위험을 포함하는 레이스 컨디션을 자유롭게하는 여러가지 앱디자인 고려 사항을 보었다. 이번 장에서, 우리는 몇가지 클래식 동기화 툴을 보겠다. 우리는 또한 리눅스, 유닉스, 윈도우 운영체제 에서 사용하는 동기화 메커니즘을 보고, 우리는 자바와 포식스 시스템의 API 디테일을 보겠다.

## Objectives

- 바운디드 버퍼, 리더-라이터, 다이닝-필로소퍼 동기화문제를 보겠다. 
- 리눅스와 윈도우의 프로세스 동기화 툴을 보겠다.
- POSIX와 자바가 동기화 문제 해결에 사용되는 법을 보겠다.
- POSIX와 자바 API를 통해서 동기화 문제를 해결하겠다.

## 7.1 Classic Problems of Synchronization

이 절에서는, 우리는 동기화 컨트롤 문제에 관한 예시를 보겠다. 이러한 문제들은 최근에 제안된 동기화 구조를 테스트하기 위해서 쓰인다. 이 문제를 해결하기 위한 해결책은, 우리는 동기화를 위한 세마포어를 사용하겠다. 세마포가 이런 문제를 해결하는 전통적인 방법이다. 그러나, 이 실제의 구현은 바이너리 세마포어를 대신해서 뮤텍스 락을 쓸 수도 있다.

### 7.1.1 바운디드 버퍼 문제

*bounded-buffer problem*은 6.1절에서 소개되었다. 그것은 보통 동기화의 조상의 위력을 설명하기 위해서 사용된다. 이 문제의 예시를 장의 끝에서 보이겠다. 

우리의 문제에서, 생산자-소비자 프로세스는 다음의 데이터 구조를 공유했다.
```cpp
int n;
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
```
우리는 풀이 총 n의 버퍼를 포함하고, 각각은 한가지 아이템을 쥐고 있을 수 있다. *mutex* 바이너리 세마포어는 버퍼 풀로의 접근을 위한 상호배제를 제공하고 1로 초기화 되어있다. empty와 full 세마포어는 빈공간과 가득찬 공간의 버퍼 크기를 샌다. 

생산자와 소비자의 코드는 아래와 같고 둘은 대칭적인 구조를 가진다.
```cpp
while(ture){
    . . .
    /* produce an item in next_produced */
    . . .
    wait(empty);
    wait(mutex);
    . . .
    /* add next_produced to the buffer */
    . . .
    signal(mutex);
    signal(full);
}
```

```cpp
while(ture){
    wait(full);
    wait(mutex);
    . . .
    /* remove an item in next_consumed */
    . . .
    signal(mutex);
    signal(empty);
    . . .
    /* consume the item in next_consumed */
    . . .
}
```

### 7.1.2 리더-라이터 문제

데이터 베이스가 몇가지 동시 프로세스에 의해서 소비된다고 가정하자. 이 프로세스 중 몇가지는 오직 데이터베이스에서 읽기만을 원할수도 있지만, 다른 것들은 데이터 베이스에 업데이트를 원할수도 있다. 우리는 이 두가지 타입의 프로세스를 전자는 리더 후자는 라이터라고 하겠다. 명백하게, 만약 두가지 리더가 공유 데이터에 동시에 접근하면, 역효과는 딱히 일어나지 않는다. 그러나, 만약에 라이터와 다른 프로세스(리더, 라이터 둘다)가 데이터 베이스가 같이 접근하면 혼돈이 일어난다.

이런 어려움이 일어나지 않게 보장하려면, 우리는 라이터가 데이터 베이스에 쓰는 동안 독점적인 권한을 갖도록 해야한다. 이 동기화 문제를 일컬어 **reader-writers problem**이라고 한다.

리더-라이터 문제는 몇가지 베리에이션이 있는데, 모든 것이 우선도를 포함한다. 가장 간단한것은, *first* readers-writers problem이라 하고, 라이터가 공유 데이터에 이미 허가를 받지 않은한 리더가 기다리지 않는 것이다. 다른 말로는, 리더는 리더가 끝나기를 기다리지 않는다. 왜냐하면 라이터가 대기중이기 때문이다. *second* readers-writers 문제는 라이터가 ready하면, 라이터는 최대한 빨리 실행한다. 다른 말로는, 만약 writer가 오브젝트에 접근을 기다리면, 리더는 더이상 새로 읽지 않는다.

두가지 문제에 대한 해결법은 기아를 발생할 수 있다. 첫번째 경우에는, writer가 굶는다. 두번째 경우에는 reader가 굶는다. 이런 이유로, 문제의 다양한 해결법이 제안되었다. 다음으로, first에 대한 해결책을 보이겠다. 두번째 문제를 해결하기 위한 **Bibliographical** note를 참고하면 좋을 것이다.

첫번째 리더-라이터 문제의 해결책에서, 리더 프로세스는 다음의 데이터 구조를 공유한다.

```cpp
semaphore rw_mutex = 1;
semaphore mutex = 1;
int read_count = 0;
```

바이너리 세마포 뮤텍스와 rw_mutex는 1로 초기화가 된다.  read_count는 0으로 초기화된 counting semaphore이다. 세마포어 rw_mutex는 reader와 writer 프로세스에 둘다 쓰인다. mutex 세마포어는 read_count가 업데이트 될때 상호배제가 확실하도록 사용된다. read_count는 현재 읽고있는 오브젝트의 수를 유지해준다. 세마포어 rw_mutex는 라이터를 위해서 상호배제를한다. 그것은 또한 임계영역을 들어가거나 나가는 첫번째 또는 마지막 리더도 쓴다. 그것은 다른 리더가 임계영역에 있을때는 사용되지 않는다.

코드는 다음과 같다.

```cpp
while(true){
    wait(rw_mutex);
    . . .
    /* writing is performed */
    . . .
    signal(rw_mutex);
}
```

```cpp
while(true){
    wait(mutex);
    read_count++;
    if(read_count == 1) wait(rw_mutex);
    signal(mutex);
    . . .
    /* reading is performed */
    wait(mutex);
    read_count--;
    if(read_conut == 0) signal(rw_mutex);
    signal(mutex);
}
```
만약 라이터가 임계영역에 있고 n 리더가 기다리고 있으면, 한명의 리더가 rw_mutex에 큐되고, n-1리더가 mutex에 큐된다. 라이터가 signal(rw_mutex)하면, 우리는 대기하는 리더 또는 대기하는 라이터중를 실행한다. 이 선택은 스케쥴러가 담당한다. 
리더-라이터 문제와 그것의 해결책은 시스템에서 락을 제공함으로서 일반화되었다. 리더-라이터 락은 락의 모드를 구별하는 것이 필요하다.(read or write access). 프로세스가 공유데이터를 읽기를 원할때, 그것은 리드모드로 리더-라이터 락을 요청한다. 공유 메모리 수정을 요청하는 프로세스는 반드시 라이터 모드로 락을 요청해야한다. 다양한 프로세스들은 리드 모드에서 리더 라이터 락을 얻는 것을 허가 받는다. 그러나 오직 하나의 프로세스만 writing을 위해서 락을 획득한다.

리더 라이터 락들은 다음상황에서 유용하다.
- 한가지 작업만 하는 프로세스를 구별하기 쉬운 앱
- 라이터보다 리더를 더 가진 앱. 리더-라이터 락은 보통 세마포어 또는 뮤텍스 락보다 더 큰 비용을 요구한다. 많은 리더를 가지는 것은 이것에 대한 대리비를 보상해준다.

### 7.1.3 식사하는 철학자 문제

5명의 철학자가 생각하고 먹기만 한다. 그 철학자들은 5개의 의자로 둘러쌓인 둥근 책상을 공유한다. 책상의 중심에는 쌀이 있고, 테이블에는 5개의 젓가락이 있다. 철학자가 생각할떄, 그녀는 다른 동료와 상호작용하지 않는다. 시간이 지나면, 철학자는 배고파지고, 근처의 젓가락을 든다. 철학자는 한번에 젓가락을 한짝만 들수 있고, 다른 사람의 손에 있는건 얻을 수 없다. 배고픈 철학자가 두손에 젓가락이 있으면, 먹고 다시 내려두고 생각한다.

철학자의 구조는 다음과 같다.
```cpp
while(true){
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    . . .
    /* eat for a while */
    . . .
    signal(chopstick[i]);
    signal(chopstick[(i+1) % 5]);
    . . .
    /* Think for a while */
    . . .
}
```
이 문제는 고전 동기화문제에서 동시성 컨트롤 문제로 분류된다. 이 문제는 데드락에서 자유롭고 기아에서 자유롭도록 프로세스에 리소스를 할당하는 필요의 기초적인 예제이다.

#### 7.1.3.1 세마포 문제

한가지 간단한 문제 해결법은 각 젓가락에 세마포어를 주는 것이다. 철학가는 젓가락은 wait()함으로서 획득한다. 그리고 signal()로 놓아준다. 그러므로 공유 데이터는 값이 1로 초기화되는 `semaphore chopstick[5];`이다.  비록 이 해결법이 두가지 이웃이 동시에 먹지 않는 것을 보장하지 않지만, 그것은 그럼에도 불구하고 그것이 데드락을 만들어서 거절해야한다. 모든 철학자가 배고파지고 모두 왼쪽 젓가락을 잡는 것을 상상해보아라. 모든 젓가락은 0으로 변한다. 각각의 철학자가 그녀의 오른쪽 젓가락을 쥐면, 그녀는 영원히 딜레이 된다.

이런 데드락 상황을 경감시키는 방법이 있다.
- 4명의 철학자가 동시에 책상에 앉게끔한다.
- 철학자가 오직 두개의 젓가락이 있을때만 집는다.(그녀는 반드시 임계영역에서 잡아야한다.)
- 비대칭 방법- 홀수는 왼쪽, 오른쪽 순으로 잡고, 짝수 철학자는 오른쪽, 왼쪽 순으로 잡는다.
  
6.7절에서, 우리는 식사하는 철학자 문제를 해결하기 위한 해결법을 보았다., 그러나 철학자가 굶어 죽는 상황을 아직 해결하지 못했다. 데드락-프리 솔루션은 기아의 문제를 해결하지는 못한다. 

#### 7.1.3.2 모니터 해결법

```cpp
monitor DiningPhilosophers
{
    enum {THINKING, HUNGRY, EATING} state[5];
    condition self[5];

    void pickup(int i){
        state[i] = HUNGRY;
        test(i);
        if(state[i] != EATING) self[i].wait();
    }

    void putdown(int i){
        state[i] =THINKING;
        test((i+4)%5);
        test((i+1)%5);
    }

    void test(int i){
        if((state[(i+4)%5] != EATING) && (state[i] == HUNGRY) && (state[(i+1)%5] != EATING) ){
            state[i] = EATING;
            self[i].signal();
        }
    }

    initialization_code(){
        for(int i=0; i<5; i++){
            state[i] = THINKING
        }
    }
}

다음으로는, 데드락 문제를 해결하는 모니터 방법을 보겠다. 이 해결법은 철학자가 오직 두개의 젓가락이 있을때만, 젓가락을 획득한다는 제한을 내포한다. 이 해결을 코드화하려면, 우리는 철학자가 가질 3가지 상황을 가정해야한다. 이 목적을 위해서 다음과 같은 데이터 구조가 따라온다.

`enum {THINKING, HUNGRY, EATING} state[5];`

철학자 i의 state[i] = EATING은 오직 그녀의 두 옆사람이 먹지않을때만 가능하다. (state[(i+4)%5] != EATING) and (state[(i+1)%5] != EATING)일 때이다.

우리는 또한 `condition self[5];`를 선언한다. 이것은 i가 그녀가 배고파진 시점으로부터 젓가락을 못 얻었을때 지연시켜준다.

우리는 이제 식사하는 철학자 문제를 해결법을 말했다. monitor DiningPhilosophers에 의해서 조작된다. 각 철학자는 먹기 이전에, pickup()을 실행한다. 이 행동은 철학자 프로세스의 정지를 일으킬수 있다. 명령어의 성공적인 완료후에, 철학자는 먹는다. 이것에 따르면, 철학자는 putdown()도 실행한다. 그러므로, 철학자 i는 반드시 pickup()과 putdown()을 다음의 순서로 실행해야한다.

```cpp
DiningPhilosophers.pickup(i);
. . .
eat
. . .
DiningPhilosophers.putdown(i);
```

이 해결책이 동시에 먹는 2명의 이웃은 없고 데드락은 일어나지 않는다. 이미 말했듯이, 이것 또한 철학자가 굶어 죽을 수 있다. 우리는 이것에 대한 해결책은 예제로 남겨두겠다.

## 7.2 커널에서의 동기화

우리는 윈도우와 리눅스 운영체제에서의 동기화 메커니즘을 살펴보겠다. 이 두가지 운영체제는 커널을 동기화하는 여러가지 좋은 예제를 제공하고, 너가 보듯이, 이 시스템의 동기화 메커니즘은 미묘하지만 큰 차이를 보인다.

### 7.2.1 윈도우에서의 동기화

윈도우 운영체제는 리얼타임 앱 지원과 다중 프로세스를 제공하는 멀티스레드 커널이다. 윈도우 커널이 한 프로세서의 전역 리소스에 접근하면, 그 전역 리소스에 접급할수도 있는 모든 인터럽트 핸들러에 언터럽트를 칠한다. 멀티 프로세서 시스템에서, 윈도우는 스핀락을 통해서 전역 리소스 접근을 보호한다. 그리고 오직 코드 부분이 짧을 경우에만 스핀락을 사용한다. 더욱이, 효율성을 이유로, 커널은 스레드가 스핀락을 쥐고 있으면 결코 선점당하지 않는다. 

커널 밖의 스레드 동기화를 위해서, 윈도우는 **dispatcher objects**를 제공한다. 이것을 사용하면, 스레드는 뮤텍스락, 세마포, 이벤트, 타이머를 포함한 다양한 메커니즘으로 동기화한다. 이 시스템은 스레드에게 데이터를 접근하고 끝났을때 소유를 해제하는 뮤텍스의 권한을 스레드에게 요구함으로서 공유데이터를 보호한다. 세마포어는 6.6절에서와 같게 행동한다. **Evens**는 컨디션 변수와 비슷하다. 즉, 그들은 원하는 컨디션이 생겼을때 스레드에게 기다리라고 공지한다. 마지막으로, 타이머는 스레드가 시간이 만료되었다고 알려준다.

**Dispatcher object**는 **signaled state**이거나 **nonsignaled state**이다. **signaled state**인 오브젝트가 있으면, 스레드는 오브젝트를 획득할때 블락하지 않는다. **nonsignaled state**인 오브젝트가 없으면, 스레드는 오브젝트를 얻으려고 시도할때 블락한다.

디스패처 오브젝트의 상태와 스레드의 상태사이의 관계는 존재한다. 스레드가 논시그널드 디스패처 오브젝트를 블락하면, 그것의 상태는 레디에서 대기로 변하고, 스레드는 그 오브젝트에 대한 대기 큐에 들어간다. 디스패처 오브젝트의 상태가 시그널드로 변하면, 커널은 그 오브젝트를 기다리는 스레드가 있는지 확인한다. 만약 존재하면, 커널은 스레드를 가능한 대기 상태에서 레디 스테이트로 변경하고 그들은 실행을 재개한다. 커널은 한 스레드를 대기큐에서 선택하는데, 뮤텍스 오브젝트는 오직 한가지 스레드에게만 할당되기 때문이다. 이벤트 오브젝트에서는, 커널은 이벤트를 기다리는 모든 스레드를 선택한다. 

우리는 디스패처 오브젝트와 스레드 상태의 설명을 뮤텍스락을 통해서 설명할 수 있다. 만약 스레드가 nonsignaled 상태의 뮤텍스 디스패처 오브젝트를 얻으려고하면, 스레드는 정지하고 뮤텍스 오브젝트의 대기큐에 들어가게된다. 뮤텍스가 시그널 스테이트로 이동하면(다른 스레드가 뮤텍스의 락을 해제했다.), 큐의 헤드에서 기다리던 스레드는 레디 상태로 들어가고 뮤텍스락을 획득한다.

**critical-section object**는 커널 개입 없이 유저모드 뮤텍스를 획득/해제할 수 있다. 멀티프로세서 시스템에서, 임계영역 오브젝트가 다른 스레드가 오브젝트를 대기할때까지 처음으로 스핀락을 사용한다. 만약 스핀이 너무 길면, 획득한 스레드는 커널 뮤텍스에 할당하고 CPU를 포기한다. 임계영역 오브젝트는 커널 뮤텍스가 오직 오브젝트간의 경쟁이 있을때만 할당하기 때문에 특히 효율적이다. 실제로, 적은 경쟁만이 존재하기에, 절약이 뛰어나다.

우리는 이 챕터의 끝에서 윈도우 API를 이용한 세마포/뮤텍스락 프로젝트를 제공하겠다.

### 7.2.2 리눅스에서의 동기화

2.6버전 이전에는, 리눅스는 비선점 커널이었고, 커널 모드에서 작동하는 프로세스는 선점당하지 않았다. 이제, 그러나, 리눅스 커널은 선점형이고, 그래서 커널이 동작중일 때 태스크는 선점된다. 

리눅스는 커널에서의 동기화를 위한 다양한 동기화 메커니즘을 제공한다. 대부분의 컴퓨터 아키텍처는 간단한 수학 연산자에 대해서 아토믹 명령어를 제공하고, 리눅스에서 가장 간단한 동기화 테크닉은, 아토믹 정수이고, 불투명한 데이터 타입 *atomic_t*를 이용한다. 이름이 내포하듯이, 아토믹 정수를 이용하는 수학 명령어는 인터럽트 없이 작동한다. 이를 설명하기 위해서, 아토믹 정수 counter와 정수 value를 포함한 프로그램을 생각하겠다.

```cpp
atomic_t counter;
int value;
```

다음 표는 다양한 아토믹 명령어를 실행하는 명령어의 효과이다.
|Atomic Operation|Effect|
|---|---|
|atomic_set(&counter, 5); | counter = 5|
|atomic_add(10, &counter); | counter = counter + 10|
|atomic_sub(4, &counter); | counter = counter - 4|
|atomic_inc(&counter); | counter = counter + 1|
|value = atomic_read(&counter); | value = 12 |

아토믹 정수는 카운터 같은 정수 변수가 업데이트가 필요할때 특히 효율적이다. 아토믹 명령어는 락 메커니즘의 대리비가 필요로하지 않기 때문이다. 그러나, 그들의 사용은 일련의 시나리오에만 제한되어있다. 레이스 컨디션에 기여하는 몇가지 변수가 있는 상황에서, 더욱 정교한 락은 필요할 것이다.

뮤텍스 락은 커널에서의 임계 영역 보호를 위해서 리눅스에서 제공한다. 여기서, 태스크는 반드시 mutex_lock() 함수를 임계영역 진입 이전에 실행하고 나가기 전에 mutex_unlock()을 임계영역 탈출 이전에 실행해야한다. 만약 뮤텍스 락이 없으면, mutex_lock()을 부르는 태스크는 수면 모드에 들어가고 락의 주인이 mutex_unlock()을 실행하면 꺠운다.

리눅스는 또한 스핀락과 세마포를 커널을 락하기 위해서 제공한다.(reader-writer version of these two locks) SMP 머신에서, 기본적인 락킹 메커니즘은 스핀락이고, 커널은 스핀락이 짧은 기간동안 잡도록 디자인되었다. 단일 프로세서 머신에서는, 싱글 코어를 가진 임베디드 시스템에서, 스핀락은 사용에 부적절하고 커널 선점을 작동/비작동시킨다. 즉, 단일 프로세싱 코어에대해서는 스핀락을 이용하는 것보다는, 커널이 커널 선점을 비활성화하는 것이다. 그리고 스핀락을 해제하기보다는 커널 선점을 활성화한다.

리눅스 커널에서, 스핀락과 뮤텍스락은 *nonrecursive*이다. 즉, 만약 스레드가 이 락의 첫번쨰를 획득하면, 그것은 같은 락을 첫번쨰 해제없이는 두번쨰로 획득하지 못한다. 다른 경우에, 락을 획득하는 두번째 시도는 블락된다. 

리눅스는 커널 선점의 활성/비활성화에 흥미로운 접근을 사용한다. 그것은 두가지 간단한 시스템 콜을 제공하는데 `preeempt_disable()`과 `preempt_enable()`이다. 커널은 비선점이고, 그러나, 만약에 커널에서 작동중인 태스크가 락을 가지고 있다.  이 룰을 강화하기 위해서, 시스템의 각 태스크는 preempt_count(태스크가 소유하고 있는 락)을 포함하는 thread-info 구조를 가진다. 만약 락을 획득하면, preempt_count의 수는 증가한다. 락이 해제되면 감소한다. 만약 현재 커널에서의 태스크가 가진 수가 0보다 크면 커널을 선점하는 것은 안전하지 않다. 만약 카운트가 0이면 안전하게 인터럽트한다.(preempt_disable()이라는 거창한 명령어가 없다.)

커널 선점 활성/비활성화에서 스핀락들은 오직 락이 짧은시간을 잡고싶을때 사용한다. 락이 반드시 긴 시간을 필요로하면, 세마포어나, 뮤텍스락이 적절하게 쓰일 것이다.

## 7.3 POSIX 동기화

커널 개발자를 위한 동기화도구를 앞에서는 보았다. 반대로, POSIX API는 유저레벨 프로그래머와 다양한 운영체제에서 가용하다.(물론,그것은 호스트 운영체제가 제공하는 툴을 사용해야한다.)

이 절에서는, 우리는 Phtread와 POSIX API를 이용한 뮤텍스락, 세마포, 컨디션 변수를 다루겠다. 이 API는 유닉스, 리눅스, 맥os 개발자를 위한 스레드 생성과 동기화를 위해서 널리 쓰인다. 

### 7.3.1 포식스 뮤텍스 락

뮤텍스 락은 Pthread를 이용한 기본적인 동기화 도구이다. 뮤텍스 락은 임계영역을 보호하기 위해서 쓰이고 즉, 스레드는 임계영역에 들어가기전에 락을 획득하고 나가기 전에 해제한다. Pthread는 pthread_mutex_t 데이터를 뮤텍스 락을 위해서 사용한다. 뮤텍스는 pthread_mutex_init() 함수로 생성된다. 첫번쨰 파라미터는 뮤텍스 포인터이다. NULL을 준 두번쨰 파라미터는, 우리는 뮤텍스에 기본 설정을 초기화하게한다.
```cpp
#include <pthread.h>

pthread_mutex_t mutex;

/* create and initialize the mutex lock */
pthread_mutex_init(&mutex, NULL);
```

뮤텍스는 pthread_mutex_lock()과 pthread_mutex_unlock() 함수를 가진다. 만약 뮤텍스 락이 없을떄, pthread_mutex_lock()이 실행되면, 오너가 pthread_mutex_unlock()을 실행할때까지 블락된다.

```cpp
/* acquire the mutex lock */
pthread_mutex_lock(&mutex);

/* critical section */

/* release the mutex lock */
pthread_mutex_unlock(&mutex);
```

모든 뮤텍스 함수는 정상작동시 0을 리턴한다. 만약 에러가 생기면 함수는 0이 아닌 값을 리턴한다.

### 7.3.2 POSIX Semaphores

Pthreads를 구현하는 많은 시스템은 세마포어도 제공한다. 비록 세마포어가 POSIX 표준이 아닌 POSIX SEM 확장에 들어있다. POSIX는 **named**와 **unnamed**라는 두가지 타입의 세마포를 특정한다. 기본적으로, 두개는 꽤 비슷하지만, 그러나 그들은 그들이 프로세스 사이에서 어떻게 생성되고 공유되는지에 따라서 다른다. 두가지 테크닉은 일반적이지만, 우리는 두가지를 모두 다루겠다. 리눅스 2.6의 시작과 함께 두가지 세마포를 모두 제공한다.

#### 7.3.2.1 POSIX Named Semaphores

함수 sem_open()은 포식스 naemd sempahotre를 생성하고 오픈한다.

```cpp
#include <semaphore.h>
sem_t *sem;

/* Create the semaphore and initialize it to 1 */
sem = sem_open("SEM", 0_CREAT, 0666, 1);
```
이 예시에서, 우리는 세마포를 SEM이라고 이름지었다. 0_CREAT 플래그는 세마포가 존재하지 않는 것을 생성하는 것을 의미한다. 추가적으로, 세마포는 다른 프로세스를 읽고 쓰는 권한을 가진다.(0666을 통해서) 

네임드 세마포의 장점은 관련 없는 프로세스가 세마포의 이름을 언급하는 것만으로 공통의 세마포를 가지는 것이다. 이 예시에서, 한번 SEM이 생성되면, sem_open()은 존재하는 세마포의 기술어를 리턴한다.

6.6절에서, 우리는 wait()와 signal() 명령어를 설명했다. 포식스는 sem_wait()와 sem_post()를 개별적으로 사용한다. 다음 코드는 네임드 세마포어를 이용해서 임계영역을 보호한다.

```cpp
/* acquire the semaphore */
sem_wait(sem);

/* critical section */

/* realease the semaphore */
sem_pos(sem);
```

리눅스와 맥os는 POSIX 세마포어를 제공한다.

#### 7.3.2.2 POSIX Unnamed Semaphores

이름없는 세마포어는 세가지 파라미터를 전달하는 sem_init() 함수로 생성되고 초기화된다.
1. A pointer to the semaphore
2. A flag indicating the level of sharing
3. The semaphores's inital value

```cpp  
#include <semaphore.h>
sem_t sem;
/* Create the semaphore and initialize it to 1 */
sem_init(&sem, 0, 1);
```
이 예제에서 0을 전달함으로서, 우리는 세마포어가 소유한 프로세스가 만든 스레드에서만 접근이 가능하다.(0이 아니면, 우리는 세마포어를 공유 메모리 영역에 배치해서 다른 프로세스간에 공유가 된다.) 추가적으로, 우리는 세마포를 1로 초기화했다. 

POSIX unnamed semaphore는 sem_wait()와 sem_post()를 사용한다. 뮤텍스락과 같이, 모든 세마포는 정상작동시에 0을 리턴하고 아니면 0이 아닌 값을 리턴한다.

### 7.3.3 포식스 컨디션 변수

Pthread의 컨디션 변수는 6.7에서 설명한 것과 비슷하게 작동한다. 그러나, 이 절에서, 컨디션 변수는 모니터의 컨텍스트로 사용되고, 데이터 무결성을 확실하게하는 락킹 메커니즘이다. Pthread가 C에서 주로 사용되어서, 그리고 C는 모니터를 가지지 않아서, 우리는 뮤텍스락과 함꼐 컨디션 변수를 수행한다.

Pthread에서의 컨디션 변수는 pthread_cond_t 데이터 타입을 사용하고 pthread_cond_init() 함수로 초기화된다. 다음 코드는 컨디션변수와 뮤텍스를 초기화한다.
```cpp
pthread_mutex_t mutex;
pthread_cond_t cond_var;

pthread_mutex_init(&mutex, NULL);
pthread_cond_init(&cond_var, NULL);
```

pthread_cond_wait() 함수는 컨디션 변수를 기다릴때 사용한다. 다음 코드는 어떻게 스레드가 a==b가 참이 될때까지 기다리는지를 표현한 것이다.
```cpp
pthread_mutex_lock(&mutex);
while(a != b) pthread_cond_wait(&cond_var, &mutex);

pthread_mutex_unlock(&mutex);
```

컨디션 변수와 연결된 뮤텍스락은 반드시 pthread_cond_wait() 함수가 불리기전에 락이 되어야하고, 그것은 컨디셔널 clause의 데이터가 레이스컨디션을 보호하기 때문이다. 한번 락이 획득되면, 스레드는 컨디션을 확인한다. 만약 컨디션이 참이 아니면, 스레드는 pthread_cond_wait()를 호출하고, 뮤텍스락과 컨디션 변수를 파라미터로 넘긴다. pthread_cond_wait()를 부르면 뮤텍스 락은 해제되고 다른 스레드가 공유 데이터에 접근 가능하고 그것의 값을 변경하고 컨디션 clause를 참으로 바꿀수 있다.(프로그램 에러를 방지하기위해서, 컨디셔널 clause를 루프안에 넣어서 시그널되기전에 다시 체크하는 것은 중요하다.)

공유 데이터 수정을 실행하는 스레드는 pthread_cond_signal()함수를 사용하고, 그러므로 컨디션 변수를 기다리는 스레드에 신호를 보낸다. 다음과 같다.
```cpp
pthread_mutex_lock(&mutex);
a = b;
pthread_cond_signal(&cond_var);
pthread_mutex_unlock(&mutex);
```
pthread_cond_signal()은 뮤텍스락을 해제하지 않는 것이 중요하다. 이것은 뮤텍스를 해제하는 pthread_mutex_unlock()의 따라오는 콜이다. 한번 뮤텍스 락이 해제되면, 시그널 받은 스레드는 뮤텍스 락의 주인이 되고 pthread_cond_wait()를 호출한 컨트롤로 돌아간다. 

우리는 이 챕터에 pthreads 뮤텍스락과 컨디션 변수와 세마포에 관한 몇가지 프로그램 문제와 프로젝트를 제공했다.