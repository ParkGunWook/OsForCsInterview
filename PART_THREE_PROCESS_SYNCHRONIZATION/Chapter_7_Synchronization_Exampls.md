## what we gonna study

6장에서, 우리는 임계영역 문제를 보이고 다양한 동시 프로세스가 데이터를 공유할 때 생기는 레이스 컨디션에 집중했다. 우리는 레이스 컨디션이 생기는 것을 방지해서 임계영역을 조절하는 몇가지 툴을 배웠다. 이러한 툴들은 로우레벨 하드웨어 해결책(메모리 배리어, CAS 명령어)와 하이레벨 툴(뮤텍스락, 세마포어, 모니터)를 배웠다. 우리는 또한 데드락 같은 실시간 위험을 포함하는 레이스 컨디션을 자유롭게하는 여러가지 앱디자인 고려 사항을 보었다. 이번 장에서, 우리는 몇가지 클래식 동기화 툴을 보겠다. 우리는 또한 리눅스, 유닉스, 윈도우 운영체제 에서 사용하는 동기화 메커니즘을 보고, 우리는 자바와 포식스 시스템의 API 디테일을 보겠다.

## Objectives

- 바운디드 버퍼, 리더-라이터, 다이닝-필로소퍼 동기화문제를 보겠다. 
- 리눅스와 윈도우의 프로세스 동기화 툴을 보겠다.
- POSIX와 자바가 동기화 문제 해결에 사용되는 법을 보겠다.
- POSIX와 자바 API를 통해서 동기화 문제를 해결하겠다.

## 7.1 Classic Problems of Synchronization

이 절에서는, 우리는 동기화 컨트롤 문제에 관한 예시를 보겠다. 이러한 문제들은 최근에 제안된 동기화 구조를 테스트하기 위해서 쓰인다. 이 문제를 해결하기 위한 해결책은, 우리는 동기화를 위한 세마포어를 사용하겠다. 세마포가 이런 문제를 해결하는 전통적인 방법이다. 그러나, 이 실제의 구현은 바이너리 세마포어를 대신해서 뮤텍스 락을 쓸 수도 있다.

### 7.1.1 바운디드 버퍼 문제

*bounded-buffer problem*은 6.1절에서 소개되었다. 그것은 보통 동기화의 조상의 위력을 설명하기 위해서 사용된다. 이 문제의 예시를 장의 끝에서 보이겠다. 

우리의 문제에서, 생산자-소비자 프로세스는 다음의 데이터 구조를 공유했다.
```cpp
int n;
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;
```
우리는 풀이 총 n의 버퍼를 포함하고, 각각은 한가지 아이템을 쥐고 있을 수 있다. *mutex* 바이너리 세마포어는 버퍼 풀로의 접근을 위한 상호배제를 제공하고 1로 초기화 되어있다. empty와 full 세마포어는 빈공간과 가득찬 공간의 버퍼 크기를 샌다. 

생산자와 소비자의 코드는 아래와 같고 둘은 대칭적인 구조를 가진다.
```cpp
while(ture){
    . . .
    /* produce an item in next_produced */
    . . .
    wait(empty);
    wait(mutex);
    . . .
    /* add next_produced to the buffer */
    . . .
    signal(mutex);
    signal(full);
}
```

```cpp
while(ture){
    wait(full);
    wait(mutex);
    . . .
    /* remove an item in next_consumed */
    . . .
    signal(mutex);
    signal(empty);
    . . .
    /* consume the item in next_consumed */
    . . .
}
```

### 7.1.2 리더-라이터 문제

데이터 베이스가 몇가지 동시 프로세스에 의해서 소비된다고 가정하자. 이 프로세스 중 몇가지는 오직 데이터베이스에서 읽기만을 원할수도 있지만, 다른 것들은 데이터 베이스에 업데이트를 원할수도 있다. 우리는 이 두가지 타입의 프로세스를 전자는 리더 후자는 라이터라고 하겠다. 명백하게, 만약 두가지 리더가 공유 데이터에 동시에 접근하면, 역효과는 딱히 일어나지 않는다. 그러나, 만약에 라이터와 다른 프로세스(리더, 라이터 둘다)가 데이터 베이스가 같이 접근하면 혼돈이 일어난다.

이런 어려움이 일어나지 않게 보장하려면, 우리는 라이터가 데이터 베이스에 쓰는 동안 독점적인 권한을 갖도록 해야한다. 이 동기화 문제를 일컬어 **reader-writers problem**이라고 한다.

리더-라이터 문제는 몇가지 베리에이션이 있는데, 모든 것이 우선도를 포함한다. 가장 간단한것은, *first* readers-writers problem이라 하고, 라이터가 공유 데이터에 이미 허가를 받지 않은한 리더가 기다리지 않는 것이다. 다른 말로는, 리더는 리더가 끝나기를 기다리지 않는다. 왜냐하면 라이터가 대기중이기 때문이다. *second* readers-writers 문제는 라이터가 ready하면, 라이터는 최대한 빨리 실행한다. 다른 말로는, 만약 writer가 오브젝트에 접근을 기다리면, 리더는 더이상 새로 읽지 않는다.

두가지 문제에 대한 해결법은 기아를 발생할 수 있다. 첫번째 경우에는, writer가 굶는다. 두번째 경우에는 reader가 굶는다. 이런 이유로, 문제의 다양한 해결법이 제안되었다. 다음으로, first에 대한 해결책을 보이겠다. 두번째 문제를 해결하기 위한 **Bibliographical** note를 참고하면 좋을 것이다.

첫번째 리더-라이터 문제의 해결책에서, 리더 프로세스는 다음의 데이터 구조를 공유한다.

```cpp
semaphore rw_mutex = 1;
semaphore mutex = 1;
int read_count = 0;
```

바이너리 세마포 뮤텍스와 rw_mutex는 1로 초기화가 된다.  read_count는 0으로 초기화된 counting semaphore이다. 세마포어 rw_mutex는 reader와 writer 프로세스에 둘다 쓰인다. mutex 세마포어는 read_count가 업데이트 될때 상호배제가 확실하도록 사용된다. read_count는 현재 읽고있는 오브젝트의 수를 유지해준다. 세마포어 rw_mutex는 라이터를 위해서 상호배제를한다. 그것은 또한 임계영역을 들어가거나 나가는 첫번째 또는 마지막 리더도 쓴다. 그것은 다른 리더가 임계영역에 있을때는 사용되지 않는다.

코드는 다음과 같다.

```cpp
while(true){
    wait(rw_mutex);
    . . .
    /* writing is performed */
    . . .
    signal(rw_mutex);
}
```

```cpp
while(true){
    wait(mutex);
    read_count++;
    if(read_count == 1) wait(rw_mutex);
    signal(mutex);
    . . .
    /* reading is performed */
    wait(mutex);
    read_count--;
    if(read_conut == 0) signal(rw_mutex);
    signal(mutex);
}
```
만약 라이터가 임계영역에 있고 n 리더가 기다리고 있으면, 한명의 리더가 rw_mutex에 큐되고, n-1리더가 mutex에 큐된다. 라이터가 signal(rw_mutex)하면, 우리는 대기하는 리더 또는 대기하는 라이터중를 실행한다. 이 선택은 스케쥴러가 담당한다. 
리더-라이터 문제와 그것의 해결책은 시스템에서 락을 제공함으로서 일반화되었다. 리더-라이터 락은 락의 모드를 구별하는 것이 필요하다.(read or write access). 프로세스가 공유데이터를 읽기를 원할때, 그것은 리드모드로 리더-라이터 락을 요청한다. 공유 메모리 수정을 요청하는 프로세스는 반드시 라이터 모드로 락을 요청해야한다. 다양한 프로세스들은 리드 모드에서 리더 라이터 락을 얻는 것을 허가 받는다. 그러나 오직 하나의 프로세스만 writing을 위해서 락을 획득한다.

리더 라이터 락들은 다음상황에서 유용하다.
- 한가지 작업만 하는 프로세스를 구별하기 쉬운 앱
- 라이터보다 리더를 더 가진 앱. 리더-라이터 락은 보통 세마포어 또는 뮤텍스 락보다 더 큰 비용을 요구한다. 많은 리더를 가지는 것은 이것에 대한 대리비를 보상해준다.

### 7.1.3 식사하는 철학자 문제

5명의 철학자가 생각하고 먹기만 한다. 그 철학자들은 5개의 의자로 둘러쌓인 둥근 책상을 공유한다. 책상의 중심에는 쌀이 있고, 테이블에는 5개의 젓가락이 있다. 철학자가 생각할떄, 그녀는 다른 동료와 상호작용하지 않는다. 시간이 지나면, 철학자는 배고파지고, 근처의 젓가락을 든다. 철학자는 한번에 젓가락을 한짝만 들수 있고, 다른 사람의 손에 있는건 얻을 수 없다. 배고픈 철학자가 두손에 젓가락이 있으면, 먹고 다시 내려두고 생각한다.

철학자의 구조는 다음과 같다.
```cpp
while(true){
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    . . .
    /* eat for a while */
    . . .
    signal(chopstick[i]);
    signal(chopstick[(i+1) % 5]);
    . . .
    /* Think for a while */
    . . .
}
```
이 문제는 고전 동기화문제에서 동시성 컨트롤 문제로 분류된다. 이 문제는 데드락에서 자유롭고 기아에서 자유롭도록 프로세스에 리소스를 할당하는 필요의 기초적인 예제이다.

#### 7.1.3.1 세마포 문제

한가지 간단한 문제 해결법은 각 젓가락에 세마포어를 주는 것이다. 철학가는 젓가락은 wait()함으로서 획득한다. 그리고 signal()로 놓아준다. 그러므로 공유 데이터는 값이 1로 초기화되는 `semaphore chopstick[5];`이다.  비록 이 해결법이 두가지 이웃이 동시에 먹지 않는 것을 보장하지 않지만, 그것은 그럼에도 불구하고 그것이 데드락을 만들어서 거절해야한다. 모든 철학자가 배고파지고 모두 왼쪽 젓가락을 잡는 것을 상상해보아라. 모든 젓가락은 0으로 변한다. 각각의 철학자가 그녀의 오른쪽 젓가락을 쥐면, 그녀는 영원히 딜레이 된다.

이런 데드락 상황을 경감시키는 방법이 있다.
- 4명의 철학자가 동시에 책상에 앉게끔한다.
- 철학자가 오직 두개의 젓가락이 있을때만 집는다.(그녀는 반드시 임계영역에서 잡아야한다.)
- 비대칭 방법- 홀수는 왼쪽, 오른쪽 순으로 잡고, 짝수 철학자는 오른쪽, 왼쪽 순으로 잡는다.
  
6.7절에서, 우리는 식사하는 철학자 문제를 해결하기 위한 해결법을 보았다., 그러나 철학자가 굶어 죽는 상황을 아직 해결하지 못했다. 데드락-프리 솔루션은 기아의 문제를 해결하지는 못한다. 

#### 7.1.3.2 모니터 해결법

```cpp
monitor DiningPhilosophers
{
    enum {THINKING, HUNGRY, EATING} state[5];
    condition self[5];

    void pickup(int i){
        state[i] = HUNGRY;
        test(i);
        if(state[i] != EATING) self[i].wait();
    }

    void putdown(int i){
        state[i] =THINKING;
        test((i+4)%5);
        test((i+1)%5);
    }

    void test(int i){
        if((state[(i+4)%5] != EATING) && (state[i] == HUNGRY) && (state[(i+1)%5] != EATING) ){
            state[i] = EATING;
            self[i].signal();
        }
    }

    initialization_code(){
        for(int i=0; i<5; i++){
            state[i] = THINKING
        }
    }
}

다음으로는, 데드락 문제를 해결하는 모니터 방법을 보겠다. 이 해결법은 철학자가 오직 두개의 젓가락이 있을때만, 젓가락을 획득한다는 제한을 내포한다. 이 해결을 코드화하려면, 우리는 철학자가 가질 3가지 상황을 가정해야한다. 이 목적을 위해서 다음과 같은 데이터 구조가 따라온다.

`enum {THINKING, HUNGRY, EATING} state[5];`

철학자 i의 state[i] = EATING은 오직 그녀의 두 옆사람이 먹지않을때만 가능하다. (state[(i+4)%5] != EATING) and (state[(i+1)%5] != EATING)일 때이다.

우리는 또한 `condition self[5];`를 선언한다. 이것은 i가 그녀가 배고파진 시점으로부터 젓가락을 못 얻었을때 지연시켜준다.

우리는 이제 식사하는 철학자 문제를 해결법을 말했다. monitor DiningPhilosophers에 의해서 조작된다. 각 철학자는 먹기 이전에, pickup()을 실행한다. 이 행동은 철학자 프로세스의 정지를 일으킬수 있다. 명령어의 성공적인 완료후에, 철학자는 먹는다. 이것에 따르면, 철학자는 putdown()도 실행한다. 그러므로, 철학자 i는 반드시 pickup()과 putdown()을 다음의 순서로 실행해야한다.

```cpp
DiningPhilosophers.pickup(i);
. . .
eat
. . .
DiningPhilosophers.putdown(i);
```

이 해결책이 동시에 먹는 2명의 이웃은 없고 데드락은 일어나지 않는다. 이미 말했듯이, 이것 또한 철학자가 굶어 죽을 수 있다. 우리는 이것에 대한 해결책은 예제로 남겨두겠다.