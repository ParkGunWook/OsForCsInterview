# What we gonna study

멀티프로그래밍 환경에서, 스레드들은 한정된 수의 리소스로 경쟁한다. 스레드는 리소스를 요청한다. 만약 리소스가 없다면, 스레드는 대기 상태에 들어간다. 가끔, 대기 스레드는 상태를 영영 변하지 않을수 있다. 왜냐하면 대기 스레드가 원하는 리소스가 다른 스레드에 의해서 점유되기 때문이다. 이런 상황을 **Deadlock**이라고 한다. 우리는 이를 liveness failure의 한가지 형태라고 했다. 우리는 데드락을 *every process in a set of processes is waiting for an event that can be caused only by another process in the set*이라고 한다.

아마도 데드락의 가장 좋은 비유는 "두 기차가 교차로에 접근하는데, 두 기차가 모두 멈추고 한가지가 갈때까지 움직이지 않는 것이다.'이다.

이 장에서, 우리는 앱 개발자와 운영체제 개발자가 데드락을 어떻게 예방하고 해결하는지 보겠다. 비록 몇가지 앱은 데드락을 인지하지만, 운영체제는 데드락 예방 기능을 제공하지 않고, 그것은 데드락 프리한 시스템을 짜기를 우리에게 요구한다. 데드락 문제는 병렬 멀티코어 시스템의 성장과 함께 점점 힘들어지고 있다.

# Objectives

- 뮤텍스락이 사용될때 데드락이 어떻게 일어나는지 보겠다.
- 데드락을 위한 4가지 필요조건을 정의하겠다.
- 리소스 할당 그래프로 데드락 상황을 식별하겠다.
- 데드락을 예방하는 4가지 다른 접근을 보겠다.
- 데드락 회피를 위해서 뱅커의 알고리즘을 적용하겠다.
- 데드락 탐지 알고리즘을 적용하겠다.
- 데드락으로부터 회복하는 방법을 평가하겠다.


## 8.1 시스템 모델

시스템은 경쟁하는 스레드 사이에서 분산될 한정된 수의 리소스를 포함한다. 리소스는 몇가지 타입으로 분할되고, 각각은 몇몇 인스턴스의 수를 포함한다. CPU 사이클, 파일, I/O 디바이스 들은 모두 리소스의 종류이다. 만약 시스템이 4개의 CPU를 가지면, 리소스 타입 *CPU*는 4가지 인스턴스를 가진다. 비슷하게, 리소스 타입 *network*는 두개의 인스턴스를 가질수도 있다. 만약 스레드가 리소스 타입의 인스턴스를 요청하면, 어떤 인스턴스의 할당은 리퀘스트를 만족해야한다. 만약 그렇지 않으면, 인스턴스들은 동일하지 않고, 리소스 타입 클래스는 적절하게 정의되지 않는다.

다양한 동기화 도구들은 6장에서 다루었고, 뮤텍스락과 세마포는 또한 시스템 리소스이다. 현대 컴퓨터 시스템에서, 그들은 데드락의 가장 일반적인 원인이다. 그러나, 정의는 문제가 아니다. 락은 특정 데이터 구조와 관련되어있고, 즉 한락이 큐에 접근을 보호하고, 다른 것들은 링크드 리스트를 막을수도 있다. 이러한 이유로, 각 락의 인스턴스는 그것의 리소스 클래스에 일반적으로 할당된다.

이 챕터에서 논의하는 커널 리소스는 산출물이지만, 스레드들은 다른 프로세스로 부터 리소스를 사용할 수도 있다.(예를 들어서, 내부 통신), 그리고 이러한 리소스는 또한 데드락을 일으킨다. 이런 데드락은 커널의 고려가 아니므로 설명하지는 않겠다.

스레드는 반드시 리소스를 그것을 사용하기 전에 요청해야하고 사용후에는 해제해야한다. 스레드는 그것의 지정된 태스크를 해결하기 위해서 최대한 많은 리소스를 요청해야한다. 명백히, 리소스의 수는 전체 가용 리소스를 초과하지 않는다. 다른 말로는, 스레드가 만약에 2가지 네트워크 인터페이스를 요청하지만 하나라면 성립이 불가능한 것이다.

일반적인 명령에서, 스레드는 다음과 같은 순서를 가진다.
1. Request. 스레드가 리소스를 요청한다. 만약 요청이 즉시 보장되지 않으면, 요청하는 스레드는 그것이 리소스를 획득할때까지 기다린다.
2. Use. 스레드가 리소스에서 작동한다.(만약 리소스가 뮤텍스 락이면, 스레드는 임계영역에 접근이 가능하다.)
3. Release. 스레드가 리소스를 해제한다.

리소스의 요청과 해제는 시스템 콜일 수도 있다. 예를 들어 디바이스의 request()와 release(), 파일의 open()과 close()와 메모리의 allocate()와 free()일 것이다. 비슷하게 우리는 6장에서 세마포에서의 wait()와 signal()과 뮤텍스 락에서의 acquire()와 release()이다. 스레드에 의해서 사용되는 커널 관리 리소스의 사용에서, 운영체제는 스레가 요청을 하고 리소스가 할당되었는지 확인한다. 시스템 테이블은 각 리소스가 해제되고 할당되었는지 기록한다. 각각의 할당된 리소스에서, 테이블은 어떤 스레드가 할당될지 기록한다. 만약 스레드가 현재 다른 스레드에 할당된 리소스를 요청하면, 그것은 이 리소스를 기다리는 스레드의 큐에 더해질 수 있다.

스레드의 집합이 데드락 상태이다. 데드락에서 기다리는 이벤트는 리소스 획득과 해제이다. 리소스는 보통 논리적이다.(뮤텍스락, 세마포, 파일). 그러나 다른 종류의 이벤트가 데드락을 일으킨다.(네트워크 인터페이스 읽기 또는 IPC 기능)

이런 데드락 상태를 설명하기 위해서, 우리는 식사하는 철학자로 돌아가겠다. 이 상황에서, 리소스들은 젓가락으로 대표된다. 만약 모든 철학자들이 한번에 배고파지고, 각각의 철학자들이 그들의 왼쪽 젓가락을 잡으면, 더이상 젓가락이 없다. 각각의 철학자들은 그들의 오른쪽 젓가락이 생길때까지 기다린다.

멀티스레드 앱의 개발자들은 반드시 데드락의 가능성에 대해서 인지하고 있어야한다. 6장에서의 락킹 툴은 레이스 컨디션을 회피하기 위해서 디자인되었다. 그러나 이러한 도구들을 사용할 때, 개발자들은 반드시 어떻게 락이 획득되고 해제되는지 조심스러운 집중을 해야한다. 다른 경우에는, 데드락이 생긴다.

## 8.2 Deadlock in Multithreaded Applications

어떻게 데드락 이슈가 판명나고 관리되는 것을 측정하기 전에, 우리는 먼저 어떻게 데드락이 포식스 뮤텍스 락을 쓰는 멀티 스레드 Pthread 프로그램에서 생기는지 보겠다. pthread_mutex_init() 함수는 언락된 뮤텍스를 초기화한다. 뮤텍스락은 pthread_mutex_lock()과 pthread_mutex_unlock()을 이용해서 획득되고 해제될 수 있다. 만약, 스레드가 락된 뮤텍스를 획득하려하면, pthread_mutex_lock()은 뮤텍스 락의 주인이 pthread_mutex_unlock()을 실행하기 전까지 블락된다.

두개의 뮤텍스가 다음과 같이 초기화 되었다.
```cpp
pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

pthread_mutex_init(&first_mutex, NULL);
pthread_mutex_init(&second_mutex, NULL);
```

다음으로, 두 스레드가 생성되었다고 가정하겠다. 그리고 두가지 스레드는 이 뮤텍스 락에 접근 권한이 있고 스레드1은 do_work_one()에서 일하고 스레드2는 do_work_two()에서 일한다. 

이 예시에서, 스레드1은 (1)first_mutex, (2)second_mutex를 얻는다. 같은 시간에, 스레드 2는 (1)second_mutex (2)first_mutex의 순서로 락을 얻는다. 데드락은 만약 스레드 1이 뮤텍스1을 얻고 그 때에 스레드2가 뮤텍스2를 얻었을 때이다.

```cpp
void *do_work_one(void *param)
{
    pthread_mutex_lock(&first_mutex);
    pthread_mutex_lock(&second_mutex);
    /*
    Do Some Work
    */
    pthread_mutex_unlock(&second_mutex);
    pthread_mutex_unlock(&first_mutex);

    pthread_exit(0);
}


void *do_work_two(void *param)
{
    pthread_mutex_lock(&second_mutex);
    pthread_mutex_lock(&first_mutex);
    /*
    Do Some Work
    */
    pthread_mutex_unlock(&first_mutex);
    pthread_mutex_unlock(&second_mutex);

    pthread_exit(0);
}
```

비록 데드락이 가능하더라도, 만약 스레드1이 스레드2가 뮤텍스2를 얻기전에 뮤텍스 1을 해제하거나 얻으면 일어나지 않을 수 있다. 그리고 물론, 스레드가 CPU 스케쥴에 따라서 어떻게 작동하는지에 대한 순서도 일어나지 않게 할 수 있다. 이런 예제는 데드락 핸들링 문제를 알린다. 특정 스케쥴링 환경에 따라 데드락을 알아보고 테스트 하는 것이 어렵다.

### 8.2.1 Livelock

**Livelock**은 다른 종류의 liveness failure이다. 그것은 데드락과 비슷하지만, 두가지 모두 두개 이상의 스레드가 진행하는 것을 방지하지만, 스레드는 다른 이유로 진행되지 않는다. 데드락이 스레드가 블락된 대기를 하지만, 라이브락은 스레드가 실패하는 행동을 계속 시도하는 것이다. 라이브 락은 두명의 사람이 복도를 지날때 생긴다. 한명이 그의 우측으로 이동하고, 다른 사람은 그녀의 왼쪽으로 움직이는데, 각각의 진행을 방해한다. 그러면 그는 그의 왼쪽으로 이동하고, 그녀는 그녀의 오른쪽으로 움직인다. 그들은 블락된건 아니지만, 아무런 진전이 일어나지 않는다.

```cpp
void *do_work_one(void *param)
{
    int done = 0;
    while(!done){
        pthread_mutex_lock(&first_mutex);
        if(pthread_mutex_trylock(&second_mutex)){
            /*
            Do Some Work
            */
            pthread_mutex_unlock(&second_mutex);
            pthread_mutex_unlock(&first_mutex);
            done = 1;
        }
        else pthread_mutex_unlock(&first_mutex);
    }
    pthread_exit(0);
}

void *do_work_two(void *param)
{
    int done = 0;
    while(!done){
        pthread_mutex_lock(&second_mutex);
        if(pthread_mutex_trylock(&first_mutex)){
            /*
            Do Some Work
            */
            pthread_mutex_unlock(&first_mutex);
            pthread_mutex_unlock(&second_mutex);
            done = 1;
        }
        else pthread_mutex_unlock(&second_mutex);
    }
    pthread_exit(0);
}
```

라이브락은 Pthread의 pthread_mutex_trylock() 함수로 설명되는데, 블락없이 뮤텍스 락을 얻으려는 것이다. 이 상황은 라이브락을 만약에 스레드 1이 뮤텍스1을 얻는데, 스레드2가 뮤텍스2를 얻은 상태에서 일어나면 생긴다. 각각의 스레드는 pthread_mutex_trylock()을 실행하지마, 실패하고, 각각의 락을 해제하고, 이 행동을 무제한으로 반복한다.

라이브락은 일반적으로 스레드가 동시에 실패하는 명령어를 재시도할때 생긴다. 그것은 보통 각각의 스레드가 실패명령을 랜덤 시간에 시도해서 회피한다. 이 방법은 이더넷 네트워크가 네트워크 충돌이 생길때 정확하게 이용된다. 패킷을 충돌이 생기고 바로 보내기보다는, 충돌을 포함한 호스트는 전송을 다시하기전에 한발짝 물러선다.

라이브락은 데드락보다는 자주 일어나지 않지만, 병렬 앱 디자인에서 도전되는 과제이고, 특정 스케쥴링 환경에서 일어난다.

## 8.3 데드락 특성

이전 절에서, 우리는 데드락이 뮤텍스 락을 이용하는 멀티스레드 프로그래밍에서 생길 수 있다고 했다.

### 8.3.1 필요조건

1. 상호배제. 한가지 리소스가 공유되지 않는 모드로 점유되어있다. 즉, 한가지 스레드만이 리소스에 독점적으로 접근한다. 만약 다른 스레드가 리소스를 요청하면, 리소스가 해제될때까지 지연된다.
2. 점유대기. 스레드가 최소 한가지 리소스를 점유하고 다른 스레드에 의해서 점유되는 리소스를 획득하려고 한다.
3. 비선점. 리소스가 선점될 수 없다. 즉, 리소스는 오직 스레드가 자발적으로 리소스를 해제하고, 스레드는 태스크를 완료한다.
4. 환형대기. 리소스를 기다리는 스레드사이에 사이클이 있다.

우리는 데드락을 생기게 하는 4가지 상황을 강조하겠다. 환형 대기 상태는 점유대기를 포함한다. 그래서 4가지 상황은 완벽히 독립적이지 않다. 8.5절에서, 각 상황을 분리해서 보는 것의 장점을 보이겠다.

### 8.3.2 리소스-할당 그래프

데드락은 **system resource-allocation graph**라고 불리는 방향성 그래프로 설명이 가능하다. 그래프는 V, E가 있다. V는 2가지 타입으로 나뉘는데, 시스템에서 작동중인 스레드 T와 시스템의 리소스 R이다.

방향성 엣지는 T에서 R을 가르킨다. 이것은 T가 R을 리퀘스트 했고 현재 대기중이라는 것이다. R에서 T로의 엣지는 리소스가 현재 스레드 T에게 할당되었다는 것이다. T->R은 **request edge**라고 불리고 R->T는 **assignment edge**라고 한다.

만약 이 그래프에서 사이클이 없다면, 그 시스템은 데드락 상태가 될 수 없다는 것이다. 만약 사이클이 있다면, 그러면 시스템은 데드락 상태가 될 수도 있고 되지 않을 수도 있는 것이다. 이 관측은 데드락 문제에 잘 대응하기 위해서 매우 중요하다.