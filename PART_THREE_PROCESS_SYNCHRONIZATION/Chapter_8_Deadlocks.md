# What we gonna study

멀티프로그래밍 환경에서, 스레드들은 한정된 수의 리소스로 경쟁한다. 스레드는 리소스를 요청한다. 만약 리소스가 없다면, 스레드는 대기 상태에 들어간다. 가끔, 대기 스레드는 상태를 영영 변하지 않을수 있다. 왜냐하면 대기 스레드가 원하는 리소스가 다른 스레드에 의해서 점유되기 때문이다. 이런 상황을 **Deadlock**이라고 한다. 우리는 이를 liveness failure의 한가지 형태라고 했다. 우리는 데드락을 *every process in a set of processes is waiting for an event that can be caused only by another process in the set*이라고 한다.

아마도 데드락의 가장 좋은 비유는 "두 기차가 교차로에 접근하는데, 두 기차가 모두 멈추고 한가지가 갈때까지 움직이지 않는 것이다.'이다.

이 장에서, 우리는 앱 개발자와 운영체제 개발자가 데드락을 어떻게 예방하고 해결하는지 보겠다. 비록 몇가지 앱은 데드락을 인지하지만, 운영체제는 데드락 예방 기능을 제공하지 않고, 그것은 데드락 프리한 시스템을 짜기를 우리에게 요구한다. 데드락 문제는 병렬 멀티코어 시스템의 성장과 함께 점점 힘들어지고 있다.

# Objectives

- 뮤텍스락이 사용될때 데드락이 어떻게 일어나는지 보겠다.
- 데드락을 위한 4가지 필요조건을 정의하겠다.
- 리소스 할당 그래프로 데드락 상황을 식별하겠다.
- 데드락을 예방하는 4가지 다른 접근을 보겠다.
- 데드락 회피를 위해서 뱅커의 알고리즘을 적용하겠다.
- 데드락 탐지 알고리즘을 적용하겠다.
- 데드락으로부터 회복하는 방법을 평가하겠다.


## 8.1 시스템 모델

시스템은 경쟁하는 스레드 사이에서 분산될 한정된 수의 리소스를 포함한다. 리소스는 몇가지 타입으로 분할되고, 각각은 몇몇 인스턴스의 수를 포함한다. CPU 사이클, 파일, I/O 디바이스 들은 모두 리소스의 종류이다. 만약 시스템이 4개의 CPU를 가지면, 리소스 타입 *CPU*는 4가지 인스턴스를 가진다. 비슷하게, 리소스 타입 *network*는 두개의 인스턴스를 가질수도 있다. 만약 스레드가 리소스 타입의 인스턴스를 요청하면, 어떤 인스턴스의 할당은 리퀘스트를 만족해야한다. 만약 그렇지 않으면, 인스턴스들은 동일하지 않고, 리소스 타입 클래스는 적절하게 정의되지 않는다.

다양한 동기화 도구들은 6장에서 다루었고, 뮤텍스락과 세마포는 또한 시스템 리소스이다. 현대 컴퓨터 시스템에서, 그들은 데드락의 가장 일반적인 원인이다. 그러나, 정의는 문제가 아니다. 락은 특정 데이터 구조와 관련되어있고, 즉 한락이 큐에 접근을 보호하고, 다른 것들은 링크드 리스트를 막을수도 있다. 이러한 이유로, 각 락의 인스턴스는 그것의 리소스 클래스에 일반적으로 할당된다.

이 챕터에서 논의하는 커널 리소스는 산출물이지만, 스레드들은 다른 프로세스로 부터 리소스를 사용할 수도 있다.(예를 들어서, 내부 통신), 그리고 이러한 리소스는 또한 데드락을 일으킨다. 이런 데드락은 커널의 고려가 아니므로 설명하지는 않겠다.

스레드는 반드시 리소스를 그것을 사용하기 전에 요청해야하고 사용후에는 해제해야한다. 스레드는 그것의 지정된 태스크를 해결하기 위해서 최대한 많은 리소스를 요청해야한다. 명백히, 리소스의 수는 전체 가용 리소스를 초과하지 않는다. 다른 말로는, 스레드가 만약에 2가지 네트워크 인터페이스를 요청하지만 하나라면 성립이 불가능한 것이다.

일반적인 명령에서, 스레드는 다음과 같은 순서를 가진다.
1. Request. 스레드가 리소스를 요청한다. 만약 요청이 즉시 보장되지 않으면, 요청하는 스레드는 그것이 리소스를 획득할때까지 기다린다.
2. Use. 스레드가 리소스에서 작동한다.(만약 리소스가 뮤텍스 락이면, 스레드는 임계영역에 접근이 가능하다.)
3. Release. 스레드가 리소스를 해제한다.

리소스의 요청과 해제는 시스템 콜일 수도 있다. 예를 들어 디바이스의 request()와 release(), 파일의 open()과 close()와 메모리의 allocate()와 free()일 것이다. 비슷하게 우리는 6장에서 세마포에서의 wait()와 signal()과 뮤텍스 락에서의 acquire()와 release()이다. 스레드에 의해서 사용되는 커널 관리 리소스의 사용에서, 운영체제는 스레가 요청을 하고 리소스가 할당되었는지 확인한다. 시스템 테이블은 각 리소스가 해제되고 할당되었는지 기록한다. 각각의 할당된 리소스에서, 테이블은 어떤 스레드가 할당될지 기록한다. 만약 스레드가 현재 다른 스레드에 할당된 리소스를 요청하면, 그것은 이 리소스를 기다리는 스레드의 큐에 더해질 수 있다.

스레드의 집합이 데드락 상태이다. 데드락에서 기다리는 이벤트는 리소스 획득과 해제이다. 리소스는 보통 논리적이다.(뮤텍스락, 세마포, 파일). 그러나 다른 종류의 이벤트가 데드락을 일으킨다.(네트워크 인터페이스 읽기 또는 IPC 기능)

이런 데드락 상태를 설명하기 위해서, 우리는 식사하는 철학자로 돌아가겠다. 이 상황에서, 리소스들은 젓가락으로 대표된다. 만약 모든 철학자들이 한번에 배고파지고, 각각의 철학자들이 그들의 왼쪽 젓가락을 잡으면, 더이상 젓가락이 없다. 각각의 철학자들은 그들의 오른쪽 젓가락이 생길때까지 기다린다.

멀티스레드 앱의 개발자들은 반드시 데드락의 가능성에 대해서 인지하고 있어야한다. 6장에서의 락킹 툴은 레이스 컨디션을 회피하기 위해서 디자인되었다. 그러나 이러한 도구들을 사용할 때, 개발자들은 반드시 어떻게 락이 획득되고 해제되는지 조심스러운 집중을 해야한다. 다른 경우에는, 데드락이 생긴다.

## 8.2 Deadlock in Multithreaded Applications

어떻게 데드락 이슈가 판명나고 관리되는 것을 측정하기 전에, 우리는 먼저 어떻게 데드락이 포식스 뮤텍스 락을 쓰는 멀티 스레드 Pthread 프로그램에서 생기는지 보겠다. pthread_mutex_init() 함수는 언락된 뮤텍스를 초기화한다. 뮤텍스락은 pthread_mutex_lock()과 pthread_mutex_unlock()을 이용해서 획득되고 해제될 수 있다. 만약, 스레드가 락된 뮤텍스를 획득하려하면, pthread_mutex_lock()은 뮤텍스 락의 주인이 pthread_mutex_unlock()을 실행하기 전까지 블락된다.

두개의 뮤텍스가 다음과 같이 초기화 되었다.
```cpp
pthread_mutex_t first_mutex;
pthread_mutex_t second_mutex;

pthread_mutex_init(&first_mutex, NULL);
pthread_mutex_init(&second_mutex, NULL);
```

다음으로, 두 스레드가 생성되었다고 가정하겠다. 그리고 두가지 스레드는 이 뮤텍스 락에 접근 권한이 있고 스레드1은 do_work_one()에서 일하고 스레드2는 do_work_two()에서 일한다. 

이 예시에서, 스레드1은 (1)first_mutex, (2)second_mutex를 얻는다. 같은 시간에, 스레드 2는 (1)second_mutex (2)first_mutex의 순서로 락을 얻는다. 데드락은 만약 스레드 1이 뮤텍스1을 얻고 그 때에 스레드2가 뮤텍스2를 얻었을 때이다.

```cpp
void *do_work_one(void *param)
{
    pthread_mutex_lock(&first_mutex);
    pthread_mutex_lock(&second_mutex);
    /*
    Do Some Work
    */
    pthread_mutex_unlock(&second_mutex);
    pthread_mutex_unlock(&first_mutex);

    pthread_exit(0);
}


void *do_work_two(void *param)
{
    pthread_mutex_lock(&second_mutex);
    pthread_mutex_lock(&first_mutex);
    /*
    Do Some Work
    */
    pthread_mutex_unlock(&first_mutex);
    pthread_mutex_unlock(&second_mutex);

    pthread_exit(0);
}
```

비록 데드락이 가능하더라도, 만약 스레드1이 스레드2가 뮤텍스2를 얻기전에 뮤텍스 1을 해제하거나 얻으면 일어나지 않을 수 있다. 그리고 물론, 스레드가 CPU 스케쥴에 따라서 어떻게 작동하는지에 대한 순서도 일어나지 않게 할 수 있다. 이런 예제는 데드락 핸들링 문제를 알린다. 특정 스케쥴링 환경에 따라 데드락을 알아보고 테스트 하는 것이 어렵다.

### 8.2.1 Livelock

**Livelock**은 다른 종류의 liveness failure이다. 그것은 데드락과 비슷하지만, 두가지 모두 두개 이상의 스레드가 진행하는 것을 방지하지만, 스레드는 다른 이유로 진행되지 않는다. 데드락이 스레드가 블락된 대기를 하지만, 라이브락은 스레드가 실패하는 행동을 계속 시도하는 것이다. 라이브 락은 두명의 사람이 복도를 지날때 생긴다. 한명이 그의 우측으로 이동하고, 다른 사람은 그녀의 왼쪽으로 움직이는데, 각각의 진행을 방해한다. 그러면 그는 그의 왼쪽으로 이동하고, 그녀는 그녀의 오른쪽으로 움직인다. 그들은 블락된건 아니지만, 아무런 진전이 일어나지 않는다.

```cpp
void *do_work_one(void *param)
{
    int done = 0;
    while(!done){
        pthread_mutex_lock(&first_mutex);
        if(pthread_mutex_trylock(&second_mutex)){
            /*
            Do Some Work
            */
            pthread_mutex_unlock(&second_mutex);
            pthread_mutex_unlock(&first_mutex);
            done = 1;
        }
        else pthread_mutex_unlock(&first_mutex);
    }
    pthread_exit(0);
}

void *do_work_two(void *param)
{
    int done = 0;
    while(!done){
        pthread_mutex_lock(&second_mutex);
        if(pthread_mutex_trylock(&first_mutex)){
            /*
            Do Some Work
            */
            pthread_mutex_unlock(&first_mutex);
            pthread_mutex_unlock(&second_mutex);
            done = 1;
        }
        else pthread_mutex_unlock(&second_mutex);
    }
    pthread_exit(0);
}
```

라이브락은 Pthread의 pthread_mutex_trylock() 함수로 설명되는데, 블락없이 뮤텍스 락을 얻으려는 것이다. 이 상황은 라이브락을 만약에 스레드 1이 뮤텍스1을 얻는데, 스레드2가 뮤텍스2를 얻은 상태에서 일어나면 생긴다. 각각의 스레드는 pthread_mutex_trylock()을 실행하지마, 실패하고, 각각의 락을 해제하고, 이 행동을 무제한으로 반복한다.

라이브락은 일반적으로 스레드가 동시에 실패하는 명령어를 재시도할때 생긴다. 그것은 보통 각각의 스레드가 실패명령을 랜덤 시간에 시도해서 회피한다. 이 방법은 이더넷 네트워크가 네트워크 충돌이 생길때 정확하게 이용된다. 패킷을 충돌이 생기고 바로 보내기보다는, 충돌을 포함한 호스트는 전송을 다시하기전에 한발짝 물러선다.

라이브락은 데드락보다는 자주 일어나지 않지만, 병렬 앱 디자인에서 도전되는 과제이고, 특정 스케쥴링 환경에서 일어난다.

## 8.3 데드락 특성

이전 절에서, 우리는 데드락이 뮤텍스 락을 이용하는 멀티스레드 프로그래밍에서 생길 수 있다고 했다.

### 8.3.1 필요조건

1. 상호배제. 한가지 리소스가 공유되지 않는 모드로 점유되어있다. 즉, 한가지 스레드만이 리소스에 독점적으로 접근한다. 만약 다른 스레드가 리소스를 요청하면, 리소스가 해제될때까지 지연된다.
2. 점유대기. 스레드가 최소 한가지 리소스를 점유하고 다른 스레드에 의해서 점유되는 리소스를 획득하려고 한다.
3. 비선점. 리소스가 선점될 수 없다. 즉, 리소스는 오직 스레드가 자발적으로 리소스를 해제하고, 스레드는 태스크를 완료한다.
4. 환형대기. 리소스를 기다리는 스레드사이에 사이클이 있다.

우리는 데드락을 생기게 하는 4가지 상황을 강조하겠다. 환형 대기 상태는 점유대기를 포함한다. 그래서 4가지 상황은 완벽히 독립적이지 않다. 8.5절에서, 각 상황을 분리해서 보는 것의 장점을 보이겠다.

### 8.3.2 리소스-할당 그래프

데드락은 **system resource-allocation graph**라고 불리는 방향성 그래프로 설명이 가능하다. 그래프는 V, E가 있다. V는 2가지 타입으로 나뉘는데, 시스템에서 작동중인 스레드 T와 시스템의 리소스 R이다.

방향성 엣지는 T에서 R을 가르킨다. 이것은 T가 R을 리퀘스트 했고 현재 대기중이라는 것이다. R에서 T로의 엣지는 리소스가 현재 스레드 T에게 할당되었다는 것이다. T->R은 **request edge**라고 불리고 R->T는 **assignment edge**라고 한다.

만약 이 그래프에서 사이클이 없다면, 그 시스템은 데드락 상태가 될 수 없다는 것이다. 만약 사이클이 있다면, 그러면 시스템은 데드락 상태가 될 수도 있고 되지 않을 수도 있는 것이다. 이 관측은 데드락 문제에 잘 대응하기 위해서 매우 중요하다.

## 8.4 데드락 관리를 위한 메서드

보통은, 우리는 데드락 문제를 3가지 방법으로 다룰 수 있다.

- 우리는 모든 문제를 무시하고 데드락이 시스템에서 일어나지 않은척한다..
- 프로토콜을 이용해서 데드락을 예방하고 회비해서, 데드락 상태에 들어가지 않게한다.
- 우리는 데드락 상태에 빠질수는 있지만, 탐지하고, 회복하게한다.

첫번째 방법은 운영체제에서 가장 많이쓰인다.(윈도우, 리눅스) 이것은 이제 데드락을 회피하는 프로그램을 짜도록 커널/앱 개발자에게 넘긴 것이고, 2번째 방법을 보통 이용한다. 몇몇 시스템(데이터베이스)에서 3번째 방법을 채택해서 데드락이 생겨도 회복을 하게한다.

다음으로, 우리는 데드락을 관리하는 3가지 방법에 대해서 자세히 말하겠다. 8.5절에서 8.8절까지, 우리는 자세한 알고리즘을 말하겠다. 진행하기에 앞서서, 우리는 간단한 접근하나로는 운영체제 전체의 리소스 할당 문제를 해결할 수 없을 것이라는 몇몇 연구자를 말하겠다. 기본 접근들은 합쳐질 수 있고, 각 리소스의 클래스에 맞게 최적의 접근을 선택해야할 것이다.

데드락이 결코 생기지 않게 하기 위해서, 시스템은 데드락 예방 또는 데드락 회피 구조를 사용할 수 있다. **Deadlock prevention**은 필요조건 중 적어도 하나가 생기지 않게 하는 것이다. 이런 메서드는 리소스를 향한 요청을 제한함으로서 제공한다. 우리는 이런 메서드에 대해서 8.5절에서 말하겠다.

**Deadlock avoidance**는 운영체제가 스레드가 어떤 리소스를 요청하고 그것의 일생을 사용하는지에 관한 정보를 미리 알아야한다. 이러한 추가 지식으로, 운영체제 시스템은 스레드가 기다려야하는지 아닌지를 판단한다. 현재의 리퀘스트가 충족되는지 지연되는 지를 반드시 결정하기 위해서, 시스템은 반드시 현재 가용한 리소스를 고려하고, 각 스레드에 할당된 리소스를 고려하고, 각 스레드의 해제와 예측되는 리퀘스트를 고려해야한다.

만약 시스템이 데드락 예방 또는 회피 알고리즘을 쓰지 않으면, 데드락 상태가 생겨난다. 이런 환경에서, 시스템은 시스템의 상태를 측정해서 데드락이 일어났는지 아닌지 확인하고 그렇다면 데드락으로부터 회복하는 알고리즘을 부른다. 

데드락을 감지하고 회복하는 알고리즘의 부재에서, 우리는 어떤 시스템이 데드락 상태에 빠졌고 무슨 일이 일어났는지 모르는 상황에 빠질 수도 있다. 이런 경우에, 감지되지 않은 데드락은 시스템의 성능을 하향시키고, 리소스가 다른 스레드에 의해서 잡혀있고 더욱 많은 스레드가 리소스를 요청하다보면 데드락 상태에 빠지게 된다. 결과적으로, 시스템은 작동을 멈추고, 수동으로 재시작해야 할 것이다.

비록 이런 메서드가 데드락 문제에 실행가능한 접근 같아 보이지 않지만, 앞서 말했듯이 이 방법들은 그럼에도 불구하고 쓰인다. 비용은 한가지 중요한 고려사항이다. 데드락의 가능성을 모두 무시하는 것이 다른 방법들보다 싸다. 시스템이 데드락을 자주 일으키지 않는다면, 다른 메서드들은 의미가 없다.

추가적으로, 메서드들은 다른 liveness conditions에서 회복되기 위해서 사용된다. 이런 상황에서, 시스템은 데드락이 아닌 liveness failure에서 고통받을 수 있다. 우리는 이런 상황을, 리얼 타임 스레드가 높은 순위로 작동하고 운영체제로 결코 컨트롤을 넘기지 않는다. 시스템은 이런 상황을 회복시키고 데드락 회복 테크닉만을 사용한다.

## 8.5 Deadlock prevention

8.3.1절에서 언급했듯이, 데드락이 일어나기 위해서, 4가지 필수조건이 반드시 필요하다. 이중 한가지가 일어나지 않는다는 것을 이용해서, 우리는 데드락의 발생을 예방한다. 우리는 이런 방법을 필요조건을 분리해서 접근하도록 하겠다.

### 8.5.1 Mutual Exclusion

상호배제 상태는 반드시 일어나야한다.즉, 적어도 한가지 리소스는 반드시 공유불가능이어야한다. 공유가능 리소스는 상호 배제 접근이 필요하지 않고 그러므로 데드락이 포함될수가 없다. 만약 몇가지 스레드가 read-only 파일을 시도하면, 그들은 파일에 접근을 동시에 하도록 보장해야한다. 스레드는 공유 가능리소스에 대해서 기다릴 필요가 없다. 보통, 우리는 상호배제 상태를 부인함으로서 데드락을 예방할 수 없는데, 몇몇 리소스는 태생적으로 공유가 불가능하다. 예를 들어서, 뮤텍스락은 몇가지 스레드에 의해서 동시에 공유가 불가능하다.

### 8.5.2 Hold and wait

점유대기 상태가 일어나지 않는다는 것을 확신하기 위해서, 우리는 스레드가 리소스를 요청할때마다, 그것이 다른 리소스를 가지고 있지 않다고 보증해야한다. 우리가 사용하는 프로토콜은 각 스레드가 요청하고 그것의 실행전에 리소스를 할당받는 것을 필요로한다. 이것은, 물론, 요청하는 리소스의 동적인 환경때문에 대부분의 앱에서 비효율적이다. 한가지 대안적인 프로토콜은 스레드가 none을 가질때만 요청하게 한다. 스레드는 몇가지 스레드를 요청하고 사용할 수 있다. 추가적인 리소스를 요청하기전에, 그것은 현재 가지고 있는 리소스를 반드시 해제해야한다.

이런 프로토콜은 두가지 단점이 있다. 첫번쨰는 리소스 효율성이 낮아 질수있는데, 리소스가 할당은 받았지만 오랜 기간동안 사용되지 않을 수도 있다. 예를 들어서, 스레드는 전체 실행 동안 뮤텍스락을 할당받았지만, 그것은 오직 짧은 주기만을 필요로한다. 두번쨰, 기아가 가능하다. 몇가지 인기 있는 리소스를 무한으로 기다릴 수 있다. 왜냐하면, 항상 필요한 리소스가 다른 스레드에게 할당되어 있을 수도 있다.

### 8.5.3 선점이 없다.

데드락을 위한 세번째 필수조건은 리소스의 선점이 없는 것이다. 이런 상황이 생기지 않는 것을 확신하기 위해서, 우리는 다음과 같은 프로토콜을 사용하겠다. 만약 스레드가 몇가지 리소스를 잡고있고 당장 할당될수 없는 다른 리소스를 요청했다.(즉, 스레드가 대기해야한다.) 그떄 스레드가 가지고 있는 모든 리소스는 선점당한다. 다른말로는, 이런 리소스는 해제되었다. 선점된 리소스들은 대기중인 스레드에 퍼지게 된다. 스레드는 그것의 오래된 리소스를 얻었을때 재시작한다.

대안적으로, 만약 스레드가 몇가지 리소스를 요청하면, 우리는 그들이 가용한지 체크한다. 만약 그들이 그렇다면, 우리는 그들을 할당한다. 만약 그들이 그렇지 않다면, 우리는 그들이 추가적인 리소스를 기다리는 다른 스레드에 할당할지 체크한다. 그러면, 우리는 대기 스레드로부터 리소스를 선점하고 요청하는 스레드에 할당한다. 만약 리소스가 대기 스레드에 없으면, 요청 스레드는 반드시 기다려야한다. 그것이 기다리는 동안, 그것의 리소스는 선점당할 수 있다. 스레드는 새로운 리소스가 할당되고 대기하는 동안 선점당한 리소스가 회복되면 재시작된다.

이 프로토콜은 상태가 쉽게 저장되고 복구되는 리소스에 보통 적용된다.(CPU 레지스터와 데이터베이스 트랜잭션) 그것은 뮤텍스락이나 세마포어같이 데드락이 보통 일어나는 리소스의 타입에는 적용이 불가능하다.

### 8.5.4 환형대기

앞서 말한 데드락 예방은 대부분의 상황에서 불필요하다. 그러나, 환형대기는 필수조건 하나를 없애는 실용적인 솔루션이 존재한다. 환형대기가 절대 생기지 않게하는 방법은 모든 리소스 타입의 전체 순위를 내포하고 각 스레드가 리소스를 증가하는 순서로 요청하게 하는 것이다.

리소스를 리소스1~N의 자연수로 나타내겠다. 그리고 Pthread 프로그램의 F(뮤텍스1)이 1을 가지고, F(뮤텍스2)가 5를 가지도록 하겠다. 우리는 데드락을 예방하기 위해서 다음과 같은 프로토콜을 요청하겠다. 각 스레드는 목록의 순서가 증가하는 순으로 리소스를 요청한다. 즉, F(리소스i) < F(리소스j)인 j만 요청한다. 뮤텍스의 예시로 우리는 두가지 뮤텍스를 모두 사용하고 싶고 두가지 뮤텍스를 요청해야한다. 우리는 리소스j를 요청하는 스레드는 반드시 F(리소스i)>=F(리소스j)인 리소스i를 해제해야한다.

만약 두가지 프로토콜이 사용되면, 환형대기는 일어날 수 없다. 우리는 환형대기가 있다고 가정해서 이 사실을 정의하겠다. 환형대기를 포함하는 스레드 {T0, T1, ... , Tn}이 있다고 가정하자. 각 Ti는 Ri를 기다리고 있고, 그것은 T_(i+1)이 가지고 있다.(나머지 연산자를 이용해서 Tn은 T0가 가지고 있는 Rn을 기다리고 있다.) 즉 T_(i+1)이 Ri를 잡으면서 R_(i+1)을 요청하는데, 우리는 모든 i에 대해서 F(R_i) < F(R_(i+1))을 성립해야한다. 그러나 이 상황에서 F(R0) < F(R1) < ... < F(Rn) < F(R0)이다. 하지만 F(R0) < F(R0)는 불가능하다. 그러므로 환형대기는 존재하지 않는다.

순서, 계층적으로 개발하는 것 자체가 데드락을 예방하지는 않는다. 그것은 프로그램이 순서를 잘 따르도록 앱개발자가 써야한다. 그러나, 락 순서를 건설하는 것은 어려운데, 특히 시스템이 수백-수천개의 락을 가지기 떄문이다. 이런 도전을 조정하기 위해서, 많은 자바 개발자들은 메서드 identitiyHashCode(Object)(오브젝트 파라미터가 전해지면 자동으로 해시 값을 반환)을 락의 순서를 얻기 위해서 사용한다.

```cpp
void transaction(Account from, Account to, double amount)
{
    mutex lock1, lock2;
    lock1 = get_lock(from);
    lock2 = get_lock(to);

    acquire(lock1);
        acquire(lock2);

            withdraw(from, amount);
            deposit(to, aount);

        release(lock2);
    release(lock1);
}
```
> 함수 실행마다 lock1과 lock2의 순서가 from과 to에 따라서 달라지기 때문에 문제가 생길수 있다. 

락이 동적으로 할당된다면 락 순서를 통한 데드락 예방은 실현되지 않는다. 예를 들어서, 우리가 두 계좌 사이에서 돈을 이체하는 함수가 있다. 이런 레이스 컨디션을 막기위해서, 각 계좌는 뮤텍스락이 걸려있다. 데드락은 만약에 두개의 스레드가 동시에 transaction()을 실행했을때, 다른 돈으로 바꾼다. 즉 한가지 스레드는 `transaction(checking_account, savings_account, 25.0)`을 실행하고 나머지는 `transaction(savings_account, checking_account, 50.0)`을 실행했을때 이다.