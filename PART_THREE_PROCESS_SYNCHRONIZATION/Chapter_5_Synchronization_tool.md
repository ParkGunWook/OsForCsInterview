# what we gonna study

**Cooperating process**는 시스템에서 존재하는 다른 프로세스에게 영향을 주거나 받는 것이다. 협업 프로세스들은 논리적인 주소공간을 직접 공유하거나 공유 메모리 또는 메시지 패싱만으로 데이터를 공유할 수도 있다. 공통 데이터에 동시 접근은 데이터 불완전성을 초래할 수 있다. 이 장에서는, 우리는 협업 프로세스들이 순서대로 작동하게 하는 다양한 메커니즘을 배워서, 데이터 일관성을 유지시키겠다.

# Objectives

- 임계-영역 문제와 레이스 컨디션에 대해서 설명한다.
- 하드웨어 솔루션인 메모리 베리어, 컴패어-스왑 명령어, atomic 변수로 임계영역 문제 해결법 설명하겠다.
- 뮤텍스 락, 세마포, 모니터, condition variables로 임계영역 문제를 해결하겠다.
- low, moderate, high 경쟁 상황에 따른 임계영역 문제 해결 툴을 측정하겠다.

## 6.1 Background

우리는 concurrently or parallel하게 작동하는 프로세스를 보았다. 3.3.2 절에서는 프로세스 스케쥴링의 역할을 소개하고 어떻게 CPU 스케쥴러가 빠르게 스위칭하면서 concurrent하게 작동하는지 보여줬다. 실제로, 이것은 한개의 프로세스가 다른 프로세스가 스케쥴되기전에 부분적으로 완료할 수 있다는 것이다. 실제로, 프로세스는 특정 명령어의 스트림에서 인터럽트되고, 프로세싱 코어는 다른 프로세스의 명령어를 할당한다. 4.2절에서는 병렬 실행, 두개의 명령어 스트림이 구별된 코어에서 나오는 것을 보였다. 이 챕터에서는, 우리는 어떻게 병렬 실행이 몇가지 프로세스가 공유하는 데이터의 무결성에 이슈를 만드는지 설명하겠다.

어떻게 이런 일이 생기는지 알아보자. 3장에서, 우리는 연속 협업 프로세스 또는 스레드의 모델을 보았고, 비동기로 작동하고 데이터를 공유했다. 우리는 생산자-소비자 문제로 모델을 설명했고, 운영체제 함수의 대표 패러다임이다. 특별하게도, 3.5절에서, 우리는 메모리를 공유하기 위해서 프로세스에 바운디드 버퍼를 주는 것을 설명했다.

우리는 이제 바운디드 버퍼의 고려로 돌아오겠다. 말했듯이, 우리의 본래의 해결책은 BUFFER_SIZE-1의 아이템이 버퍼에 있을떄였다. 우리가 이 알고리즘의 결점을 감소하려고 수정해보겠다. 한가지 가능성은 정수 변수, 카운트를 0으로 초기화하는 것이다. 카운트는 새로운 아이템이 버퍼에 들어올때마다 증가하고 빠질때마다 감소한다. 

생산자 코드는 다음과 같다.

```c
while(true){
    /* produce an item in next produced */
    
    while(count == BUFFER_SIZE) ;
    
    buffer[in] = next_produced;
    in = (in +1) % BUFFER_SIZE;
    count++;
}
```

소비자 코드는 다음과 같다.

```c
while(true) {
    while(count == 0) ;

    next_consumed = buffer[out];
    out = (out +1) % BUFFER_SIZE;
    count--;
}
```

비록 생산자와 소비자 루틴이 개별적으로는 옳아보이지만, 그들은 동시에 작동할때 문제가 생길 수 있다. count의 값이 현재 5이고 생산자와 소비자가 동시에 "count++", "count--"를 실행한다고 생각해보자. 두개의 실행은, 4 또는 5 또는 6이 될 수 있다. 기계어로 count++이 해석될때에 총 3가지 단계를 다음과 같이 가진다. 그리고 이 기계어가 순서에 맞지 않게 끼워지면 문제가 생기는 것이다.

> register_1 = count
> register_1 = register_1 + 1
> count = register_1

우리는 우리가 두개의 프로세스가 count 변수를 동시에 조작해서 문제가 된것을 알고있다. 몇가지 프로세스가 같은 데이터를 동시에 접근하고 조작하는 상황에서는 실행의 결과는 접근이 일어난 시점의 특정한 순서에 따라서 달라지고 **race condition**이라고 부른다. 이런 race condition을 막기위해서는, 우리는 count를 동시에 한개의 프로세스만 조작하게하면된다. 이것을 보장하기 위해서, 우리는 프로세스가 몇가지 방식으로 동기화 되게 한다.

운영체제에서는 시스템의 다른 파트가 자원을 관리할때 자주 일어난다. 더욱이, 우리가 앞서 언급했듯이, 멀티코어 시스템의 발전은 멀티스레드 앱의 개발의 중요성을 올렸다. 이런 앱에서, 데이터를 공유하는 몇가지 스레드들은 다른 프로세싱 코어에서 병렬로 작동중이다. 확실하게, 우리는 이런 활동들이 다른 것을 방해하는 변화를 원하지 않는다. 이 이슈의 중요성 때문에, 우리는 **process synchronization**과 **coordination**에 많은 투자를 했다.


## 6.2 Critical-Section Problem

우리는 프로세스 동기화의 첫 번째 고려를 임계-영역 문제로 시작하겠다. n개의 프로세스를 가진 시스템을 생각하겠다. 각각의 프로세스는 **critical-section**이라는 공유된 데이터가 하나 이상의 프로세스에게 접근되고 업데이트되는 코드의 부분이 있다. 시스템의 중요한 기능은,한 프로세스가 임계영역을 실행중이면, 다른 프로세스는 임계영역을 실행하는게 허용되지 않는다. 각 프로세스는 그것의 임계영역에 들아가기전에 승인 요청을 해야한다. 이런 요청을 하는 코드를 **entry section**이라고 한다. 그리고 임계영역 후에는 **exit section**을 가진다. 나머지 코드는 **remainder section**이라고 부른다. 

3가지 방법으로 임계영역 문제를 해결할 수 있다.

1. Mutex exclusion - 만약 P1이 임계영역을 실행중이면, 다른 프로세스들은 그들의 임계영역을 실행할 수 없다.
2. Progress - 만약 프로세스가 임계영역을 실행중이지 않고 몇몇 프로세스가 임계영역 실행을 원하면, 그들의 잔여 섹션를 실행중이지 않은 코드들중 하나가 선택되어서 임계영역을 실행한다. 그리고 이 선택은 무기한으로 연기될 수 없다.
3. Bounded waiting - 만약에 바운드, 리미트가 시간에 따라 존재하면, 다른 프로세스들은 프로세스가 임계영역에 입장 요청을 보낸후에 그들의 임계 영역에 들어가는 것을 허용받는다.

프로세스들은 0이 아닌 속도로 실행중이라고 가정한다. 그러나 우리는 n프로세스의 상대적인 속도를 추측할 수 없다.

주어진 시점에서, 많은 커널 모드 프로세스는 운영체제 안에서 활동중이다. 결과적으로, 운영체제를 구현하는 코드(커널 코드)는 몇가지 레이스 컨디션을 만들수 밖에 없다. 커널 데이터 구조가 시스템에서 오픈 파일의 리스트를 유지한다. 이 리스트는 반드시 새로운 파일이 열리고 닫히면 수정되어야한다. 만약 두가지 프로세스들이 파일을 열려고하면, 리스트를 향한 분리된 업데이트는 레이스 컨디션을 유발한다. 

다른 예시는 두가지 프로세스 P0와 P1이 fork() 시스템 콜로 자식 프로세스를 만든다고 생각하자. 이 예제에서, 다음의 프로세스 식별자의 값인 커널 변수 next_available_pid에서 레이스 컨디션은 생길수 있다. 상호 배제가 없다면, 같은 프로세스 식별자가 두개의 분리된 프로세스에 배정된다.

레이스 컨디션을 잘 일으키는 다른 커널 데이터 구조는 메모리 할당을 위한 구조, 프로세스 리스트 관리, 인터럽트 핸들링을 포함한다. 이것은 커널 개발자에게 운영체제가 레이스 컨디션에 자유롭도록할지 달려있다.

임계 영역 문제는 싱글 코어 환경에서는 만약 공유 변수가 실행중일때 인터럽트를 방지함으로서 간단하게 해결할수있다. 이런 방법으로, 우리는 현재 명령어의 시퀀스가 선점없이 명령의 순서를 지키게 할수 있다. 다른 명령어들은 실행되지 않고, 예측하지 못한 변경은 생기지 않을 것이다.

불행히도, 이 해결책은 멀티프로세서 환경에서는 적절하지 않다. 멀티 프로세서에 대해서 인터럽트를 비활성화하는 것은 모든 프로세스끼리 메시지를 주고 받아야해서 비용이 많이 든다. 이 메시지 패싱은 임계영역에 들어갈때마다 딜레이시키고, 시스템 효율성은 감소한다. 또한 시스템의 클락이 인터럽트에 의해서 업데이된다면 그 효과를 생각해보아라.

두가지 방법이 운영체제에서 임계영역을 다루기 위해서 사용된다. **Preemptive kernels**과 **Nonpreemptive kernels**이다. 선점 커널은 커널 모드 실행중에 선점이 가능하게 허용하고 비선점은 커널에서 실행중인 프로세스가 선점되지 않게 한다. 커널 모드 프로세스는 커널 모드를 종료, 블락, 자발적으로 CPU의 컨트롤을 포기할때까지 실행된다.

명백하게, 비선점 커널은 커널 데이터 구조에서 레이스 컨디션으로 부터 자유로운데, 한개의 프로세스가 커널에서 한개만 실행되기 때문이다. 우리는 선점 커널에서는 같게 얘기하지 못하는데, 그들은 공유 커널 데이터를 레이스 컨디션으로부터 자유롭도록 보장해야한다. 선점 커널들은 SMP 디자인에서 특히 디자인하기 힘든데, 두개의 커널 모드 프로세스가 CPU 코어에서 동시에 실행할수있기 때문이다.

왜, 우리는 선점을 비선점보다 선호할까? 선점 커널은 더욱 반응성있고, 커널 프로세스가 너무 길게 작동하기전에 기다리는 프로세스를 위해서 포기하기 때문이다. 더욱이, 선점 커널은 리얼타임 프로그래밍에 적합하고, 리얼 타임 프로세스는 커널에서의 프로세스를 선점한다.