## What we gonna learn

이 장에서 리눅스 운영체제의 깊이있는 분석을 하겠다. 완벽하고 실제의 운영체제를 평가함으로서, 우리는 우리가 말했던 개념들이 어떻게 관련되는지 볼 수 있을 것이다. 이 장에서, 우리는 리눅스의 역사와 개발을 보고 유저와 프로그래머 인터페이스를 살펴보겠다. 리눅스가 제공하는 것은 유닉스 전통에 기반했다. 우리는 또한 이런 인터페이스의 구현과 디자인을 따져보겠다. 리눅스는 빠르게 진화하는 운영체제이다. 이 장에서 2017년에 출시된 리눅스 커널 4.12를 통해서 설명하겠다.

## Objectives

- 리눅스가 끌어온 유닉스 운영체제의 역사와 니룩스 디자인이 기초한 원칙을 살펴보겠다.
- 리눅스 프로세스와 모델을 평가하고 어떻게 리눅스 스레드가 스레드를 스케쥴하고 IPC를 제공하는지 보겠다.
- 리눅스에서의 메모리 관리를 살펴보겠다.
- 리눅스가 어떻게 파일 시스템을 구현하고 I/O 디바이스를 관리하는지 보겠다.

## 20.1 Linux History

리눅스는 유닉스와 매우 닮았다. 실제로, 유닉스 호환성은 리눅스 프로젝트의 주요한 목적중 하나이다. 그러나, 리눅스는 유닉스보다 훨씬 젊다. 그것의 개발은 1991년에 시작했고, 핀란드 대학생, 리누스 토르발즈가 80386 프로세스(인텔이 만든 첫번쨰 PC 호환되는 32bit CPU)를 위한 작지만 자립하는 커널을 만들기 시작했다.

그것의 개발 초기에는, 리눅스 소스 코드는 무료이고 배포에 제한이 최소였다. 결과적으로, 리눅스의 역사는 전세계의 많은 개발자의 합작품이고, 대부분이 인터넷을 통해 이루어졌다. 유닉스 시스템 서비스의 작은 서브셋만 부분적으로 구현된 첫 커널에서, 리눅스는 현대 유닉스 시스템의 모든 기능을 포함하게 성장했다.

초기에, 리눅스 개발은 중심 운영체제 커널을 중심으로 크게 돌았고, 특전을 받은 코어는 모든 시스템 리소스를 관리하고 컴퓨터 하드웨어와 직접적으로 소통했다. 우리는 이 커널보다 더한걸 원했고, 물론, 완전한 운영체제를 생성했다. 우리는 그러므로 리눅스 커널과 완벽한 리눅스 시스템 사이에 구별을 했다. **Linux kernel**은 리눅스 커뮤니티에 의해서 개발된 작은 조각으로부터 모인 소프트웨어의 조각이다. **Linux system**, 우리가 근래에 안것은, 다양한 컴포넌트를 포함하고, 몇몇은 스크래치로부터 쓰였고, 몇몇은 다른 개발 프로젝트로부터 빌리고, 다른 팀과 협동해서 만든 것이다.

기본 리눅스 시스템은 유저와 앱 프로그래밍에 표준 환경이다. 그러나 그것은 가용한 기능 관리의 표준 목적을 강요하지는 않는다. 리눅스가 성숙하면서, 리눅스의 꼭대기에 올릴 기능의 다른 계층의 필요가 생겼다. 이 필요는 다양한 리눅스 배포판에서 맞추어졌다. **Linux distribution**은 리눅스 시스템의 모든 표준 컴포넌트를 포함하고, 초기 설치와 리눅스의 업그레이드와 설치를 관리하고 시스템에서의 다른 패키지를 제거를 단순화하는 관리자 툴이 더해진다. 현대 배포판은 또한 파일 시스템의 관리, 유저 계정의 생성과 관리, 네트워크, 웹브라우저 워드프로세스의 관리를 위한 툴도 포함한다.


### 20.1.1 The Linux Kernel

첫번쨰로 대중에 공개된 리눅스 버전은 0.01이었고, 1991년 3월 14일에 출시했다. 그것은 네트워킹이 없었고, 오직 80386에 적절한 인텔 프로세서와 PC 하드웨어에서만 작동했고, 디바이스 드라이버 지원을 극적으로 제한했다. 가상 메모리 서브시스템은 꽤 일반적이었고 메모리 맵드 파일에 지원은 포함되지 않았다. 그러나, 초기의 생에는 COW와 보호된 주소 공간으로 공유 페이지를 지원했다. 지원하는 파일 시스템은 Minix 파일 시스템이고, 첫번째 리눅스 커널은 Minix 플랫폼과 교차로 개발되었다.

다음 마일 스톤은 1994년 3월 14일에 배포되었다. 이 배포는 리눅스 커널의 빠른 3년의 개발이 끝이 났다. 아마도 가장 큰 단일 기능은 네트워킹이다. 1.0은 유닉스의 표준 TCP/IP 네트워킹 프로토콜을 지원했고, BSD 호환성 소켓 인터페이스를 네트워킹 프로그램을 위해서 지원했다. 디바이스 드라이버 지원은 이더넷으로 IP 또는 모뎀에서의 연결을 위해서 추가되었다.

1.0 커널은 또한 기존 미닉스 파일 시스템의 제한없이 향상되고 새로운 파일 시스템을 포함했고, 그것은 고성능 디스크 접근을 위한 SCSI 컨트롤러를 지원했다. 개발자들은 파일을 스왑과 임의의 파일의 메모리 매핑을 하기 위해서 페이징을 지원하는 가상 메모리 서브시스템으로 확장했다.

추가적인 하드웨어 지원의 범위는 이 배포에서 포함되었다. 비록 여전히 인텔 PC 플랫폼에 제한되었지만, 하드웨어 지원은 플로피 디스크와 CD-ROM 디바이스를 포함해서 지원하게 성장했다.(사운드 카드, 마우스, 국제 키보드 등). 부동 소수점 계산또한 80387 수학 프로세서가 없는 80386유저를 위해서 제공되었다. 시스템 V 유닉스 스타일 **IPC**, 공유 메모리, 세마포어, 메시지 큐가 또한 구현되었다.

이 시점에, 개발은 1.1 커널 스트림을 시작했지만, 1.0을 따라서 다양한 버그 픽스 패치가 배포되었다. 패턴은 리눅스 커널을 위한 표준 넘버링 컨벤션으로 채택되었다. 홀수의 마이너 버전 넘버를 가진 커널들은 1.1 또는 2.5같은 것들은 **development kernels**이다. 짝수 숫자의 마이너 버전 넘버는 안정된 **production kernels**이다. 안정된 커널을 위한 업데이트는 오직 교정하기 위한 버전인 반면에, 개발 커널은 새롭고 상대적으로 테스트되지 않은 기능을 포함했다. 이 패턴은 버전 3까지 유지되었다.

1995년 3월에, 1.2 커널이 배포되었다. 이 배포는 1.0 배포처럼 같은 향상된 기능을 제공했고, 그러나 그것은 새로운 PCI 하드웨어 버스 아키텍처를 포함한 다양한 넓은 범위의 하드웨어를 지원했다. 개발자들은 다른 PC 특화 기능을 추가했고 80386 CPU의 가상 8086 모드를 지원해서 PC 컴퓨터를 위한 DOS 운영체제의 에뮬레이션을 가능하게 했다. 그들은 계정과 방화벽을 지원해서 IP 구현을 업데이트했다. 동적 로드 가능/불가능한 커널 모듈을 위한 단순한 지원 또한 커널 모듈에 제공되었다.

1.2 커널은 마지막 PC 전용 리눅스 커널이다. 리눅스 1.2를 위한 소스 배포는 SPARC, Alpha와 MIPS CPUs를 지원하도록 구현되었지만, 이런 다른 아키텍처의 완전한 통합은 다음 1.2 커널이 배포되기전에는 시작되지 않았다.

리눅스 1.2 배포는 더 넓은 범위의 하드웨어 지원과 존재하는 기능의 완벽한 구현에 집중했다. 새로운 기능들은 그 시점에 개발되고 있었지만, 메인 커널 소스 코드로의 새로운 코드의 통합은 안정된 1.2 커널이 배포되기까지 연기되었다. 결과적으로, 1.3 개발 스트림은 커널에 추가된 새로운 기능의 큰 덕을 보았다.

이 작업은 리눅스 버전 2.0이 배포되는 1996년 6월에 배포되었다. 이 배포는 메이저 버전 넘버 증가를 받았는데, 왜냐하면 두가지 새로운 기능이 추가되었다. 64비트를 포함한 다중 아키텍처 지원과 Symmetric multiprocessing(SMP) 지원이다. 추가적으로, 메모리 관리 코드는 블록 디바이스의 캐싱과 독립적인 파일 시스템 데이터의 통합된 캐시를 제공함으로서 향상되었다. 이 변화의 결과로, 커널은 파일 시스템과 가상 메모리 성능에서 큰 증가를 받았다. 처음으로, 파일 시스템 캐싱은 네트워크 파일 시스템에 확장되었고 쓰기 가능한 맵드 리전또한 지원한다. 다른 주요한 증가는 내부 커널 스레트, 로더블 모듈사이의 의존성을 노출시키는 메커니즘, 수요에 따른 자동적인 로딩, 파일 시스템 한도, 포식스 호환 리얼 타임 프로세스 스케쥴링 클래스가 추가되었다.

1999년의 2.2 버전의 배포에서도 발전은 계속되었다. UltraSPARC 시스템으로의 포트가 추가되었다. 네트워킹은 더 유연한 방화벽, 향상된 라우팅과 트래픽 관리, TCP를 위한 지원으로 향상되었다. 에이콘, 애플, NT 디스크가 읽힐 수 있고, NFS가 새로운 커널 모드 NFS 다이몬으로 향상되었다. 시그널 핸들링, 인터럽트, 이전보다 SMP 성능은 증가하기 위해서 몇몇 I/O들은 정제된 레벨에 락되었다.

2.4와 2.6 배포의 진전은 증가된 SMP 시스템, 파일 시스템 탐색, 메모리 관리와 블럭 I/O 시스템을 향한 향상을 위한 지원이다. 스레드 스케쥴러는 버전 2.6에서 수정되었고, O(1)의 복잡도를 제공한다. 추가적으로, 2.6 커널은 선점이고, 스레드가 커널 모드로 작동할떄에도 선점하게 허용한다.

리눅스 커널 버전 3.0은 2011년에 배포되었다. 주요한 2~3으로의 발전은 리눅스의 20주년을 기념하기 위해서이다. 향상된 가상 지원, 새로운 페이지 라이트 백 기능, 메모리 관리 시스템으로의 기능이 포함되고 그러나 다른 새로운 스케쥴러, Completely Fair Scheduler(CFS)또한 나타났다.

리눅스 버전 4.0은 2015년 4월에 배포되었다. 이 번에는 매우 모호하다. 리눅스 커널 개발자들은 큰 마이너 버전에 지쳤다. 오늘날 리눅스 커널 버전은 배포 순서를 제외하고는 별 의미가 업다. 4.0 커널 시리즈는 새로운 아키텍처, 향상된 모바일 기능, 많은 반복적인 향상을 제공했다. 우리는 이 챕터의 나머지에는 가장 최근의 커널을 다루겠다.

### 20.1.2 The Linux System

앞서 말했듯이, 리눅스 커널은 리눅스 프로젝트의 중심을 만들었지만, 다른 컴포넌트들이 완벽한 리눅스 운영체제를 만들었다. 반면에 리눅스 커널은 리눅스 프로젝트에 특화된 스크래치로부터 전체의 코드를 구성했고, 리눅스를 만든 대부분의 지원 소프트웨어는 리눅스에 독점적이지 않고 유닉스 운영체제에 일반적이다. 특히, 리눅스는 버클리 BSD 운영체제, MIT의 X 윈도우 시스템, GNU의 일부를 개발하는데에 많이 사용했다.

툴의 공유는 두 방향으로 일어났다. 리눅스의 주요한 시스템 라이브러리는 GNU 프로젝트에서 기원했지만, 리눅스 커뮤니티는 생략, 비효율성, 버그를 잡으면서 라이브러리를 크게 향상시켰다. **GNU C complier** 같은 다른 컴포넌트들은 리눅스에서 직접 쓰일정도로 충분히 높은 품질을 가졌다. 네트워크 관리자 툴은 4.3 BSD에서 처음 개발한 코드에서 끌어왔지만, 현재의 BSD는 리눅스에서 코드를 끌어온다. 이 공유의 예시는 인텔 부동 소수점 에뮬레이션 수학 라이브러리와 PC 사운드 하드웨어 디바이스 드라이버를 포함한다.

리눅스 시스템은 인터넷을 넘어서 느슨하게 연결된 개발자들의 협력으로 유지된다. 그리고 특정 컴포넌트의 무결성을 유지하는 책임을 가진 개인과 작은 그룹이 있다. 작은 수의 공용 인터넷 FTP 아카이브 사이트는 사실상의 표준 레퍼지토리이다. **File System Hierachy Standard** 문서는 또한 다양한 시스템 컴포넌트를 건너 호환성을 확신하는 수단으로서 리눅스 커뮤니티에 존재한다. 이 표준은 리눅스 파일 시스템의 전체 레이아웃을 명시한다. 그것은 어떤 디렉토리가 설정 파일, 라이브러리, 시스템 바이너리, 런타임 데이터 파일을 저장해야할지 결정한다.

### 20.1.3 Linux Distributions

이론적으로, 누구든 ftp 사이트로부터 필수 시스템 컴포넌트의 최신 버전을 실행하고 그들을 컴파일링 함으로서 리눅스 시스템을 설치할수 있다. 최근의 리눅스는, 이것이 리눅스 유저가 정확히 해야할 일이다. 리눅스가 성숙하면서, 다양한 개인과 그룹이 이 일을 설치를 위한 표준, 미리 컴파일된 패키지를 제공함으로서 덜 고통스럽게 한다.

이런 모음집, 배포판은 기본적인 리눅스 시스템 이상을 포함한다. 그들은 일반적으로 추가 시스템 설치와 관리 유틸리티 뿐만이 아니라 미리 컴파일되고 설치가 준비된 유닉스 툴(뉴스 서버, 웹 브라우저, 텍스트 프로세싱툴, 심지어는 게임)를 포함한다.

첫번쨰 배포판은 이런 패키지를 단순히 적절한 위치에 모든 파일을 압축해제하도록 제공했다. 현대 배포판의 가장 중요한 기능은, 진보된 패키지 관리이다. 오늘날의 리눅스 배포판은 패키지가 설치되고, 업그레이드되고 고통없이 제거되도록 허용하는 패키지 트래킹 데이터베이스를 포함한다.

SLS 배포판에서, 리눅스의 초기판으로 돌아가면, 완벽한 배포판으로 인식되는 리눅스 패키지의 첫번째 컬렉션이다. SLS는 현제 기대하는 리눅스 배포판의 패키지 관리 툴이 부족하다. **Slackware** 배포판은 전체 품질에서 큰 향상을 얻었다. 그것은 또한 저급한 패키지 관리를 가졌다. 실제로, 그것은 여전히 리눅스 커뮤니티에서 널리 설치된 것중 하나이다.

슬랙 웨어의 출시후에, 많은 상업적 비상업적 리눅스 배포판이 나왔다. **Red Hat**과 **Debian**들은 특별히 유명한 배포판이다. 첫번쨰는 상업적 리눅스를 지원한 회사이고 두번째 무료 소프트웨어 커뮤니티에서 나온 것이다. 다른 리눅스의 상업적 지원 버전은 **Canonical**과 **SuSE**가 있다. 우리가 이제 설치할 리눅스 배포판은 다양하다. 다양한 배포판은 리눅스 배포판들이 호환되는 것을 예방하지 않는다. RPM 패키지 파일 포맷이 대부분의 배포판에서 사용되거나 상업적 앱이 RPM 파일을 수용한 배포판에서만 설치되고 실행하게한다.

### 20.1.4 Linux Licensing

리눅스 커널은 GNU General Public License(GPL)의 버전 2에서 배포되었다. 리눅스는 공적인 도메인 소프트웨어가 아니다. **Public domain**은  저자가 소프트웨어에 대한 저작권을 포기한 것인데, 그러나 리눅스 코드의 저작권은 여전히 코드의 다양한 저자에게 잡혀있다. 리눅스는 *free* 소프트웨어이고, 그러나 사람들이 복사하고 수정하고 그들이 원하는대로 사용하고, 그들의 카피를 팔 수 있다.

리눅스 라이센싱의 주요한 암시는 아무도 리눅스를 사용하거나 리눅스의 파생물을 만들어가 소스코들르 포함하지 않고 파생물을 배포할 수 있다. GPL아래에서 배포된 소프트웨어는 바이너리 전용 프로덕트로 재 배포될 수 없다. 만약 너가 GPL에 의해서 만들어진 소프트웨어를 배포하면, 너는 반드시 소스코드가 바이너리 배포판으로 구별되게 만들어야한다.

## 20.2 Design Principles

그것의 전체 디자인에서, 리눅스는 다른 전통적인, nonmicrokernel 유닉스 구현과 비슷하다. 그것은 유닉스 호환 툴의 완전한 집합을 가진 멀티유저, 멀티태스킹 시스템이다. 리눅스의 파일 시스템은 유닉스 시맨틱에 빠져있고, 표준 유닉스 네트워킹 모델이 완벽히 구현되어있다. 리눅스 디자인의 내부 디테일은 운영체제 개발의 역사에 크게 영향을 받았다.

비록 리눅스가 다양한 플랫폼에서 작동하지만, 그것은 PC 아키텍처에서 독점적으로 개발되었다. 최근 개발의 큰 처리는 잘 펀딩된 개발 또는 연구 시설보다는 개별적인 지지자들에 의해서 실행되었고, 그래서 시작부터 리눅스는 최대한 많은 기능을 제한된 리소스로부터 짜내기 위해서 시도했다. 오늘날, 리눅스는 수백 기가의 메인 메모리와 테라바이트의 디스크 공간과 함께 멀티 프로세스 머신을 행복하게 돌리지만, 그것은 여전히 16MB이하의 램에서 유용하게 돌리기가 가능하다.

PC가 점점 강력해지고, 하드디스크와 메모리가 싸지면서, 초기의, 최소의 리눅스 커널은 더 많은 유닉스 기능을 구현하게 성장했다. 속도와 효율성은 여전히 중요한 디자인 골이지만, 최근의 작업은 3번째 메이저 디자인 골인 표준화에 집중한다. 유닉스 구현의 다양성에 지불한 비용은 한가지를 위해 작성한 소스코드가 다른 곳에서는 정확히 컴파일되거나 실행될 필요가 없다는 것이다. 심지어 같은 시스템 콜이 다른 두 유닉스 시스템에 있으면, 그들은 필수적으로 같은 방식으로 작동하지 않는다. 포식스 표준은 운영체제 행동의 다른 측면에 대한 상세의 집합을 모았다. 일반적인 운영체제 기능와 프로세스 스레드와 리얼타임 명령어 같은 확장판을 위한 포식스 다큐먼트가 있다. 리눅스는 POSIX 다큐먼트를 따르고 두개의 배포판이 공식적인 POSIX 증명을 수행했다.

그것이 프로그래머와 유저에게 표준 인터페이스를 주기 떄문에, 리눅스는 유닉스와 친밀한 누구에게나 약간의 놀라움을 보여준다. 우리는 이런 인터페이스를 여기서는 다루지 않겠다. 고정으로, 리눅스 프로그래밍 인터페이스는 SVR4 유닉스 시맨틱에 부착되었다. 라이브러리의 분리된 집합은 BSD 시맨틱을 구현하는데 가용하다.

많은 다른 표준이 유닉스 세계에 존재하지만, 리눅스의 완전한 증명은 느린데 왜냐하면 증명은 비용을 통해 가용하고, 운영체제의 준수를 증명하는 것은 비용을 포함한다. 그러나, 다양한 범위의 앱의 베이스를 지원하는 것은 운영체제에게 중요하고, 그래서 표준의 구현은 리눅스 개발의 주요한 목적이고, 리눅스는 최근에 포식스 스레딩 확장 Pthreads와 리얼타임 프로세스 컨트롤을 위한 포식스 확장을 지원한다.

### 20.2.1 리눅스 시스템의 컴포넌트

리눅스 시스테은 세가지 메인 바디로 이루어 져있고, 대부분이 전통적인 유닉스 구현과 비슷하다.

1. Kernel. 커널은 가상 메모리와 프로세스 같은 것을 포함한 운영체제의 중요한 관념을 유지하는 책임을 가진다.
2. System libraries. 시스템 라이브러리는 어떤 앱이 커널과 소통하느냐를 통해서 함수의 표준 집합을 정의한다. 이런 함수들은 커널 코드의 완전한 권한을 필요로하지 않는 운영체제 함수의 대부분을 구현한다. 대부분의 중요한 시스템 라이브러리는 `libc`로 알려진 **C library**이다. 표준 C 라이브러리를 제공함으로서, `libc`는 치명적인 시스템 레벨 인터페이스와 리눅스 시스템 콜 인터페이스의 대부분의 유저 모드 사이드를 구현한다.
3. System utilityies. 시스템 유틸리티들은 개별적으로, 특화된 관리 태스크를 수행하는 프로그램들이다. 몇몇 시스템 유틸리티들은 초기화되고 시스템의 몇가지 측면을 설정하기 위해서 한번 실행된다. 다른 **daemons**로 알려진 것들은, 영구적으로 실행되고 다가오는 네트워크 커넥션, 터미널로부터 로그온 요청을 받아들이고 로그 파일을 업데이트하는 태스크를 핸들링한다.

이들을 구별하는 가장 중요한 것은 커널과 나머지이다. 모든 커널 코드는 프로세서의 권한 모드에서 컴퓨터의 모든 물리적 리소스에 완전한 접근을 하면서 실행한다. 리눅스는 이 권한 모드를 **kernel mode**라고 한다. 리눅스에서, 어떠한 유저 코드도 커널안에 빌드될 수 없다. 어떠한 커널 모드에서 실행할 필요가 없는 운영체제 지원 코드는 시스템 라이브러리에 위치하고 **user mode**에서 작동한다. 커널 모드와는달리, 유저 모드는 시스템 리소스의 제한된 서브셋에만 접근할 수 있다.

비록 다양한 모던 운영체제가 그들의커널 내부를 위해서 메시지 패싱 아키텍처를 채택했지만, 리눅스는 유닉스의 역사적인 모델을 유지한다. 커널은 단일로, 하나로 구성된 바이너리로 생성된다. 주요한 이유는 성능이다. 모든 커널 코드와 데이터 구조가 단일 주소 공간에 유지됨으로서, 스레드가 운영체제 함수를 부르거나 하드웨어 인터럽트가 발생할떄 컨텍스트 스위치가 필요하지 않다. 더욱이, 커널은 다양한 서브시스템 사이에서 싼 C 함수 실행과 더욱 복잡하지 않은 IPC로 데이터를 패스하고 요청을 만든다. 단일 주소 공간은 코어 스케쥴링, 가상 메모리 코드뿐만이 아니라 모든 디바이스 드라이버, 파일 시스템, 네트워킹코드를 포함한 모든 커널 코드를 포함한다.

비록 모든 커널 컴포넌트가 이 같은 도가니를 공유하지만, 여전히 모듈을 위한 여지가 있다. 유저 앱이 런타임에 필요한 코드의 조각을 끌어오는 공유 라이브러리를 로드하듯이, 리눅스 커널은 런타임에 동적으로 모듈을 로드할 수 있다. 커널은 어떤 모듀류이 로드되는지를 알 필요가 없다. 그들은 정말로 독립적인 로더블 컴포넌트이다.

리눅스 커널은 리눅스 운영체제의 코어를 형성한다. 그것은 프로세스를 관리하고 스레드를 실행하는데 필요한 모든 기능을 제공하고, 그것은 하드웨어 리소스에 모호하고 보호된 접근을 주는 시스템 서비스를 제공한다. 커널은 운영체제로서 작동할 모든 필요한 기능을 구현한다. 그것의 바램대로, 리눅스 커널에 의해서 제공된 운영체제는 완벽하지 않다. 그것은 유닉스의 많은 기능과 행동이 부족하고, 그것이 제공하는 기능은 유닉스 앱이 그들이 원하는 대로 나타나기를 기대하는 포맷일 필요가 없다. 앱을 실행하는 운영체제 인터페이스는 커널에 의해서 직접적으로 유지되지 않는다. 오히려, 앱은 시스템 라이브러리에 콜을 만들고 필요한 만큼 운영체제 서비스를 부른다.

시스템 라이브러리는 많은 종류의 함수를 제공한다. 가장 간단한 레벨에서, 그들은 리눅스 커널에 시스템 콜을 만드는 앱을 허용한다. 시스템 콜을 만드는 것은 유저 모드에서 커널 모드로 컨트롤을 전송하는 것을 포함한다. 이 전송의 상세는 아키텍처마다 다르다. 라이브러리는 시스템 콜 어규먼트에 신경쓰고, 만약 필요하다면, 이런 어규먼트를 시스템 콜을 만들기위해서 특별하게 나열한다.

라이브러리는 더 복잡한 기본 시스템 콜을 제공할 수도 있다. 예를 들어서, C 언어의 버퍼 파일 핸들링 함수는 시스템 라이브러리에 구현되어있을 수 있다. 그리고 기본 커널 시스템 콜보다 진보된 파일 I/O를 제공한다. 라이브러리는 또한 시스템 콜에 일치하지 않는 루틴을 제공하는데, 소팅 알고리즘, 수학적 함수와 스트링 조정 루틴이다. 유닉스 또는 포식스 앱의 실행을 지원하는 모든 함수들은 시스템 라이브러리에 구현되었다.

리눅스 시스템은 넓은 범위의 유저 모드 프로그램을 포함하고 시스템 유틸리티와 유저 유틸리티도이다. 시스템 유틸리티는 시스템을 시작하고 관리하는데 필요한 모든 프로그램을 포함하고, 네트워크 인터페이스를 셋업하고 시스템으로부터 유저를 제거하고 추가한다. 유저 유틸리티들은 또한 시스템의 기본 명령어에도 필수적인데 그러나 실행하기 위해서 권한을 상승시킬 필요는 없다. 그들은 파일 복사, 디렉토리 생성, 텍스트 파일 수정 같은 단순한 파일 관리 유틸리티를 포함한다. 가장 중요한 유저 유틸리티는 **Shell**이고, 유닉스에서 표준 CLI이다. 리눅스는 많은 쉘을 지원하는데 일반적인 것은 **bourne again shell(bash)**이다.