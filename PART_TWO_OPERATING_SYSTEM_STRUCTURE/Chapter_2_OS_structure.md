# What we gonna study?

운영체제는 프로그램이 실행되는 환경을 제공한다.  내부적으로, 운영체제는 그들이 여러개의 라인으로 구성되는 메이크업에 따라 달라진다. 새로운 운영체제의 디자인은 매우 중요하다. 디자인을 시작하기 전에 운영체제를 잘 정의하는 것이 중요하다. 이런 목표는 다양한 알고리즘과 전략을 고른 기초이다.

우리는 운영체제를 다양한 우세로 볼수있다. 한가지 관점은 시스템이 제공하는 서비스에 집중하는 것이다. 다른 하나는 프로그래머와 유저가 사용하능하게하는 인터페이스이다. 세번째는 그것의 구성요소와 내부연결이다. 이 장에서는, 우리는 운영체제의 3가지 관점을 바라볼 것이다. 사용자, 프로그래머, 운영체제 디자이너의 관점이다. 우리는 운영체제가 어떤 서비스를 제공하는지 고려하고 그들이 어떻게 제공되는지 그들이 어떻게 디버깅되는지, 그리고 이런 시스템을 디자인하는 여러가지 방법론이 된다. 마지막으로 우리는 어떻게 운영체제가 만들어지고 어떻게 컴퓨터가 운영체제를 실행하는지 보겠다.

# Objectives

1. 운영체제가 제공하는 서비스를 확인한다.
2. 시스템 콜이 어떻게 운영체제 서비스를 제공하는지 설명한다.
3. 단일, 레이어드, 마이크로 커널, 모듈러, 하이브리드 전략을 비교하며 운영체제 디자인을 살펴본다.
4. 운영체제를 부팅하는 프로세스를 설명한다.
5. 운영체제 퍼포먼스를 관찰하는 툴을 적용한다.
6. 리눅스 커널을 간섭하는 커널 모듈을 디자인하고 사용한다.

## 2.2 Operating-System Service

운영체제는 프로그램을 실행하는 환경을 제공한다. 그것은 프로그램을 모두 가능하게 하는 서비스이다. 특정 서비스들은 물론 다른 운영체제에서도 제공하지만, 우리는 일반적인 클래스를 구별한다. 

- 유저 인터페이스
대부분의 운영체제는 UI를 가지고 있다. 이 인터페이스는 몇가지 형태가 있다. 보통은, GUI가 사용된다. 마우스로 무언가를 가르키고 키보드로 텍스트를 입력한다. 모바일 시스템은 터치-스크린 인터페이스를 제공해서 손가락으로 버튼을 누른다. 다른 방법은 comman-line-interface로, 텍스트 커맨드와 그들을 입력하는 방법이다. 몇몇은 이 3가지를 모두 지원한다.

- 프로그램 실행
시스템은 메모리에서 프로그램을 불러와서 프로그램을 실행한다. 프로그램은 반드시 실행을 정상이든 비정상으로 끝내야한다.

- I/O operations
작동중인 프로그램은 파일이나 I/O 디바이스와 같은 I/O가 필요하다. 특정 장비를 위해서, 특별한 함수가 필요하다. 효율성과 보호를 위해서, 유저는 보통 I/O 디바이스를 직접 통제할 수 없다. 그러므로 운영체제는 반드시 I/O를 제공해야한다.

- 파일시스템 조작

파일 시스템은 특정한 관심이다. 명백하게, 프로그램은 디렉토리와 파일을 읽고 쓸 수 있어야한다. 그들은 또한 주어진 파일을 찾거나, 그들의 이름으로 삭제하거나 생성할 수 있어야한다. 마지막으로는, 몇몇 운영체제들은 디렉토리나 파일에 그들의 소유권에 기반해서 접근을 거부하거나 승낙할 수 있어야한다. 많은 운영체제들은 다양한 파일 시스템을 제공하고, 때때로는 개인적 선택을 승낙하고 특정 기능이나 성능 특성을 제공한다.

- 통신

프로세스가 다른 프로세스와 정보를 교환해야하는 많은 상황이 있다. 이런 통신은 같은 컴퓨터에서 실행중인 프로세스간에 생기거나  네트워크로 묶인 다른 컴퓨터 시스템에서 일어난다. 통신은 같은 메모리 영역의 **공유 메모리**를 통해서 일어나거나, 미리 정의된 포멧의 정보 패킷이 운영체제를 통해서 움직이는 **메시지 패싱**이 가능하다.

- 에러 감지
운영체제는 에러를 지속적으로 감지하고 조정한다. 에러들은 CPU와 메모리 하드웨어, I/O 디바이스(용지부족, 네트워크 연결 실패, 디스크에서의 패리티 에러), 유저프로그램에서 생길 수 있다. 이런 각각의 에러의 종류는, 운영체제가 반드시 적절한 액션을 취해서 정확하고 일정한 컴퓨팅을 하게 돕는다. 가끔, 시스템 정지외의 방법이 없을 때가 있다. 다른 때에는, 그것은 에러를 일으키는 프로세스를 종료하거나 프로세스 에러코드를 리턴해서 프로세스를 감지하고 고치려고 한다.

운영체제 기능의 다른 세트는 유저보다는 시스템 자체의 효율적인 명령을 보장해준다. 다양한 프로세서를 가진 시스템들은 컴퓨터 리소스를 프로세스간에 나누면서 효율성을 얻었다.

- 리소스 할당

동시에 많은 프로세스가 작동하면, 리소스들은 반드시 각각에게 할당되어야한다. 운영체제는 다양한 리소스를 관리한다. 몇몇(CPU 사이클, 메인메모리, 파일 저장소)는 특별한 할당 코드가 필요한데 비해서, 몇몇(I/O 디바이스)는 일반적인 요청과 릴리즈 코드가 있을 것이다. 예를 들어서, CPU를 가장 최고로 사용하는 것을 정하는 방법은, 운영체제가 CPU의 속도, 실행되어야만하는 프로세스, CPU 위의 프로세싱 코어 같은 CPU스케쥴링 루틴을 가지는 것이다. 그리고 프린터, 유에스비, 주변장치를 할당하는 많은 루틴이 있다.

- 로깅

우리는 어떤 프로그램이 얼마나 많고 다양한 컴퓨터 리소스를 사용하는지 추적해야한다. 이런 기록은 회계로 사용되거나 사용 통계를 누적한다. 사용통계는 컴퓨터 서비스 향상을 위해 시스템을 변경할 시스템 관리자에게 귀중한 도구이다.

- 보호와 보안 

멀티 유저와 네트워크속의 컴퓨터 시스템에 저장된 정보의 소유자는 정보의 사용을 제어하고 싶다. 몇몇 프로세스가 동시에 실행될 때, 그것은 하나가 다른 것에 의해서 방해되는 것은 불가능해야한다. 보호는 시스템 리소스로 부터의 모든 접근이 통제되는 것이다. 외부인으로부터의 시스템의 보안은 또한 중요하다. 이런 보안은 각각의 유저가 시스템에게 자신을 자신이라고 입증하는 것이다. 외부 I/O 디바이스, 네트워크 어댑터를 불분명한 접근과 녹음으로 보호하는 것으로 확장되기도 한다. 만약 시스템이 보호되고 보안되면, 경고는 그것을 통해서 생긴다. 체인은 또한 가장 약한 링크만큼 강하다.

## 2.2 User and Operating System Interface

우리는 운영체제 시스템과 유저가 연결되는 인터페이스에 대해서 언급한 적이 있다. 여기서, 우리는 3가지 기초적인 접근이 있다. 하나는 CLI, **command interpreter**, 유저가 커맨드를 운영체제에 직접 입력하는 방법이다. 다른 두가지 방법은 유저가 GUI를 통해서 운영체제와 연결되는 인터페이스이다.

### 2.2.1 커맨드 인터프리터

리눅스, 유닉스, 윈도우를 포함한 대부분의 운영체제는 프로세스가 실행되거나 유저가 로그인 했을 떄 커맨드 인터프리터를 특별한 프로그램을 제공한다. 예를 들어 유닉스와 리눅스 시스템에서, 유저는 C-shell, Bourne-Again shell, Korn shell이라는 다양한 쉘을 제공한다. 서드 파티 쉘과 유저가 만든 쉘또한 존재한다. 대부분의 쉘들은 비슷한 기능을 제공하고 유저의 기호에 따라서 선택된다.

커맨드 인터프리터의 주요한 함수는 유저가 지정한 커맨드를 얻어내고 실행한다. 많은 커맨드는 이런 수준으로 제공된다. : 삭제, 리스트, 생성, 프린트, 카피, 실행 등등이다. 유닉스 시스템에서 실행가능한 다양한 유닉스 시스템은 이런 방식으로 실행된다. 이런 커맨드들은 두가지 방법으로 실행된다.

한가지 접근은, 커맨드 인터프리터는 그 자체로 커맨드를 실행시키는 코드를 포함하고 있다. 예를 들어, 파일을 삭제하는 커맨드는 커맨드 인터프리터가 그것의 코드 구역을 이동해서 파라미터를 결정한 후에 적절한 시스템 콜을 부른다. 이런 경우에는, 많은 수의 커맨드는 커맨드 인터프리터의 사이즈를 결정하기에 커맨드는 그것의 실행 코드를 필요로 한다.

다른 접근은, 유닉스에서 쓰이는데, 커맨드를 시스템 프로그램으로 실행한다. 이런 경우에는 커맨드 인터프리터는 커맨드를 이해하는 것이 아니다. 그것은 커맨드를 메모리에서 부를 파일을 인식하고 실행하는 것이다. 따라서 유닉스가 파일을 지우게 하는 것이다.

rm file.txt는 rm이라는 파일을 찾게하고 파일을 메모리에서 부르고 그것의 파라미터를 file.txt로 한다. rm 코맨드와 관련된 논리는 file rm에 있는 코드에서 확실히 정의된다. 이런 방식으로, 프로그래머들은 새로운 파일을 만들고 적적한 프로그램 로직을 만듬으로서 쉽게 새로운 커맨드를 시스템에 추가한다. 커맨드 인터프리터 프로그ㅐㄻ은 매우 작지만, 새로운 커맨드 추가를 위해서 바뀔필요는 없다.

### 2.2.2 GUI

운영체제가 사용자와 인터페이싱하는 두번째 방법은 우리가 친숙하게 사용하는 GUI이다. 커맨드를 CLI로 직접치는 것보다는, 유저는 마우스 기반의 윈도우와 메뉴 시스템을 사용하는 것이다. 유저는 마우스를 이미지의 포인트로 옮긴다. 그리고 그 이미지들은 프로그램, 파일, 디렉토리, 시스템 함수 등이 있다. 마우스 포인터의 위치에 따라서, 마우스 버튼을 클릭하는 것은 프로그램을 깨우고, 파일이나 디렉토리를 고르고 커맨드를 포함한 메뉴를 내린다.

GUI는 1970년도에 제록스 PARC 연구소에서 처음 나타났다. 첫번째 GUI는 제록스 알토 컴퓨터였다. 그러나 그래픽 인터페이스는 애플의 메킨토시 컴퓨터와 함께 급진했다. 매킨토시 운영체제의 유저 인터페이스는 다양한 변화를 다년간 겪었고, 가장 큰 변화는 맥OS의 아쿠아 인터페이스이다. MS사의 첫 윈도우는 MS-DOS 운영체제의 GUI 추가버전이다. 그 후에 윈도우는 그것의 기능성을 향상시키면서 GUI의 모습을 변화시켰다. 전통적으로, 유닉스 시스템은 CLI에 의해서 지배되었다. 다양한 GUI 인터페이스는 존재하나, GUI 디자인은 오픈소스에 의해서 큰 영향을 받았다.

### 2.2.3 터치 스크린 인터페이스

CLI와 마우스 키보드 시스템이 모바일에서는 불편해서 스마트폰과 태블릿컴퓨터는 터치 스크린을 택하게되었다. 유저는 터치스크린의 행동으로 소통한다. 비록 초기의 스마트폰은 물리적 키보드를 지원했지만 이제는 키보드는 보통 터치스크린 위에서 실행된다.

### 2.2.4 인터페이스의 선택

GUI를 쓸지, CLI를 쓸지는 컴퓨터를 사용하는 사람의 개인 선호에 따라 달린다. 컴퓨터를 관리하는 시스템 어드민과 시스템을 깊게 이해하는 파워유저는 CLI를 선호한다. 그들에게는 이것이 더욱 효율적이고 원하는 행동에 대한 더 빠른 접근을 주기 때문이다. 실제로, 시스템위에서 오직 시스템 함수의 하위세트는 GUI를 통해서만 되고 나머지는 CL 지식에 맡겨둔다. 더 나아가, CLI는 보통 반복적인 행동을 쉽게하고, 몇몇 부분에서는 그들의 프로그래머빌리티를 가진다. 예를 들어 반복되는 동작들은 일련의 command line step이 필요한데, 이런 step은 파일에 저장될 수 있고, 파일은 프로그램처럼 돌아갈 수 있다. 프로그램은 실행코드로만 컴파일 되지 않고 CLI에 의해서 해석된다. 이런 쉘 스크립트들은 보통 시스템에서 일반적이다.

반면에 대부분의 윈도우 유저들은 윈도우 GUI 유저들에게 행복을 주고 대부분이 절대 쉘 인터페이스를 사용하지 않는다. 최근 버전의 윈도우 운영체제 버전은 데스크탑을 위한 GUI와 태블릿을 위한 터치 스크린을 제공한다. 이런 다양한 변화는 매킨토시 운영체제가 좋은 연구를 보여주었기 때문이다. 역사적으로, MacOs는 CLI를 제공하지 않았고 오직 GUI만을 사용하게했다. 그러나 macOS의 출시와 함께 운영체제는 아쿠아 GUI와 CLI를 모두 제공했다.

비록 CLI를 제공하는 IOS와 안드로이드 시스템이 있지만, 그들은 거의 사용되지 않는다. 대신에 대부분의 유저들은 터치스크린을 이용한다.

유저 인터페이스는 시스템마다 다르고 같은 시스템에서도 유저마다 다르다. 그러나 실제 시스템 구조는 점점 사라지고 있다. 유용하고 직관적인 유저인터페이스의 운영체제 의 직접적인 함수는 아니다. 이 책에서는 적절한 서비스를 제공하는 근본적인 문제에 집중하겠다. 운영체제의 여러가지 관점에서, 우리는 유저 프로그램과 시스템 프로그램을 구별하지 않는다.

## 2.3 시스템 콜

**시스템 콜**은 운영체제에 의해서 서비스를 제공하는 인터페이스를 만들어주게한다. 이런 콜들은 보통 C언어나 C++로 쓰여있고, 낮은 레벨의 일(예를 들어, 하드웨어가 직접 연결된 것이다.)은 어셈블리어 명령어로 쓰여있다.

### 2.3.1 예시

운영체제가 시스템콜을 가능하게 만드는 것을 논의하기 이전에, 먼저 어떻게 시스템 콜이 사용되는지 생각해보자 : 하나의 파일로부터 데이터를 읽고 다른 파일로부터 복사하는 프로그램을 만들겠다. 먼저 프로그램이 필요로하는 인풋은 두가지이다.(인풋파일과 아웃풋 파일) 이런 이름들은 많은 방식으로 되어있고, 운영체제 디자인에 따라 다르다. 두파일의 이름은 커맨드에 전달하는 한가지 방법이다.

cp in.txt out.txt

이러한 커맨드들은 인풋 파일 in.txt를 아웃풋 파일 ou.txt로 카피한다. 두번쨰 방법은 프로그램이 유저에게 이름을 묻는 것이다. 반응형 시스템에서, 이런 접근은 시스템콜의 일련을 필요로하고, 처음으로는 프롬프팅 메시지를 작성하고 키보드로부터 두 파일을 읽어들인다. 마우스와 아이콘 베이스의 시스템에서는, 파일 이름의 메뉴는 윈도우에서 보여진다. 유저는 소스 이름을 선택하기 위해서 마우스를 선택하고, 윈도우는 정해진 도착 윈도우에 의해서 열린다. 이런 시퀀스는 많은 I/O 시스템 콜을 필요로 한다. 

두 파일 이름이 얻어지면, 프로그램은 반드시 인풋 파일을 열고 아웃풋 파일을 생성하고 열어낸다. 각각의 명령은 다른 시스템 콜이 필요하다. 각각의 시스템에 예상되는 에러는 조정되어야한다. 예를 들어서, 프로그램이 인풋 파일을 열려고하면, 그것은 그곳에 파일이 없는지 찾아내야하고 접근으로부터 파일이 보호되어있을수 있다. 이러한 경우에 프로그램은 에러메시지를 내보내야하고 비정상적인 종료를 한다. 만약 인풋이 존재하면 , 우리는 반드시 새로운 아웃풋 파일을 만들어내야한다. 우리는 아웃풋 파일이 같은 이름으로 존재하는 것을 볼수도 있다. 이런상황은 프로그램이 멈추게 할 수도있고 존재하는 파일을 지우고 새로운 파일을 만들수도있다. 인터렉티브 시스템에서는 유저에게 파일을 교체할지 프로그램을 멈출기 물어볼 수 도있다.

두 파일이 준비되면, 우리는 인풋 파일로 부터 루프를 입력하고 아웃풋 파일을 쓰기시작한다. 각각의 읽기와 쓰기는 가능한 에러 컨티션을 위해서 상태 정보를 리턴해야한다. 인풋에서는, 프로그램은 파일의 끝에 도달하거나 읽기에서 하드웨어 페일이 나온다. 쓰기에서는, 다양한 에러가 아웃풋 디바이스에서 일어날 수 있다.

마지막으로, 전체 파일이 복사되면, 프로그램은 두 파일을 모두 닫고, 콘솔이나 윈도우에 메시지를 쓰고 마침내 정상적으로 종료된다.

### 2.3.2 애플리케이션 프로그래밍 인터페이스

말햇듯이, 간단한 프로그램은 운영체제의 무거운 사용을 만들 수 있다. 자주, 시스템은 일초마다 수천만가지의 시스템 콜을 생성한다. 대부분의 프로그래머들은 이러한 자세한 사항을 살피지 않는다. 보통, 앱 개발자는 API에 따라서 프로그램을 디자인한다. API는 애플리케이션 프로그래머가 사용가능한 다양한 함수를 제공한다. 이 함수들은 각각의 함수의 파라미터를 포함하고 프로그래머가 예상하는 리턴값을 돌려준다. 대부분의 API에서는 윈도우 시스템을 위한 윈도우 API이다.(포식스는 포식스API)) 자바 API는 자바 가상머신에서 돌아간다. 씨로 쓰여진 유닉스와 리눅스 프로그램은 libc라고 불린다. 이런 시스템 콜 이름은 일반적인 예시이다. 각각의 운영체제는 각각의 시스템콜 이름이 있다. 화면뒤에서, API를 만드는 함수는 앱 프로그래머 입장에서 시스템콜을 만들어낸다. 예를들어 윈도우 함수 CreateProcess()는 실제로 NTCreateProcess() 시스템콜을 윈도우 커널에서 불러들인다. 

앱 프로그래머가 시스템 콜보다 API를 부르는 이유가 무엇일까? 한가지 장점은 프로그램 휴대성이다. 프로그램을 디자인하는 앱 프로그래머는 그녀의 프로그램이 어떤 시스템이든 같은 API에서는 그녀의 프로그램이 실행되고 컴파일되기를 원한다. 더욱이 실제의 시스템콜은 보통 API더 힘들게 만든다. 그럼에도 불구하고, API와 커널의 시스템 콜에서는 강력한 관련점이 있다. 실제로, 많은 포식스와 윈도우 API는 유닉스, 리눅스, 윈도우가 제공하는 네이티브 시스템 콜과 배우 유사하다.

다른 핸들링 시스템 콜의 중요한 요소는 **런타임 환경**이다- 주어진 언어로 애플리케이션을 실행하는데 필요한 컴파일러와 인터프리터나 라이브러리나 로더 같은 소프트웨어 모음이다. RTE는 운영체제에서 시스템콜을 만드는 링크를 시스템콜 인터페이스에 제공한다. 시스템 콜 인터페이스는 API에서 함수를 뺏고 운영체제에서 필요한 시스템콜을 실행한다. 특히, 다양한 것들이 각각의 시스템콜과 연관되어있고 시스템콜 인터페이스는 이런 넘버에 따른 테이블 인덱스를 유지한다. 시스템 콜 인터페이스는 운영체제 커널안에서 의도된 시스템 콜을 실행하고 시스템콜의 상태를 반환한다.

콜러는 어떻게 시스템콜이 작동되고 어떤 일을 하는지 전혀 모른다. 오히려 콜러는 API에 복종하고 운영체제가 시스템콜의 실행의 결과를 받아들인다. 그러므로 대부분의 운영체제 인터페이스는 API로부터 프로그래머에게 숨어있고 RTE에 의해서 관리된다. 

시스템 콜은 다양한 방식에서 일어나고 컴퓨터 사용에 따라 달린다. 보통, 정보는 소망된 시스템콜의 정보보다 많이 필요로한다. 정확한 타입과 정보의 양은 특정한 운영체제와 시스템콜에 따라서 달라진다. 예를 들어서 인풋을 얻기위해서, 우리는 파일 또는 장치 소스를 특정화하고 읽혀야하는 인풋의 메모리 버퍼의 길이와 주소를 필요로한다. 물론 디바이스나 파일과 길이는 내부 콜에서 정확해야한다. 

운영체제에서는 파라미터를 전달하는 3가지 일반적인 방법론이 존재한다. 가장 간단한 방법은 레지스터를 통해서 파라미터를 넘기는 것이다. 몇가지 경우에는 물론 레지스터보다 파라미터가 더 많다. 이런 경우에는, 파라미터는 블록이나 테이블, 메모리에 저장되고 레지스터에는 파라미터의 주소가 저장된다. 리눅스는 이런 방법의 조합을 사용한다. 만약 5개나 적인 파라미터가 있으면, 레지스터가 사용된다. 아니라면 블록 메서드가 사용된다. 파라미터는 운영체제에서 프로그램 유저에 의해서 스택에서 푸시되거나 운영체제에 의해서 팝된다. 몇몇 운영체제는 블럭이나 스택 방법을 더 선호하는데 이런 방법은 파라미터의 갯수에 제한이 없기 떄문이다.

### 2.3.3 시스템 콜의 종류

시스템 콜은 6가지의 메이저 카테고리로 그룹된다 : 프로세스 컨트롤, 파일 관리, 디바이스 관리, 정보 유지, 통신, 보호가 있다. 우리는 운영체제에 의해서 제공되는 여러가지 타입의 시스템 콜을 논의하겠다. 대부분의 시스템 콜은 뒷 챕터에 나올 개념들을 서포트하거나 서포트 받는다. 이 책에서 말했듯이, 우리는 시스템콜을 제너릭한 이름으로 부르겠다. 이책에서 우리는 유닉스, 리눅스, 윈도우에 상응하는 실제 예시도 제공하겠다.

> Porcess Control
> - Create process, terminate process
> - 로드, 실행
> - 프로세스 성질 얻기 혹은 설정
> - 이벤트를 기다리거나 시그널
> - 메모리 할당 및 해제
> File management
> - 파일 생성, 삭제
> - 열기, 닫기
> - 읽기, 쓰기, 재위치
> - 파일 성질 얻기, 설정
> 디바이스 관리
> - 디바이스 호출, 해제
> - 읽기, 쓰기, 재위치
> - 디바이스 성질 얻기, 설정
> 정보 유지
> - 시간 혹은 날짜 얻기, 설정
> - 시스템 데이터 얻기, 설정
> - 프로세스, 파일, 디바이스 성질 얻기
> - 프로세스, 파일, 디바이스 성질 설정
> 통신
> - 통신 연결 생성, 삭제
> - 메시지 보내기, 받기
> - 상태 정보 전이
> - 먼 디바이스 부착 및 해제
> 보호
> - 파일 허가 얻기
> - 파일 허가 설정

#### 2.3.3.1 프로세스 컨트롤

실행중인 프로그램은 그것의 실행을 정상적(end()) 또는 비정상적(abort())로 멈출 필요가 있다. 만약 시스템 콜이 현재의 프로그램을 비정상적으로 종료하거나, 만약 프로그램이 문제에 진입하고 에러 트랩을 야기하면 버려진 메모리는 사라지고 에러메시지가 생성된다. 이 버려진 메모리는 디스크의 특별한 로그파일에 쓰이거나 에러 원인을 찾기 위해서 디버거(프로그래머가 에러를 찾거나 고치는 것을 돕는 시스템 프로그램)에 의해서 측정된다. 이런 정상 또는 비정상적인 상황속에서, 운영체제는 반드시 커맨드 인터프리터 발생으로 컨트롤을 옮겨야한다. 이런 커맨드 인터프리터는 다음 커맨드를 읽는다. 상호적인 시스템에서, 커맨드 인터프리터는 간단하게 다음 커맨드를 진행한다. 그것은 유저가 에러에 따라 유저가 다음 커맨드를 입력할 것을 예상하기 때문이다. GUI 시스템에서는, 팝업 윈도우가 에러를 유저에게 알리고 가이드를 제공한다. 몇몇 시스템은 에러가 생긴 시점에 특별한 리커버리 액션을 허용한다. 만약 프로그램이 에러를 그것의 인풋에서 찾으면 비정상 종료를 원하는데, 그것은 에러 레벨을 또한 정의하기를 원한다. 더 심각한 에러는 높은 레벨 에러 파라미터를 가르킬 수도 있다. 정상과 비정상 종료를 정상 종료를 에러 레벨 0으로 설정함으로서 합쳐서 사용할 수 있다. 커맨드 인터프리터나 따라오는 프로그램은 에러레벨을 다음 행동을 자동으로 실행하기 위해서 사용할 수도 있다.

한프로그램을 싱행하는 프로세스는 다른 프로그램을 loag()와 excute()하고 싶을 수도 있다. 이런 기능은 커맨드 인터프리터가 지시하는 프로그램을 실행하는 것을 허용한다. 예를 들어서, 유저 커맨드 또는 마우스의 클릭이다. 흥미로운 질문은 로드된 프로그램이 종료될때 어디에 컨트롤을 리턴하는 것이다. 이 질문은 존재하는 프로그램이 사라지거나 저장되었거나 새로운 프로그램이 동시에 실행될때 관련되어 있다.

만약 존재하는 프로그램에 컨트롤이 리턴되면 새로운 프로그램은 종료되고, 우리는 반드시 존재하는 프로그램의 메모리 이미지를 저장해야한다. 그러므로 우리는 한개의 프로그램이 다른 프로그램을 부르는 메커니즘을 효과적으로 만들 수 있다. 만약 두개의 프로그램이 동시에 지속되면, 우리는 새로운 프로세스를 멀티프로그램을 위해서 생성한다. 자주, 시스템 콜은 이목적을 위해서 생성된다.(create_process)

만약 우리가 새로운 프로세스를 만들면, 우리는 그것의 실행을 컨트롤할 수 있다. 이런 컨트롤은 프로세서의 성질을 결정하거나 리셋할 수 있다.(프로세스 우선권, 그것의 맥시멈 실행시간 등등(get_process_attributes() and set_process_attributes())). 우리는 우리가 만든 프로세스를 종료하고 싶을수도 있다.(terminate_process()) 만약에 우리가 그것이 잘못되었거나 더이상 필요없다면.

새로운 프로세스를 만드는 것에서, 우리는 그들의 실행을 끝낼때까지 기다릴 필요가 있다. 우리는 특정 양의 시간을 기다리는 것을 원할 수도 있다.(wait_time()) 더 가능성 있는 것은, 우리는 특별한 이벤트가 일어나는 것을 기다릴 수도 있다.(wait_event()) 프로세스들은 만드시 이벤트가 일어났을때, 시그널을 보내야한다.(signal_event())

더 자주, 두개 또는 더많은 프로세스는 데이터를 공유한다. 공유되는 데이터의 순결성을 확정하기 위해서, 운영체제는 공유데이터를 잠구는 시스템콜을 프로세서에게 허용해야한다. 그러면 다른 프로세스들은 락이 풀리기 전에 데이터에 접근할 수 없다. 보통, 이런 시스템은 *acquire_lock()*과 *release_lock()*을 포함한다. 이런 타입의 시스템 콜은 동시 실행되는 프로세스와 얘기하고, 챕터 6과 7에서 설명될 것이다.

우리가 다음에 사용할 두 예제의 프로세스 컨트롤은 다양한 측면과 베리에이션이 있다. 싱글 태스킹 시스템과 멀티 태스킹 시스템이다. 이 개념을 명료화하겠다. 아두이노는 마이크로 컨트롤러를 인풋 센서로 포함하는 간단한 하드웨어 플랫폼이다. 인풋 센서는 불빛, 온도, 기압변화의 변화에 반응한다. 아두이노 프로그램을 작성하기위해서, 우리는 PC에 프로그램을 작성하고 PC에서 아두이노 플래시 메모리에 USB를 통해서 컴파일된 프로그램을 작성한다. 대신에, 부트로더로 불리는 작은 소프트웨어는 스케치를 아두이노 메모리의 특별한 지역에 로드한다. 스케치가 로드되면, 그것은 실행을 시작하고, 프로그램된 이벤트가 반응하기를 기다린다. 예를 들어, 만약에 아두이노의 온도 센서가 쓰레시홀드 온도를 넘기면, 스케치는 아두이노를 시작해서 팬을 돌린다. 아두이노는 한가지 일을 하는 시스템이다. 하나의 스케치만이 동시간에 메모리에 존재하기 때문이다. 만약 다른 스케치가 로드되면, 그것은 존재하는 스케치로 교체된다. 더욱이, 아두이노는 하드웨어 인풋 센서 사이에서 아무런 유저 인터페이스를 제공하지 않는다.

FreeBSD(berkeley UNIX에서 만들어짐)는 멀티태스킹 시스템의 예시이다. 유저가 시스템에 로그온하면, 유저가 선택한 쉘은 실행되고 커맨드를 기다리고 유저 요청에따라 프로그램을 실행한다. 그러나 FreeBSD가 멀티태승킹 시스템이어서, 커맨드 인터프리터는 다른 프로그램이 실행될때도 계속 실행한다. 새로운 프로세스를 시작하려면, 쉘은 fork() 시스템콜을 실행한다. 그러면 exec() 시스템콜을 통해 선택된 프로그램이 메모리에 로드된다. 그렇게 프로그램은 실행된다. 커맨드에서 어떻게 생겨났냐에 따라서, 쉘은 프로세스가 끝나는 것을 기다리거나 프로세스가 백그라운드에서 실행된다. 후자의 경우에는 쉘은 다른 커맨드를 당장 입력되기를 기다린다. 프로세스가 백그라운드에서 실행중이면, 그것은 키보드로부터 직접 인풋을 받을 수 없다. 왜냐하면 쉘은 이 리소스를 이미 사용하기 때문이다. I/O는 따라서 파일 또는 GUI를 통해서 실행된다. 반면에, 유저는 쉘에게 다른 프로그램 실행을 마음껏 물을 수 있고, 실행중인 프로세스의 진척을 볼수 있고, 프로그램의 우선도를 바꿀수 있다. 프로세스가 다하면, 그것은 exit() 시스템콜을 종료하기 위해서 실행하고 프로세스 상태를 0또는 0이아닌 에러코드로 리턴한다. 이런 상태나 에러코드는 쉘또는 다른 프로그램에 존재하게 된다. 프로세스는 3장에서 논의되고 fork와 exec를 사용하는 예시를 보이겠다.

#### 2.3.3.2 파일 관리

파일 시스템은 13장에서 15장에서 자세히 다룰 것이다. 여기서는 우리는 몇가지 파일을 다루는 시스템콜을 구분하겠다.

우리는 먼저 create()와 delete() 파일을 필요로한다. 두 시스템은 파일의 이름 또는 파일의 성질또한 필요로할 것이다. 한번 파일이 생성되면, 우리는 사용하려면 open()을 필요로한다. 우리는 또한 read(), write(), reposition()(파일의 끝을 스킵하거나 리와인드한다.)또한 필요할 것이다. 마침내 사용을 다했을떄, 우리는 close() 파일을 실행한다.

우리는 만약 파일 시스템에서 디렉토리 구조를 가진다면 몇몇 디렉토리 명령어 또한 필요로 한다. 덧붙여서, 파일 또는 디렉토리 둘다, 우리는 다양한 성질의 값을 결정하고 필요하다면 그들을 설정한다. 파일 설정은 파일 이름, 파일 타입, 보호 코드, 정보 등등이 필요하다. 적어도 두 시스템 콜, get_file_attributes()와 set_file_attributes()는 이런 함수가 필요하다. 몇몇 운영체제는 더 많은 콜을 제공한다. 이런 콜은 파일이 move()와 copy가 있다. 다른 것은 API가 이런 명령어를 사용해서 우리의 일을 돕는다. 만약 시스템 프로그램이 다른 프로그램에 의해서 불려지면, 각각은 다른 시스템 프로그램에서 API 취급 받는다.

#### 2.3.3.3 디바이스 관리

프로세스는 메인 메모리, 디스크 드라이브, 파일 접근 등 다양한 리소스가 실행되기 위해서 필요하다. 만약 리소스가 존재한다면, 그들은 반드시 보장되어야하고 컨트롤은 유저 프로세스에 리턴되어야한다. 다른 경우에, 프로세스는 충분한 리소스가 존재할때까지 기다려야할 것이다. 운영체제에 의해서 통제되는 다양한 리소스는 디바이스라고 생각할 수 있다. 몇몇 디바이스는 물리 장치(디스크 드라이버)일 것이고, 나머지는 추상적이고 가상 디바이스(파일)일 것이다. 여러 유저를 가진 시스템은 먼저 우리에게 request()로 그것을 독점적으로 사용할 수 있을 지 물어야한다. 우리가 디바이스를 모두 사용하면 realease()를 해준다. 이런 함수는 파일 시스템 콜인 open()과 close()와 비슷하다. 다른 운영체제에서는 디바이스 접근을 관리안할수도 있다. 그 위험은 디바이스 논쟁 위험과 데드락을 만들어낼 수 있다.

디바이스가 요청되면, 우리는 read(), writ- e(), reposition() 디바이스를 할수있다. 사실은 I/O device와 파일은 공통점이 많은 운영체제에서 존재한다. 유닉스같은 곳에서는 두개가 합쳐져있기도하다. 이런 경우에는 시스템콜은 파일과 디바이스에 사용된다. 가끔은, I/O 디바이스는 특별한 파일 이름, 디렉토리, 파일 성질에 따라 구별된다.

유저 인터페이스는 파일을 만들고 디바이스는 존재하는 시스템콜이 달라도 비슷하게 나타난다. 이런 예시는 운영체제와 유저 인터페이스의 많은 디자인에 따라서 달라진다.

#### 2.3.3.4 정보 유지

많은 시스템 콜은 유저 프로그램과 운영체제 간에 정보를 주고받기위해서 존재한다. 예를 들어 대부분의 시스템은 현재의 시간과 날짜를 리턴하는 시스템콜이 있다. 다른 시스템 콜은 운영체제의 버전 넘버, 디스크와 메모리의 여유공간양 같은 시스템에 관련된 정보를 리턴한다. 

다른 시스템 콜은 프로그램 디버깅에 도움이 된다. 많은 시스템들은 dump() memory라는 시스템 콜을 제공한다. 이 영역은 디버깅에 도움이 된다. 프로그램 *strace*는 리눅스 시스템에서 존재하고, 시스템콜이 실행될때마다 리스트된다. 마이크로 프로세서가 CPU 모드를 한단계로 제공해도, 트랩은 모든 명령이 끝나고 CPU에 의해서 실행된다. 트랩은 디버거에 의해서 보통 잡힌다.

많은 운영체제는 프로그램이 어떤 장소에서 얼마나 실행되었는지 알려주는 프로그램의 시간 프로필을 제공한다. 시간 프로필은 시설을 따르거나 일바넉인 시간 인터럽트를 필요로한다. 각각의 타이머 인터럽트 실행에서, 프로그램 카운터의 값은 저장된다. 충분히 빈번한 타이머 인터럽트와 함께, 시간의 통계적인 그림은 프로그램의 다양한 부분을 얻어준다.

덧붙여서, 운영체제는 그것의 프로세스 정보를 모두 가지고, 시스템 콜은 이정보에 접근하는데 사용한다. 보통, 시스테 콜은 프로세스 정보를 얻거나 설정한다.(get_process_attributes() and set_process_attributes()) 3.13절에서 우리는 어떤 정보가 저장되는지 논의하겠다.

#### 2.3.3.5 통신

프로세스간에 두가지 통신 모델이 존재한다. 하나는 메시지 패싱 모델과 하나는 공유 메모리 모델이다. 메시지 패싱 모델에서, 프로세스간 통신은 메시지를 프로세스 간에 교환한다. 메시지는 공통 메일함을 통해서 프로세스간에 직접 또는 간접으로 교환할 수 있다. 통신이 생기기전에, 연결이 열려야한다. 다른 통신자의 이름을 반드시 알아야하고, 같은 시스템의 다른 프로세서나 다른 컴퓨터의 프로세스는 통신 네트워크로 연결되어야한다 네트워크안의 각각의 컴퓨터는 호스트 이름을 가지고 있다. 호스트는 IP같은 네트워크 구별자를 가져야한다. 비슷하게 각각의 프로세스는 프로세스 이름을 가져야하고 운영체제가 프로세스를 언급하는 것에 다라서 이 이름을 구별자로 번역해야한다. get_hostid()와 get_processid() 시스템 콜이 이러한 번역을 진행한다. 구별자는 보통 open()과 close() 콜 같은 일반적인 목적으로 전해지고 open_connection()과 close_connection() 시스템 콜이라는 특별한 것으로 시스템의 통신 모델에 따라 달라진다. 프로세스의 수신자는 보통 통신을 위한 허가를 accept_connectioin()콜을 통해서 얻는다. 대부분의 프로세스들은 특정 목적 daemons로 연결을 얻고, 시스템 프로그램은 그 목적으로 제공된다. 그들은 wait_for_connection() 콜과 연결이 만들어졌을때 깨워진다. 커뮤니케이션의 소스는 클라이언트이고 그것은 recieving damon이라고 불리는 서버이고 read_message()와 write_message() system 콜로 메시지를 주고받는다. 그리고 close_connection()콜로 통신을 종료한다.

#### 2.3.3.6 보호

보호는 컴퓨터 시스템이 리소스 접근을 컨트롤하는 메커니즘으로 제공한다. 역사적으로, 보호는 오직 여러 유저에 의해서 멀티프로그램된 컴퓨터 시스템에서만 고려된다. 그러나 네트워킹과 인터넷의 발전으로, 모든 컴퓨터 시스템은 이 보호가 필요해졌다.

보통, 보호를 제공하는 시스템콜은 set_permisiion()과 get_permission이 있고, 파일과 디스크 같은 리소스 허용 설정을 조절한다. allow_user()와 deny_user() 시스템 콜은 특정 유저가 리소스에 접근할지 말지를 허용한다. 우리는 이런 내용을 보안이라는 더 큰 주제에서 다루도록 하겠다.

## 2.4 시스템 서비스

현대 시스템의 다른 점은 서비스 시스템의 모음이다. 가장 낮은 단계는 하드웨어이다. 그리고 운영체제이고 시스템 서비스, 마지막으로 애플리케이션 프로그램이다. 시스템 서비스는 시스템 유틸리티라고 알려져있고, 프로그램 개발과 실행에 편한 환경을 제공한다. 그들중 몇가지는 간단하게 유저 인터페이스 시스템 콜이다. 다른 것들은 훨씬 복잡하고 여러가지 분야로 나뉠수 있다.

- 파일 관리 : 이런 프로그램은 만들고 삭제하고 복사하고 재정의하고 출력하고 리스트로 만들고 파일과 디렉토리를 관리하고 접근하게한다.

- 상태 정보 : 몇몇 프로그램은 시스템에게 날짜, 시간, 사용가능한 메모리 또는 디스크 공간, 유저의 수, 상태 정보를 묻는다. 다른 것들은 복잡한데, 정확한 성능, 로깅, 디버깅 정보를 제공한다. 보통 이런 프로그램들은 터미널, 파일, GUI를 통해 아웃풋으로 내보내진다. 몇몇 시스템은 레지스트리를 지원하는데, 레지스트리는 환경설정 정보를 저장하고 불러온다.

- 파일 수정 : 몇몇 텍스트 에디터는 디스크나 저장장치에 저장된 파일을 만들거나 수정하는 것이 가능하게한다. 파일을 검색하거나 텍스트의 변형을 수행하는 특별한 커맨드이다.

- 프로그램 언어 지원 : 컴파일러, 어셈블러, 디버거, 프로그램 언어 인터프리터들은 운영체제와 함께 제공되거나 별도의 다운로드로 제공된다.

- 프로그램 로딩과 실행 : 프로그램이 만들어지고 컴파일 되면 그것은 메모리에서 로드되어 실행한다. 그 시스템은 절대적인 로더나 새롭게 위치하는 로더나 링키지 에디터, 오버레이 로더를 제공한다. 높은 수준 언어나 기계어도 디버깅 시스템이 필요하다.

- 통신 : 이런 프로그램은 프로세스, 유저, 컴퓨터 시스템을 가상으로 연결하는 메커니즘을 제공한다. 그들은 유저가 다른이의 스크린에 메시지를 보내게 도와주고, 웹페이지를 탐색하고, 이메일을 보내고, 다른 기계나 다른 사람의 파일을 멀리서 접근하게 해준다.

- 백그라운드 서비스 : 모든 시스템은 특정 시스템 프로그램 프로세스를 부트중에 런칭하는 방법이 있다. 이런 프로세스들은 그들의 작업이 완료되면 사라지고, 다른 것들은 시스템이 멈출때까지 실행한다. 영구적으로 시스템 프로그램 프로세스를 실행하는 것은 서비스, 서브시스템, 다이몬이 있다. 한가지 예시는 네트워크 다이몬이고 2.3.3.5에서 언급되었다. 이 예시에서는 시스템은 프로세스를 교정할 리퀘스트를 수행하기 위해 네트워크 연결을 들을 서비스가 필요하다. 다른 예시는 특정 스케쥴에 맞춰서 프로세스를 시작하는 프로세스 스케쥴러, 시스템 에러 모니터링 서비스, 프린터 서버가 있다. 몇몇 시스템은 수많은 다이몬이 있다. 덧붙여서, 유저 컨텍스트 보다는 커널 컨텍스트가 더 중요하게 여기는 운영체제는 다이몬을 이런 행동을 위해서 사용한다.

이런 시스템 프로그램들과 함께, 대부분의 운영체제는 일반 문제 해결이나 일반 명령을 수행하는 프로그램을 공급한다. 이런 앱프로그램은 웹브라우저, 워드프로세서, 텍스트 포매터, 스프레드시트, db 시스템, 컴파일러 등이 있다.

대부분의 유저들이 보는 운영체제의 관점은 실제 시스템 콜보다는 앱과 시스템 프로그램으로 이루어져있다. 유저의 컴퓨터가 macOS 운영체제를 돌리면, 유저는 GUI를 볼 것이고, 마우스와 윈도우 인터페이스를 기능한다. 윈도우에서는, 유저는 유닉스 쉘 커맨드 라인을 가진다. 두개다 같은 시스템 콜을 사용하지만, 시스템 콜은 다르게 보이고 다르게 행동한다. 유저의 관점에서 더헷갈리는 것은, 유저가 macOS에서 윈도우를 듀얼 부팅하는 것이다. 이제 같은 하드웨어의 같은 유저가 두개의 다른 인터페이스와 같은 물리 자원을 사용하는 앱을 사용한다. 이런 하드웨어에서 유저는 다중 유저 인터페이스를 겪을수 있다.

## 2.5 링커와 로더

일반적으로, 프로그램은 디스크에서 바이너리 실행파일로 거주한다. CPU에서 실행되려면, 프로그램은 만드시 메모리에 가져다지고 프로세스의 컨텍스트에 들어가야한다. 이 절에서는 우리는 이 과정을 설명하겠다. 프로그램 컴파일 부터 메모리에 옮겨서 CPU 코어가 사용 가능하게 만드는 것까지이다.

소스 파일들은 오브젝트 파일이라는 물리적 메모리 공간에 로드될수 있게끔 컴파일되는데 이 포맷은 **relocatable object file**이라고 불린다. 다음으로는, 링커가 relocatable object file을 단일 실행가능 바이너리 파일로 합친다. 링킹 단계에서, 다른 오브젝트 파일이나 라이브러리는 또한 포함된다.

**로더**는 바이너리 실행 파일을 메모리에 로드하는데 사용되는데 이것이 cpu 코어에서 작동하게 해준다. 링킹과 로딩에 관련된 활동은 **relocation**이고 프로그램 파트에 마지막 주소를 할당하고 프로그램 안의 코드와 데이터를 주소에 맞게 고정한다. 예를 들어 코드는 라이브러리 함수를 부르고 그것의 변수가 접근하게 해준다. 로더가 실행되게 필요한 것은 커맨드 라인에 실행 파일을 입력하는 것이다. 프로그램 이름이 유닉스 시스템의 커맨드 라인에 입력된다. 그러면 쉘은 먼저 새로운 프로세스를 프로그래밈이 실행하게 fork() 시스템 콜을 해준다. 그 쉘은 다음으로 exec() 시스템 콜과 로더를 실행하고 실행 파일의 이름을 exec()에 넘겨준다.

프로세스는 모든 라이브러리를 실행파일과 링크하고 메모리로 로드한다. 현실에서 대부분의 시스템은 프로그램이 동적으로 프로그램이 로드될때 라이브러리를 링크한다. 윈도우에서는 dynamically linked libraries(**DLLs**)를 지원한다. 이 방법의 장점은 실행파일에서 사용되지 않을 라이브러리를 부르고 링크하는 것을 피하는 것이다. 대신에, 라이브러리는 조건에 맞게 프로그램 런타임때마다 불려진다. 이것은 챕터 9에서 멀티프로세스가 라이브러리를 동적으로 공유해서 메모리 사용을 아끼는 것을 보게될 것이다.

오브젝트 파일과 실행파일은 커파일 머신 코드와 프로그램에서 언급된 함수와 변수 메타데이터를 포함한 심볼 테이블을 포함하고 있다. 유닉스와 리눅스 시스템에서, 이 표준 포맷은 ELF(**Excutable and Linkable Format**)이라는 것으로 알려져 있다. ELF 포멧은 relocatable과 실행 파일로 구별되어있다. 실행 파일을 위한 ELF의 한 정보 단편은 프로그램의 엔트리 포인트이고 프로그램이 실행될떄 첫번째 명령의 위치를 저장한다. 

## 2.6 왜 앱들은 운영체제 특성화인가?

기본적으로, 한운영체제에서 컴파일된 앱은 다른 운영체제에서는 실행되지 않는다. 만약 그들이 그랬다면, 세계는 더 나아지고, 어떤 운영체제를 선택할지는 어떤 앱이 가용한가보다는 유틸리티와 기능에 달려있을 것이다.

최근의 논쟁에 따르면, 우리는 문제의 부분을 볼수있는데, 각각의 운영체제는 특별한 시스템콜을 제공하는 것이다. 시스템 콜은 앱이 사용하는 운영체제가 제공한 서비스이다. 아무리 시스템 콜이 같아도, 다른 장벽들이 우리가 다른 운영체제에서 작동하기 힘들게 만든다. 만약 너가 다중 운영체제를 사용하면, 당신은 그들위에서 같은 앱을 사용하고있다. 어떻게 가능할까?

앱은 3가지 방법으로 다중 운영체제를 가능하게 한다.

1. 앱은 파이썬이나 루비같은 인터프리터 언어로 쓰일수 있는데 인터프리터는 여러가지 운영체제에서 가용하다. 인터프리터는 소스 프로그램의 각 줄을 읽고, 네이티브 명령어 셋을 동일하게 실행하고 네이티브 시스템 콜을 부른다. 성능은 네이티브 앱보다 떨어지지만, 인터프리터는 각각의 운영체제 기능을 지원해서, 비슷한 앱의 기능 셋을 제한하기도 한다.

2. 앱은 가상 머신을 포함한 언어로 쓰일 수 있다. 가상 머신은 언어의 풀 RTE 부분이다. 자바가 대표적이다. 자바는 로더를 포함한 RTE가 있고, 파이트 코드 명확자, 자바 가상 머신으로부터 자바 앱을 불러오는 구성요소가 있다. RTE는 많은 운영체제를 복사하고 개발하고 RTE가 존재하면 어디서든 실행되게 만들었다. 이런 시스템은 인터프리터와 비슷한 제약이 있다.

3. 앱 개발자가 스탠다드 언어 또는 컴파일러가 머신에서 이진수를 만드는 API와 운영체제 특정 언어를 사용하는 것이다. 앱은 반드시 각각의 운영체제에 맞게 작동하게 복사된다.이 복사는 시간이 꽤 걸리고 앱의 새로운 버전마다 진행되어야한다. 아마도 가장 좋은 예시는 포식스 API와 그것의 UNIX 운영체제와의 호환성이다.

이론으로는 이런 3가지 접근은 다른 운영체제속에서 앱을 개발하는 간단한 해결책을 제공한다. 그러나 앱 모빌리티의 부재는 크로스 플랫폼 앱을 만들기 힘들게 만든다. 앱의 레벨에서는, API를 포함한 운영체제 라이브러리가 제공되어야하고 앱은 API를 부를수 있게 디자인해야하는데 그 API를 제공하지 않는 운영체제에서는 일하지 않을 것이다. 다른 도전점은 시스템의 낮은 레벨에 있는데 다음과 같다.

- 각각의 운영체제는 헤더, 명령어, 변수의 레이아웃을 특정 마이너리 포맷으로 가지고 있다. 이런 구성은 실행 파일의 특정한 구조에 위치되어야한다. 그래서 운영체제가 파일을 열고 로드해서 앱을 적절하게 실행한다.

- CPU는 다양한 명령어 셋이 있고, 한개의 앱은 특정한 명령이 확실하게 실행하게하는 것을 포함한다.

- 운영체제는 앱이 파일 생성, 네트워크 연결 열기 같은 다양한 활동을 요청하는 앱을 허용하는 시스템 콜을 제공한다. 이런 시스템 콜은 많은 관점에서 운영체제 마다 다른데, 특별한 연산자와 연산 순서가 사용되고, 앱이 시스템 콜을 어떻게 생성하는지, 그들의 넘버링과 숫자, 그들의 의미, 그들의 결과 리턴등이 다양하다.

완벽하게 해결하지는 않지만, 이런 구조적 다름을 해결하는 여러가지 접근이 있다. 예를 들어, 리눅스, 대부분의 유닉스 시스템은, 이진 실행 파일을 위한 ELF 포맷을 채택했다. 비록 ELF 포맷이 특정 컴퓨터 구조에 묶여 있지는 않지만, 그것은 실행파일이 다른 하드웨어 플랫폼에서 운영되는 것을 보장한다.

APIs는 말했듯이, 앱 레벨에서 특정한 함수를 명시한다. 구조적인 레벨에서, **Application binary Inerface**는 주어진 운영체제 에서 바이너리 코드가 얼마나 다른지 보여준다. ABI는 낮은 레벨 상세를 주소 너비, 시스템콜을 전달하는 파라미터 방법, 런타임 스택, 시스템 라이브러리의 바이너리 포맷, 데이터타입의 사이즈를 포함한다. 보통, ABI는 주어진 구조에 맞게 특정화된다. 그러므로, ABI는 API와 구조적인 레벨에서는 같다. 만약 이진 실행 파일이 특정 ABI로 링크되고 컴파일되었다면, 그것은 그 ABI를 지원하는 다른 시스템에서 실행되어야한다. 그러나, 특정한 ABI는 전체적인 운영체제를 정의하는데, ABI는 크로스 플랫폼을 조금 지원한다.

요약하면, 모든 이런 다름은 인터프리터, RTE, 이진 실행파일이 특정 CPU 타입의 특정 운영체제를 위해서 쓰이고, 앱은 실행을 실패하는 것이다. 파이어 폭스 브라우저가 윈도우 맥 리눅스 아이오에서 안드로이드 몇가지 CPU 구조를 위해서 쓰는 것을 상상해보아라.