## what we gonna study

5장에서, 우리는 CPU가 어떻게 프로세스의 집합들에서 공유되는지 보였다. CPU 스케쥴링의 결과로, 우리는 CPU의 효율성과 유저로부터의 컴퓨터 반응 속도를 모두 향상시켰다. 이 성능의 증가를 느끼기위해서, 우리는 메모리에 많은 프로세스를 보관해야한다, 즉 우리는 반드시 메모리를 공유해야한다.

이 장에서, 우리는 메모리를 관리하는 다양한 방법을 논의하겠다. 메모리 관리 알고리즘은 기계적 접근부터 페이징과 같은 전략 사용이 있다. 각각의 접근은 장점과 단점을 가지고 있다. 특정 시스템을 위한 메모리 관리 메서드의 선택은 시스템의 하드웨어 디자인과 특히 관련이 있다. 우리는 대부분의 알고리즘이 하드웨어 지원이 필요하고, 많은 시스템들이 하드웨어와 운영체제 메모리 관리의 통합하는 것을 볼 것이다.

## Objectives

- 물리적, 논리적 주소 사이의 차이와 Memory management unit(MMU)의 주소 번역 역할을 설명한다.
- 연속적 메모리 할당의 first-, best-, worst-fit 전략을 적용한다.
- 내부와 외부 단편화의 차이를 설명한다.
- Translation look-aside buffer(TLB)를 포함한 페이징 시스템속의 논리->물리적 주소 번역을 살펴본다.
- 계층적 페이징, 해쉬 페이징, inverted page tables를 본다.
- IA-32, x86-64, ARMv4 구조의 번역을 설명한다.

## 9.1 Background

1장에서 보았듯이, 메모리는 운영체제 시스템의 명령어에 집중한다. 메모리는 거대한 바이트의 행렬을 포함하고, 각각의 주소를 가진다. CPU는 명령어를 매모리로부터 프로그램 카운터의 값에 따라서 가지고 온다. 이런 명령어들은 특정한 메모리 주소로부터 로딩하고, 주소에 저장한다. 

전형적인 명령어 실행 주기는, 먼저 메모리로부터 명령어를 가지고 온다. 명령어는 해독되고 메모리로 부터 피연산함수를 가지고 오게한다. 명령어가 피연산함수에서 실행된 후에, 결과는 다시 메모리에 저장된다. 메모리 유닛은 오직 메모리 주소의 스트림만 본다. 그것은 그들이 어떻게(명령어 카운터, 인덱싱, 비간접, 리터럴 주소 등) 생성되었는지를 모르고, 그들이 무엇(명령어, 데이터)을 위해서 생성되었는지 모른다.  이에 따라서, 우리는 프로그램이 어떻게 메모리 주소를 생성했는지 무시해도 된다. 우리는 오직 프로그램을 실행하면서 생긴 메모리 주소의 시퀀스만 보면된다. 

우리는 우리의 논의를 메모리 관리에 적절한 이슈를 살펴보겠다. 기초 하드웨어, 심벌릭(가상) 메모리 주소에서 실제 물리주소, 논리와 물리 주소의 차이가 있을 것이다. 우리는 이 절의 마무리를 동적 링킹과 공유 라이브러리로 결론 짓겠다.

### 9.1.1 기초 하드웨어

각 프로세싱 코어 속에 내장된 메인 메모리와 레지스터는 CPU만 직접 접근 가능한 저장소이다. 메모리 주소를 인자로 받는 기계 명령어는 있지만, 디스크 주소를 받는 것은 없다. 그러므로, 실행중인 명령어, 명령에 사용되는 데이터는 반드시 이 직접 접근 저장 장치에 있어야한다. 만약 데이터가 메모리에 없으면, 그들은 CPU가 실행하기전에 반드시 이동되어야한다.

각 CPU에 내장된 레지스터는 CPU 클락의 한번의 사이클로 보통 접근이 가능하다. 몇몇 CPU 코어들은 래지스터 내용물의 명령어 해독과 간단한 명령어는 클락 틱의 한번에 보통 해결가능하다. 메모리에서는 같지 않을 것인데, 접근이 메모리 버스의 트랜잭션으로 이루어지기 때문이다. 메모리 엑세스 완료는 CPU 클락의 몇 사이클이 걸릴 수도 있다. 이런 경우에는, 프로세서는 보통 **stall**이 필요한데, 그것은 실행중인 명령어를 완료하는데 데이터를 필요로하지 않기 때문이다. 이 상황은 편협적인데, 메모리 접근의 주기 때문이다. 그 치료는 CPU와 메인 메모리 사이의 빠른 메모리를 추가한다. 이런 캐시는 1.5.5에서 설명했다. CPU의 내장 캐시를 관리하려면, 하드웨어는 자동적으로 운영체제의 관리 없이 메모리 접근의 속도를 올려야한다.(5.5.2에서 메모리 스톨을 설명했고, 멀티 스레드 코어가 스톨된 하드웨어 스레드에서 다른 하드웨어 스레드로 교체하는 것이다.) 

물리 메모리의 상대적인 속도에 대한 고려뿐만 아니라, 우리는 적절한 명령을 해야한다. 적절한 시스템 명령을 위해서, 우리는 반드시 운영체제로부터 유저 프로세스로의 접근을 막아야한다. 물론 유저 프로세서끼리의 접근도 마찬가지이다. 이 보호는 반드시 하드웨어에 의해서 제공되어야하는데, 운영체제는 CPU와 그것의 메모리 접근사이에 개입하지 않기 때문이다. 하드웨어는 이 생산을 몇가지 다른 방식으로 구현하고, 이 챕터에서 보일 것이다. 여기서, 우리는 한가지 가능한 구현을 보이겠다.

우리는 먼저 각 프로세스가 개별의 메모리 공간을 가지게 한다. 프로세스 메모리 공간별 구분은 프로세스끼리를 보호하고 동시 실행을 위한 다양한 프로세스 메모리 적재를 위해서 기초적이다. 메모리 공간을 분리하기 위해서, 우리는 프로세스가 오직 그 프로세스만이 접근가능한 법적 허용 주소를 가지고 있어야한다. 우리는 이 보호를 두개의 레지스터를 사용해서 제공하고, 보통은 베이스와 리미트가 있다. **base register**는 합법 물리 메모리 주소의 가장 작은 값을 가지고, **limit memory**는 범위의 크기를 정의한다. 예를 들어서, 만약 기본 레지스터가 300040이고 리미트 레지스터가 120900이면, 프로그램은 30040부터 420939까지 접근이 가능하다.

메모리 공간의 보호는 유저모드에서 생성된 모든 주소를 비교해서 CPU 하드웨어를 가지는 것으로 완료된다. 유저모드에서 실행하는 프로그램의 운영체제 메모리 또는 다른 유저의 메모리 접근은 어떤 시도든 운영체제에 의해서 트랩되고, 치명적인 오류로 다루어진다. 이런 구조는 유저 프로그램이 운영체제나 다른 유저의 코드나 데이터 구조를 변조하는 것을 방지한다.

베이스와 리미트 레지스터는 오직 운영체제에 의해서만 로드되는데, 특별한 우선순위 명령어를 사용한다. 우선 순위 명령어는 커널 모드에서만 실행 가능하고, 운영체제만이 베이스와 리미트 레지스터를 로딩한다. 이 구조는 운영체제가 레지스터의 값을 바꾸는 것을 허용하면서 유저 프로그램이 레지스터의 컨텐츠를 바꾸는 것을 방지한다.

운영체제에서, 커널모드로 실행하는 것은, 운영체제 메모리와 유저 메모리의 통제되지 않은 접근을 준다. 이 공급은 운영체제가 유저의 프로그램을 유저의 메모리에 담게 해주고, 에러인 프로그램을 덤프아웃시키고, 시스템콜의 파라미터를 접근하고 수정하고, 유저 메모리로부터 I/O를 실행하고, 다양한 서비스를 제공한다. 예를 들어서, 멀티 프로세싱 시스템 시스템은 반드시 컨텍스트 스위치를 실행한다. 다음 프로세스의 컨텍스트가 메인메모리에서 레지스터로 로딩되기 전에 한가지 프로세스의 상태를 레지스터에서 메인메모리에 저장한다.

## 9.1.2 Address Binding

일반적으로, 디스크에 바이너리 실행파일로 프로그램은 자리잡고 있다. 실행하기 위해서, 프로그램은 반드시 메모리로 가지고 와야하고 가용한 CPU의 실행을 할 수 있는 프로세스의 컨텍스트에 위치해야한다. 프로세스가 실행되면, 그것은 메모리로부터 명령어와 데이터에 접근한다. 마침내, 프로세스가 종료되면, 그것의 메모리는 다른 프로세스의 사용을 위해 재정의된다.

대부분의 시스템은 유저 프로세스가 물리 메모리에 거주하게 허용한다. 그러므로, 비록 컴퓨터의 주소 공간이 00000에서 시작해도, 유저 프로세스의 시작 주소는 00000일 필요가 없다. 너는 어떻게 운영체제가 실제로 물리 메모리에 프로세스를 배치하는지 볼 것이다.

대부분의 사례에서, 유저 프로그램은 몇가지 단계를 거쳐가고, 몇몇은 실행전에 선택지가 있다. 주소는 이런 스템 동안 다른 방법으로 대표된다. 컴파일러는 대개 이런 심볼릭 주소를 relocatable 주소(모듈의 시작으로부터 14바이트)로 **binds**한다. 링커 또는 로더(2.5절)는 relocatable 주소를 절대 주소로 **binds**한다. 각 바인딩은 한가지 주소공간을 다른 것으로 매핑한다.

전통적으로, 명령어와 데이터의 바인딩부터 메모리 주소는 다음 방법으로 실행된다.

- Compile time. 만약 너가 프로세스가 거주할 메모리인 컴파일 시간을 알면, **absolute code**는 생성될 수 있다. 예를 들어서, 만약 너가 유저 프로세스가 위치 R로부터 시작하는 것을 알면, 생성된 컴파일러 코드는 그 주소에서 시작하고 그 주소에서 확장될 것이다. 만약, 어느정도 후에, 시작 점이 바뀌면, 그것은 이 코드를 반드시 리컴파일 해야한다.
- Load time. 만약 compile time을 모르면, 컴파일러는 **relocatable code**를 생성해야한다. 이런 경우에, 마지막 바인딩은 로드 타임까지 지연된다. 만약 시작 주소가 바뀌면, 너는 이 변화에 맞지 않게 바뀐 유저코드를 다시 로드해야한다.
- Excution time. 만약 프로세스가 그것의 실행중에 다른 메모리 세그먼트로 이동하면, 바인딩은 반드시 런타임까지 지연되어야한다. 특별한 하드웨어가 이 구조에 적합하고 9.1.3에서 다루겠다. 대부분의 운영체제가 이 방법을 사용한다.

이 장의 가장 큰 부분은 어떻게 다양한 바인딩이 컴퓨터 시스템에서 구현되는 것을 보여주고 적절한 하드웨어 지원을 토론한다.

