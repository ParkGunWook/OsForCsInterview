## what we gonna study

이 장에서, 우리는 컴퓨터의 비휘발성 대량 저장소가 어떻게 구성되는지 보겠다. 주요 대량 저장소 시스템은 2차 저장소이고, HDD와 NVM을 통해서 제공된다. 몇몇 시스템은 더욱 크고 3차저장소인 자기 테이프, 광학 디스크, 클라우드 저장소를 가진다.

현대에서 가장 중요하고 일반적인 저장소는 HDD와 NVM이고, 두 저장소에 대한 설명이 대부분일 것이다. 우리는 I/O의 성능을 최대화하는 스케쥴링 알고리즘을 살펴보겠다. 다음으로, 우리는 디바이스 포매팅과 부트 블럭 관리, 손상 블럭, 스왑스페이스에 대해서 논의하겠다. 마지막으로, RAID 시스템의 구조를 확인하겠다.

대량 저장소에는 다양한 종류가 있고, 우리는 보통 *nonvolatile storage(NVS)*라고 부른다. 그리고 모든 타입의 기기를 일반적으로 "drives"라고 표현하겠다. HDD와 NVM같은 특정 기기는 정확하게 정의될 것이다.

## objectives

- 다양한 2차 저장소의 물리적인 구조와 사용에 맞게 디바이스의 구조 효과를 설명하겠다.
- 대량 저장 기기의 성능 성질을 설명하겠다.
- I/O 스케쥴링 알고리즘을 평가하겠다.
- RAID를 포함한 대량 저장소를 위해 운영체제가 제공하는 서비스를 보겠다.

## 11.1 Mass-Storage Structure

현대 컴퓨터의 2차 저장소는 대부분 **hard disk drives(HDDs)**와 **nonvolatile memory(NVM)**으로 제공된다. 이 절에서, 우리는 이런 기기의 메커니즘을 설명하고 어떻게 운영체제가 주소 매핑을 통해서 그들의 물리적 공간을 논리주소로 번역하는지 보겠다.

### 11.1.1 Hard Disk Drives

개념적으로, HDD들은 꽤나 단순하다. 각 디스크 **platter**는 평평한 원형이다. 일반적인 플래터 지름은 1.8~3.5인치이다. 플래터의 두 표면은 자성 물질로 덮여있다. 우리는 플래터위에서 자기적으로 저장하고, 우리는 플래터위의 자기적인 패턴을 감지해서 정보를 읽는다.

읽기-쓰기 헤드는 모든 플래터의 위에 있다. 그 헤드들은 헤드를 하나의 유닛처럼 움직여주는 **disk arm**에 붙어있다. 플래터의 표면은 **sector**로 다시 나누어지는 원형 **tracks**로 논리적으로 나누어진다. 주어진 암 위치의 트랙의 집합은 **cylinder**를 만든다. 디스크 드라이브에는 수천개의 동심원 실린더가 있고, 각 트랙은 수천개의 섹터를 가진다. 각 섹터는 고정된 크기를 가지고 전송의 최소 단위이다. 섹터 크기는 2010년에는 512바이트였다. 그 시점에서, 많은 제조사들이 4KB 섹터로 이전하기 시작했다. 일반적으로 디스크의 커패시티는 기가바이트와 테라바이트이다. 

디스크 드라이브 모터는 높은 속도로 회전한다. 대부분의 드라이브는 초당 60~250번을 회전하고 **rotations per minutes(RPM)**이라고 부른다. 일반적인 드라이브는 5400, 7200, 10000, 15000의 RPM을 가진다. 몇몇 드라이브는 사용되지 않거나 I/O 요청을 기다릴때까지 전원을 꺼둔다. 회전 속도는 전송 속도와 관계가 있다. **Transfer rate**는 드라이브와 컴퓨터 사이에 데이터가 흐르는 속도이다. 다른 성능 측면은 **positioning time**또는 **random-access time**은 두가지 부분으로 구성된다. 첫번쨰는 원하는 실린더에 디스크 암을 이동시키는 **seek time**이고 원하는 섹터를 회전시키는 **rotational latency**이다. 일반적인 디스크는 초당 100메가바이트를 전송하고, 그들은 탐색 시간과 회전 지연에 걸리는 시간은 몇 미리초에 불과하다. 그들은 드라이브 컨트롤러에 DRAM 버퍼르 가짐으로서 성능을 향상시킬 수 있다.

디스크 헤드 파일들은 헬륨 같은 가스로 이루어진 극단적으로 얇은 쿠션위에 있고, 헤드가 디스크 표면을 접촉할 위험이 있다. 디스크 플래터가 얇은 보호막으로 코팅되어도, 헤드는 자기 표면을 손상시킨다. 이런 사고를 **head crash**라고 부른다. 이 사고는 고쳐질 수 없다. 전체 디스크는 교체되어야하고, 데이터의 디스크는 다른 저장소에 백업 되거나 RAID로 보호되있지 않으면 영영 사라진다.

HDDs들은 봉인된 유닛이고, 몇몇 HDD를 쥐고 있는 chassis는 시스템의 종료나 저장소 chassis없이 그들의 제거를 허용한다. 이것은 시스템이 더 많은 저장소를 필요로하거나 그것이 배드드라이브를 일하는 것과 교체하기 위해서 필요하다. 다른 타입의 저장 미디어도 **removalble**하다.

### 11.1.2 Nonvolatile Memory Devices

NVM 디바이스는 점점 중요해지고 있다. 간단히 말하면 NVM 장치는 기계라기보다는 전기적인 장치이다. 가장 일반적으로, 이런 디바이스는 컨트롤러와 플래시 NAND 반도체 칩으로 구성되어있다. 다른 NVM 기술은 존재하는데, 배터리가 있는 DRAM은 그것의 컨텐츠를 잃지않고, 그러나 그들은 덜 일반적이고 책에서 다루지 않는다.

#### 11.1.2.1  Overview of NVM

NVM 베이스의 플래시 메모리는 컨테이너 같은 디스크 드라이브에서 사용되고, **solid state disk**라고 부른다. 다른 예시로는 **USB drive**또는 DRAM 스틱이 있다. 그것은 또한 스마트폰 기기에서 메인 저장소로서 마더보드의 위에 마운트되어있다. 모든 형태에서, 그것은 같은 방식으로 작동한다. NVM 기기의 주된 논의는 이 기술에 대한 것이다.

NVM 기기는 움직이는 부분이 없기 때문에 HDD보다 믿음직하고 탐색시간이나 회전 지연이 없기 때문에 더욱 빠르다. 추가적으로 그들은 적은 파워를 소모한다. 부정적인 측면은, 그들은 고전적인 하드디스크보다 비싸고 큰 하드디스크보다 적은 용량을 가진다. 시간에 걸쳐서, NVM 디바이스의 용량은 하드디스크의 용량 증가속도를 넘어섰고, 그들의 가격은 더욱 빠르게 떨어지고 있다. 그래서 그들의 사용은 급격히 증가하고 있다. 실제로, SSDs와 비슷한 기기는 더 작고 빠르고 에너지 효율적인 랩탑을 위해서 사용되고 있다.

NVM 기기가 하드디스크보다 더욱 빠르기 때문에, 표준 버스 인터페이스는 산출량에 주요한 리미트를 초래한다. 몇몇 NVM 기기들은 시스템 버스(PCIe)에 직접 연결되게 디자인된다. 이 기술은 전통적인 컴퓨터 디자인을 바꾸고 있다. 몇몇 시스템은 디스크 드라이브의 직접 교체로 사용하고, 그것을 새로운 캐시 티어에 넣기도하고, 성능을 최적화하기 위해서 자기 디스크, NVM, 메인 메모리 사이의 데이터를 움직인다.

NAND 반도체는 그들의 저장소와 신뢰성 문제를 가직 있다. 예를 들어서, 그들은 "page" 증가(섹터와 비슷하다.)를 통해서 읽고 쓰는데, 그러나 데이터는 NAND 셀이 지워지기 이전에는 덮어쓰기가 안된다. "block" 증가를 초래하는 삭제는 크기가 여러 페이지이고, 읽기나 쓰기보다 훨씬 많은 시간이 필요하다. 이 상황을 돕기위해서 NVM 플래시 디바이스는 각각이 데이터 패스로 연결된 여러가지 금형으로 이루어져있고, 그래서 명령어는 병렬적으로 일어날 수 있다. NAND 반도체는 또한 여러 삭제 사이클에 의해서 감소되고, 100000 프로그램 삭제 사이클 후에, 각 셀은 더이상 데이터를 보관할 수 없다. write wear 때문에, 더이상 움직일 수 없는 파트때문에, NAND NVM 수명주기는 년단위가 아니라 **Drive Writes Per Day(DWPD)**로 측정된다. 그 측정은 드라이브가 고장나기 전까지 드라이브가 매일 쓸수있는지를 측정한다. 예를 들어서 5DWPD를 가진 1TB NAND 드라이브는 보장기간동안 5TB를 매일 쓸수있다.

이런 제한은 몇가지 개선 알고리즘을 이끌었다. 다행히도, 그들은 NVM 기기에 구현이 되었고 운영체제의 역할이 아니다. 운영체제는 단순히 논리 블럭을 읽고 쓰고, 디바이스는 어떻게 되는지 매니지한다. 그러나, NVM 디바이스는 운영체제 알고리즘에 따라서 다양한 성능을 가지고, 그래서 컨트롤러가 무엇을 하는지에 대한 간단한 설명이 필요하다.

#### 11.1.2.2 NAND Flash Controller Algorithms

NAND 반도체가 한번 쓰이면 덮어쓰기가 안되기에, invalid 데이터를 포함한 페이지가 있다. 파일 시스템 블럭을 고려하면, 한번 쓰이고 후에 다시 쓰인다. 만약 그 기간동안 삭제가 일어나지 않으면, 페이지는 예전 데이터를 가지고, 현재는 invalid하다. 그리고 두번째 페이지가 현재의 정확한 버전의 블럭을 가진다. 유효하고 유효하지 않은 페이지를 NAND 블럭이 포함하고 있다. 어떤 논리 블럭이 유효 데이터를 가지고 이쓴지 추적하기 위해서, 컨트롤러는 **flash translation layer**를 유지한다. 이 테이블은 어떤 물리 페이지가 현재 유효 논리 블럭을 가진지 매핑한다. 그것은 또한 물리 블럭 상태를 추적하고 어떤 블럭이 유효하지 않은 페이지를 포함한지 확인하고 삭제시킨다.

이제 쓰기 요청을 기다리는 full SSD를 고려하자. SSD가 가득 찼기 때문에, 모든 페이지들은 쓰여있고, 그러나 이 상황에서 블럭들은 유효 데이터가 없을 수도 있다. 이런 경우에, 쓰기는 삭제가 이루어지기를 기다릴 수 있고, 그후에 쓰기가 일어난다. 그러나 만약 여유 블럭이 없다면 어떻게 될까? 만약 페이지들이 invalid data를 포함한다면 가용한 공간이 있을 것이다. 그런 경우에는, **garbage colletion**이 일어나고 좋은 데이터는 다른 공간에 복사되고 블럭을 깔끔히 한후에 쓰기 요청을 받을 수 있다. 그러나, 가비지 컬렉션은 어디에 좋은 데이터를 저장할까? 이 문제를 해결하고 쓰기 성능을 증가시키기 위해서, NVM 디바이스는 **overprovisioning**을 사용한다. 디바이스는 쓸 수 있는 페이지를 보통 전체의 20%정도로 유지한다. 가비지 컬렉션에 의해서 완벽히 유효하지 않은데이터, 데이터의 오래된 버전들은 over porvisioning 공간에 두고 만약 디바이스가 가득차면 여유 풀로 리턴한다.

over provisioning 공간은 **wear leveling**을 돕는다. 만약 몇몇 블럭이 반복적으로 지워지면, 그 지워지는 블럭은 다른 것들보다 빨리 닳고, 전체 기기는 만약 블럭이 동시적으로 닳는 것보다 짧은 수명주기를 가질 것이다. 컨트롤러는 적게 삭제된 블럭에 데이터를 위치해서 전체기기의  닳은 정도의 밸런스를 맞추는 다양한 알고리즘을 사용한다.

데이터 보호에서, NVM 디바이스는 에러 수정 코드를 제공하는데, 데이터를 읽고 쓰는 과정에서 에러를 찾아내고 고치는 것을 저장하고 계산한다. 만약 페이지가 자주 에러를 가지면, 페이지는 나쁘다고 마킹되고 다음 쓰기에서 사용되지 않는다. 일밙적으로, 단일 NVM 기기는 정보가 썩거나 쓰기/읽기 요청에 답하지 못할때 재앙적인 실패를 가진다. 이런 것을 복구하기 위해서 RAID 보호가 사용된다.

### 11.1.3 Volatile Memory

대량 저장소 구조에 관한 장에서 휘발성 메모리를 논의하는 것은 이상할 수 있는데, 그것은 DRAM이 대량 저장 디바이스로 쓰이기 때문에 정당화가 가능하다. 특히, **RAM drives**(RAM 디스크라고도 불림)는 2차 저장소로 역할하지만, 시스템의 DRAM에서 발굴한 디바이스 드라이버에 의해서 생성되고 그것이 저장소였던 것처럼 작동한다. 이런 "drives"들은 raw block devices로 쓰일 수있고, 더욱 일반적으로, 파일 시스템들이 일반적인 파일 명령어로 생성된다.

컴퓨터들은 이미 버퍼링가과 캐싱을 가지는데, 그래서 임시 데이터 저장소를 위한 DRAM의 다른 목적은 무엇일까? DRAM은 휘발성이기에, RAM 드라이브의 데이터는 시스템 크래시, 종료, 파워 다운에서 살아남지 못한다. 캐시들과 버퍼들은 프로그래머 또는 운영체제에 의해서 할당되지만, RAM 드라이브는 일반적인 파일 명령어를 통해서 메모리에 둘 수 있다. 실제로, 램 드라이브 기능은 대부분의 운영체제에서 사용된다. 리눅스에서, /dev/ram, 맥에서는 diskutil 커맨드, 윈도우는 서드파티 툴, 솔라리스와 리눅스는 /tmp를 부트 시간에 만들고 그것이 RAM 드라이브이다.

램 드라이브들은 높은 속도의 임시 저장 공간에서 유용하다. 비록 NVM이 빨라도, DRAM이 더욱 빠르고, RAM 드라이브의 I/O 명령어는 생성, 읽기, 쓰기, 삭제가 그 무엇보다도 빠르다. 많은 프로그램들은 임시 파일을 저장하기 위해서 RAM 드라이브를 사용한다. 예를 들어서 프로그램들은 RAM 드라이브로의 공유 데이터를 통해서 읽기 쓰기를 쉽게 구현한다. 다른 예시로는, 리눅스는 시스템의 다른 파트를 루트 파일과 그것의 컨텐츠 엑세스를 가지는 것을 허용하는 임시 루트 파일 시스템(`initrd`)을 운영체제의 다른 파트가 저장 디바이스를 로드하기 전에 부트시간에 만든다.

### 11.1.4 Secondary Storage Connection Methods

2차 저장소 기기는 시스템 버스 또는 **I/O bus**로 연결되어있다. 몇가지 버스가 존재하는데, **advanced technology attatchment(ATA)**, **seral ATA(SATA)**, **eSATA**, **serial attatched SCSI(SAS)**, **universal serial bus(USB)**와 **fibre channel(FC)**가 있다. 대부분의 일반적인 연결 방식은 SATA이다. NVM 기기들이 HDD보다 빠르기 때문에, NVM 디바이르를 위한 빠른 인터페이스인 **NVM express(NVMe)**가 있다. NVMe는 시스템 PCI 버스로 연결되어있고, 산출량이 증가하고 다른 연결방식에 비해서 낮은 지연율을 가진다.

버스에서의 데이터 통신은 특별한 전자 프로세서인 **controllers**(or **host-bus adapters(HBA)**)를 통해서 전달한다. **host controller**는 컴퓨터 버스의 끝단에 있다. 대량 저장소 I/O 명령어를 실행하기 위해서, 컴퓨터는 호스트 컨트롤러에 명령을 주는데, 메모리 매핑 I/O 포트를 이용한다. 호스트 컨트롤러는 메시지를 통해서 커맨드를 전송하고 컨트롤러는 커맨드를 가져오기 위해서 드라이브 하드웨어를 실행한다. 디바이스 컨트롤러는 대개 캐시안에 있다. 드라이브에서의 데이터 전송은 캐시와 저장 매체에서 일어나고, 데이터는 호스트에게 빠른 전자 속도로 전달되고, DMA를 통해서 캐시 호스트 DRAM으로 일어난다.

### 11.1.5 Address Mapping

저장기기들은 **logical blocks**의 일차원 행렬로 가르쳐지고, 논리 블럭은 전송의 가장 단위이다. 각 논리 블럭은 물리 섹터 또는 반도체 페이지에 매핑된다. 섹터 0은 HDD의 실린더 가장 외각의 첫번째 트랙의 첫번째 섹터이다. 매핑은 트랙을 따라서, 실린더의 나머지 트랙을 따라서, 나머지 외부에서 내부의 실린더를 따라서 진행된다. NVM의 매핑은 칩의 튜플, 블럭, 페이지로 이루어진다. logical block address(**LBA**)는 섹터, 실린더, 헤드 튜플 또는 칩, 블럭, 페이지 튜플보다 알고리즘을 사용하기 간단하다. 

HDD의 매핑을 사용함으로서, 우리는 논리 블럭 넘버에서 구식 디스크로 전환하는 것을 배울수 있다. 실전에서는, 이 번역을 행하는 것은 3가지 이유때문에 어렵다. 첫번째, 대부분의 드라이브는 손상된 섹터가 존재하지만, 매핑은 이런 것을 드라이브의 어떤 스페어 섹터로 대체해서 숨겨버린다. 논리 블럭 주소는 연속적이지만, 물리 섹터 위치는 변했다. 두번쨰, 트랙의 섹터 수는 몇몇 드라이브에서 상수가 아니다. 세번째, 디스크 생산자는 LBA에서 물리 주소 매핑을 내부적으로 관리하고 그래서 현재의 드라이브에서, LBA와 물리 섹터의 관계는 적어졌다. 물리 주소의 예측 밖의 변화때문에, HDD와 대응하는 알고리즘은 논리 주소를 논리 주소는 상대적으로 물리 주소에 상관있다고 가정하는 경향이 있다. 즉, 논리 주소가 증가하는 것은 물리주소도 증가하는 것이다.

2번째 이유에 대해서 깊게 살펴보자. **constant linear velocity(CLV)**를 사용하는 미디어에서, 트랙 당 비트의 밀도는 일정하다. 트랙이 디스크의 센터에서 멀수록, 그것의 길이는 더크고, 그래서 더 많은 섹터를 가질 수 있다. 우리가 바깥에서 안쪽으로 이동하면, 트랙당 섹터의 수는 감소한다. 가장 밖의 트랙은 가장 안쪽 보다 40퍼센트나 많은 섹터를 가질 수 있다. 드라이브는 그것의 회전속도가 헤드가 안쪽으로 들어갈수록 빠르게 해서 헤드 아래에서 같은 속도를 갖게끔한다.  이 방법은 CD-ROM과 DVD-ROM에서 주로 쓰인다. 대안으로, 디스크 회전속도는 상수로 머물 수 있다. 이런 경우에, 안쪽에서 바깥 트랙의 비트의 밀도는 감소하므로 데이터 속도는 일정하다. 하드 디스크에서의 이런 메서드는 **constant angular velocity(CAV)**라고 한다.

## 11.2 HDD 스케쥴링
